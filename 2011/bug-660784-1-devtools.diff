# HG changeset patch
# Date 1306843181 -10800
# User Mihai Sucan <mihai.sucan@gmail.com>
# Parent 6d63840e3a49f2be371acec15ec6e4a44dceab13
Bug 660784 - Add a source code editor to the browser

diff --git a/browser/base/Makefile.in b/browser/base/Makefile.in
--- a/browser/base/Makefile.in
+++ b/browser/base/Makefile.in
@@ -52,16 +52,17 @@ CHROME_DEPS += $(abs_srcdir)/content/ove
 ifdef ENABLE_TESTS
 DIRS += content/test
 endif
 
 EXTRA_JS_MODULES = \
 	content/openLocationLastURL.jsm \
 	content/NetworkPrioritizer.jsm \
 	content/domplate.jsm \
+	content/source-editor.jsm \
 	$(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
 PRE_RELEASE_SUFFIX := ""
 
 DEFINES += \
 	-DMOZ_APP_VERSION=$(MOZ_APP_VERSION) \
diff --git a/browser/base/content/orion/LICENSE b/browser/base/content/orion/LICENSE
new file mode 100644
--- /dev/null
+++ b/browser/base/content/orion/LICENSE
@@ -0,0 +1,29 @@
+Eclipse Distribution License - v 1.0
+
+Copyright (c) 2007, Eclipse Foundation, Inc. and its licensors.
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice, this
+  list of conditions and the following disclaimer in the documentation and/or
+  other materials provided with the distribution.
+* Neither the name of the Eclipse Foundation, Inc. nor the names of its
+  contributors may be used to endorse or promote products derived from this
+  software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
diff --git a/browser/base/content/orion/Makefile.dryice.js b/browser/base/content/orion/Makefile.dryice.js
new file mode 100755
--- /dev/null
+++ b/browser/base/content/orion/Makefile.dryice.js
@@ -0,0 +1,69 @@
+#!/usr/bin/env node
+/* vim:set ts=2 sw=2 sts=2 et tw=80:
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Source Editor component.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Mihai Sucan <mihai.sucan@gmail.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK *****/
+
+var copy = require('dryice').copy;
+
+const ORION_EDITOR = "org.eclipse.orion.client.editor";
+const ORION_CORE = "org.eclipse.orion.client.core";
+const ORION_BUILD = "org.mozilla.orion.build";
+
+var src = copy.createDataObject();
+
+copy({
+  source: [
+    ORION_EDITOR + "/web/samples/styler.js",
+    ORION_EDITOR + "/web/samples/rulers.js",
+    ORION_EDITOR + "/web/samples/undoStack.js",
+    ORION_EDITOR + "/web/js/editor.js",
+    ORION_EDITOR + "/web/js/model.js",
+  ],
+  dest: src,
+});
+
+copy({
+    source: src,
+    dest: ORION_BUILD + '/orion.js',
+});
+
+copy({
+    source: src,
+    filter: [copy.filter.uglifyjs],
+    dest: ORION_BUILD + '/orion.min.js',
+});
+
diff --git a/browser/base/content/orion/README b/browser/base/content/orion/README
new file mode 100644
--- /dev/null
+++ b/browser/base/content/orion/README
@@ -0,0 +1,4 @@
+This is the Orion editor packaged for Mozilla.
+
+The Orion editor web site: http://www.eclipse.org/orion
+
diff --git a/browser/base/content/orion/orion.css b/browser/base/content/orion/orion.css
new file mode 100644
--- /dev/null
+++ b/browser/base/content/orion/orion.css
@@ -0,0 +1,93 @@
+.editor {
+	background-color: white;
+}
+
+.editorContainer {
+	font-family: monospace;
+	font-size: 10pt;
+}
+
+.editorContent {
+}
+
+.token_comment {
+	color: green;
+}
+
+.token_javadoc {
+	color: #00008F;
+}
+
+.token_string {
+	color: blue;
+}
+
+.token_keyword {
+	color: darkred;
+	font-weight: bold;
+}
+
+.token_bracket_outline {
+	outline: 1px solid red;
+}
+
+.token_bracket {
+	color: white;
+	background-color: grey;
+}
+
+.token_space {
+	background-image: url('/editor/samples/white_space.png');
+	background-repeat: no-repeat;
+ 	background-position: center center;
+}
+
+.token_tab {
+	background-image: url('/editor/samples/white_tab.png');
+	background-repeat: no-repeat;
+ 	background-position: left center;
+}
+
+.line_caret {
+	background-color: #EAF2FE;
+}
+
+.ruler_annotation {
+	background-color: #e1ebfb;
+	width: 16px;
+}
+
+.ruler_annotation_todo {
+}
+
+.ruler_annotation_todo_overview {
+	background-color: lightgreen;
+	border: 1px solid green;
+}
+
+.ruler_annotation_breakpoint {
+}
+
+.ruler_annotation_breakpoint_overview {
+	background-color: lightblue;
+	border: 1px solid blue;
+}
+
+.ruler_lines {
+	background-color: #e1ebfb;
+	border-right: 1px solid #b1badf;
+	text-align: right;
+}
+
+.ruler_overview {
+	background-color: #e1ebfb;
+}
+
+.ruler_lines_even {
+	background-color: #e1ebfb;
+}
+
+.ruler_lines_odd {
+	background-color: white;
+}
+
diff --git a/browser/base/content/orion/orion.js b/browser/base/content/orion/orion.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/orion/orion.js
@@ -0,0 +1,6421 @@
+/*******************************************************************************
+ * Copyright (c) 2010, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ ******************************************************************************/
+
+/*global document window navigator */
+
+var eclipse = eclipse || {};
+
+eclipse.TextStyler = (function() {
+
+	var JS_KEYWORDS =
+		["break", "continue", "do", "for", /*"import",*/ "new", "this", /*"void",*/ 
+		 "case", "default", "else", "function", "in", "return", "typeof", "while",
+		 "comment", "delete", "export", "if", /*"label",*/ "switch", "var", "with",
+		 "abstract", "implements", "protected", /*"boolean",*/ /*"instanceOf",*/ "public", 
+		 /*"byte", "int", "short", "char",*/ "interface", "static", 
+		 /*"double", "long",*/ "synchronized", "false", /*"native",*/ "throws", 
+		 "final", "null", "transient", /*"float",*/ "package", "true", 
+		 "goto", "private", "catch", "enum", "throw", "class", "extends", "try", 
+		 "const", "finally", "debugger", "super", "undefined"];
+
+	var JAVA_KEYWORDS =
+		["abstract",
+		 "boolean", "break", "byte",
+		 "case", "catch", "char", "class", "continue",
+		 "default", "do", "double",
+		 "else", "extends",
+		 "false", "final", "finally", "float", "for",
+		 "if", "implements", "import", "instanceof", "int", "interface",
+		 "long",
+		 "native", "new", "null",
+		 "package", "private", "protected", "public",
+		 "return",
+		 "short", "static", "super", "switch", "synchronized",
+		 "this", "throw", "throws", "transient", "true", "try",
+		 "void", "volatile",
+		 "while"];
+
+	var CSS_KEYWORDS =
+		["color", "text-align", "text-indent", "text-decoration", 
+		 "font", "font-style", "font-family", "font-weight", "font-size", "font-variant", "line-height",
+		 "background", "background-color", "background-image", "background-position", "background-repeat", "background-attachment",
+		 "list-style", "list-style-image", "list-style-position", "list-style-type", 
+		 "outline", "outline-color", "outline-style", "outline-width",
+		 "border", "border-left", "border-top", "border-bottom", "border-right", "border-color", "border-width", "border-style",
+		 "border-bottom-color", "border-bottom-style", "border-bottom-width",
+		 "border-left-color", "border-left-style", "border-left-width",
+		 "border-top-color", "border-top-style", "border-top-width",
+		 "border-right-color", "border-right-style", "border-right-width",
+		 "padding", "padding-left", "padding-top", "padding-bottom", "padding-right",
+		 "margin", "margin-left", "margin-top", "margin-bottom", "margin-right",
+		 "width", "height", "left", "top", "right", "bottom",
+		 "min-width", "max-width", "min-height", "max-height",
+		 "display", "visibility",
+		 "clip", "cursor", "overflow", "overflow-x", "overflow-y", "position", "z-index",
+		 "vertical-align", "horizontal-align",
+		 "float", "clear"
+		];
+
+	// Scanner constants
+	var UNKOWN = 1;
+	var KEYWORD = 2;
+	var STRING = 3;
+	var COMMENT = 4;
+	var WHITE = 5;
+	var WHITE_TAB = 6;
+	var WHITE_SPACE = 7;
+
+	// Styles 
+	var isIE = document.selection && window.ActiveXObject && /MSIE/.test(navigator.userAgent) ? document.documentMode : undefined;
+	var commentStyle = {styleClass: "token_comment"};
+	var javadocStyle = {styleClass: "token_javadoc"};
+	var stringStyle = {styleClass: "token_string"};
+	var keywordStyle = {styleClass: "token_keyword"};
+	var spaceStyle = {styleClass: "token_space"};
+	var tabStyle = {styleClass: "token_tab"};
+	var bracketStyle = {styleClass: isIE < 9 ? "token_bracket" : "token_bracket_outline"};
+	var caretLineStyle = {styleClass: "line_caret"};
+	
+	var Scanner = (function() {
+		function Scanner (keywords, whitespacesVisible) {
+			this.keywords = keywords;
+			this.whitespacesVisible = whitespacesVisible;
+			this.setText("");
+		}
+		
+		Scanner.prototype = {
+			getOffset: function() {
+				return this.offset;
+			},
+			getStartOffset: function() {
+				return this.startOffset;
+			},
+			getData: function() {
+				return this.text.substring(this.startOffset, this.offset);
+			},
+			getDataLength: function() {
+				return this.offset - this.startOffset;
+			},
+			_read: function() {
+				if (this.offset < this.text.length) {
+					return this.text.charCodeAt(this.offset++);
+				}
+				return -1;
+			},
+			_unread: function(c) {
+				if (c !== -1) { this.offset--; }
+			},
+			nextToken: function() {
+				this.startOffset = this.offset;
+				while (true) {
+					var c = this._read();
+					switch (c) {
+						case -1: return null;
+						case 47:	// SLASH -> comment
+							c = this._read();
+							if (c === 47) {
+								while (true) {
+									c = this._read();
+									if ((c === -1) || (c === 10)) {
+										this._unread(c);
+										return COMMENT;
+									}
+								}
+							}
+							this._unread(c);
+							return UNKOWN;
+						case 39:	// SINGLE QUOTE -> char const
+							while(true) {
+								c = this._read();
+								switch (c) {
+									case 39:
+										return STRING;
+									case -1:
+										this._unread(c);
+										return STRING;
+									case 92: // BACKSLASH
+										c = this._read();
+										break;
+								}
+							}
+							break;
+						case 34:	// DOUBLE QUOTE -> string
+							while(true) {
+								c = this._read();
+								switch (c) {
+									case 34: // DOUBLE QUOTE
+										return STRING;
+									case -1:
+										this._unread(c);
+										return STRING;
+									case 92: // BACKSLASH
+										c = this._read();
+										break;
+								}
+							}
+							break;
+						case 32: // SPACE
+						case 9: // TAB
+							if (this.whitespacesVisible) {
+								return c === 32 ? WHITE_SPACE : WHITE_TAB;
+							}
+							do {
+								c = this._read();
+							} while(c === 32 || c === 9);
+							this._unread(c);
+							return WHITE;
+						default:
+							var isCSS = this.isCSS;
+							if ((97 <= c && c <= 122) || (65 <= c && c <= 90) || c === 95 || (48 <= c && c <= 57) || (0x2d === c && isCSS)) { //LETTER OR UNDERSCORE OR NUMBER
+								var off = this.offset - 1;
+								do {
+									c = this._read();
+								} while((97 <= c && c <= 122) || (65 <= c && c <= 90) || c === 95 || (48 <= c && c <= 57) || (0x2d === c && isCSS));  //LETTER OR UNDERSCORE OR NUMBER
+								this._unread(c);
+								var word = this.text.substring(off, this.offset);
+								//TODO slow
+								for (var i=0; i<this.keywords.length; i++) {
+									if (this.keywords[i] === word) { return KEYWORD; }
+								}
+							}
+							return UNKOWN;
+					}
+				}
+			},
+			setText: function(text) {
+				this.text = text;
+				this.offset = 0;
+				this.startOffset = 0;
+			}
+		};
+		return Scanner;
+	}());
+	
+	var WhitespaceScanner = (function() {
+		function WhitespaceScanner () {
+			Scanner.call(this, null, true);
+		}
+		WhitespaceScanner.prototype = new Scanner(null);
+		WhitespaceScanner.prototype.nextToken = function() {
+			this.startOffset = this.offset;
+			while (true) {
+				var c = this._read();
+				switch (c) {
+					case -1: return null;
+					case 32: // SPACE
+						return WHITE_SPACE;
+					case 9: // TAB
+						return WHITE_TAB;
+					default:
+						do {
+							c = this._read();
+						} while(!(c === 32 || c === 9 || c === -1));
+						this._unread(c);
+						return UNKOWN;
+				}
+			}
+		};
+		
+		return WhitespaceScanner;
+	}());
+	
+	function TextStyler (editor, lang) {
+		this.commentStart = "/*";
+		this.commentEnd = "*/";
+		var keywords = [];
+		switch (lang) {
+			case "java": keywords = JAVA_KEYWORDS; break;
+			case "js": keywords = JS_KEYWORDS; break;
+			case "css": keywords = CSS_KEYWORDS; break;
+		}
+		this.whitespacesVisible = false;
+		this.highlightCaretLine = true;
+		this._scanner = new Scanner(keywords, this.whitespacesVisible);
+		//TODO this scanner is not the best/correct way to parse CSS
+		if (lang === "css") {
+			this._scanner.isCSS = true;
+		}
+		this._whitespaceScanner = new WhitespaceScanner();
+		this.editor = editor;
+		this.commentOffset = 0;
+		this.commentOffsets = [];
+		this._currentBracket = undefined; 
+		this._matchingBracket = undefined;
+		
+		editor.addEventListener("Selection", this, this._onSelection);
+		editor.addEventListener("ModelChanged", this, this._onModelChanged);
+		editor.addEventListener("Destroy", this, this._onDestroy);
+		editor.addEventListener("LineStyle", this, this._onLineStyle);
+		editor.redrawLines();
+	}
+	
+	TextStyler.prototype = {
+		destroy: function() {
+			var editor = this.editor;
+			if (editor) {
+				editor.removeEventListener("Selection", this, this._onSelection);
+				editor.removeEventListener("ModelChanged", this, this._onModelChanged);
+				editor.removeEventListener("Destroy", this, this._onDestroy);
+				editor.removeEventListener("LineStyle", this, this._onLineStyle);
+				this.editor = null;
+			}
+		},
+		setHighlightCaretLine: function(highlight) {
+			this.highlightCaretLine = highlight;
+		},
+		setWhitespacesVisible: function(visible) {
+			this.whitespacesVisible = visible;
+			this._scanner.whitespacesVisible = visible;
+		},
+		_binarySearch: function(offsets, offset, low, high) {
+			while (high - low > 2) {
+				var index = (((high + low) >> 1) >> 1) << 1;
+				var end = offsets[index + 1];
+				if (end > offset) {
+					high = index;
+				} else {
+					low = index;
+				}
+			}
+			return high;
+		},
+		_computeComments: function(end) {
+			// compute comments between commentOffset and end
+			if (end <= this.commentOffset) { return; }
+			var model = this.editor.getModel();
+			var charCount = model.getCharCount();
+			var e = end;
+			// Uncomment to compute all comments
+//			e = charCount;
+			var t = /*start == this.commentOffset && e == end ? text : */model.getText(this.commentOffset, e);
+			if (this.commentOffsets.length > 1 && this.commentOffsets[this.commentOffsets.length - 1] === charCount) {
+				this.commentOffsets.length--;
+			}
+			var offset = 0;
+			while (offset < t.length) {
+				var begin = (this.commentOffsets.length & 1) === 0;
+				var search = begin ? this.commentStart : this.commentEnd;
+				var index = t.indexOf(search, offset);
+				if (index !== -1) {
+					this.commentOffsets.push(this.commentOffset + (begin ? index : index + search.length));
+				} else {
+					break;
+				}
+				offset = index + search.length;
+			}
+			if ((this.commentOffsets.length & 1) === 1) { this.commentOffsets.push(charCount); }
+			this.commentOffset = e;
+		},
+		_getCommentRanges: function(start, end) {
+			this._computeComments (end);
+			var commentCount = this.commentOffsets.length;
+			var commentStart = this._binarySearch(this.commentOffsets, start, -1, commentCount);
+			if (commentStart >= commentCount) { return []; }
+			if (this.commentOffsets[commentStart] > end) { return []; }
+			var commentEnd = Math.min(commentCount - 2, this._binarySearch(this.commentOffsets, end, commentStart - 1, commentCount));
+			if (this.commentOffsets[commentEnd] > end) { commentEnd = Math.max(commentStart, commentEnd - 2); }
+			return this.commentOffsets.slice(commentStart, commentEnd + 2);
+		},
+		_getLineStyle: function(lineIndex) {
+			if (this.highlightCaretLine) {
+				var editor = this.editor;
+				var model = this.editor.getModel();
+				var selection = editor.getSelection();
+				if (selection.start === selection.end && model.getLineAtOffset(selection.start) === lineIndex) {
+					return caretLineStyle;
+				}
+			}
+			return null;
+		},
+		_getStyles: function(text, start) {
+			var end = start + text.length;
+			var model = this.editor.getModel();
+			
+			// get comment ranges that intersect with range
+			var commentRanges = this._getCommentRanges (start, end);
+			var styles = [];
+			
+			// for any sub range that is not a comment, parse code generating tokens (keywords, numbers, brackets, line comments, etc)
+			var offset = start;
+			for (var i = 0; i < commentRanges.length; i+= 2) {
+				var commentStart = commentRanges[i];
+				if (offset < commentStart) {
+					this._parse(text.substring(offset - start, commentStart - start), offset, styles);
+				}
+				var style = commentStyle;
+				if ((commentRanges[i+1] - commentStart) > (this.commentStart.length + this.commentEnd.length)) {
+					var o = commentStart + this.commentStart.length;
+					if (model.getText(o, o + 1) === "*") { style = javadocStyle; }
+				}
+				if (this.whitespacesVisible) {
+					var s = Math.max(offset, commentStart);
+					var e = Math.min(end, commentRanges[i+1]);
+					this._parseWhitespace(text.substring(s - start, e - start), s, styles, style);
+				} else {
+					styles.push({start: commentRanges[i], end: commentRanges[i+1], style: style});
+				}
+				offset = commentRanges[i+1];
+			}
+			if (offset < end) {
+				this._parse(text.substring(offset - start, end - start), offset, styles);
+			}
+			return styles;
+		},
+		_parse: function(text, offset, styles) {
+			var scanner = this._scanner;
+			scanner.setText(text);
+			var token;
+			while ((token = scanner.nextToken())) {
+				var tokenStart = scanner.getStartOffset() + offset;
+				var style = null;
+				if (tokenStart === this._matchingBracket) {
+					style = bracketStyle;
+				} else {
+					switch (token) {
+						case KEYWORD: style = keywordStyle; break;
+						case STRING:
+							if (this.whitespacesVisible) {
+								this._parseWhitespace(scanner.getData(), tokenStart, styles, stringStyle);
+								continue;
+							} else {
+								style = stringStyle;
+							}
+							break;
+						case COMMENT: 
+							if (this.whitespacesVisible) {
+								this._parseWhitespace(scanner.getData(), tokenStart, styles, commentStyle);
+								continue;
+							} else {
+								style = commentStyle;
+							}
+							break;
+						case WHITE_TAB:
+							if (this.whitespacesVisible) {
+								style = tabStyle;
+							}
+							break;
+						case WHITE_SPACE:
+							if (this.whitespacesVisible) {
+								style = spaceStyle;
+							}
+							break;
+					}
+				}
+				styles.push({start: tokenStart, end: scanner.getOffset() + offset, style: style});
+			}
+		},
+		_parseWhitespace: function(text, offset, styles, s) {
+			var scanner = this._whitespaceScanner;
+			scanner.setText(text);
+			var token;
+			while ((token = scanner.nextToken())) {
+				var tokenStart = scanner.getStartOffset() + offset;
+				var style = s;
+				switch (token) {
+					case WHITE_TAB:
+						style = tabStyle;
+						break;
+					case WHITE_SPACE:
+						style = spaceStyle;
+						break;
+				}
+				styles.push({start: tokenStart, end: scanner.getOffset() + offset, style: style});
+			}
+		},
+		_findBrackets: function(bracket, closingBracket, text, textOffset, start, end) {
+			var result = [];
+			
+			// get comment ranges that intersect with range
+			var commentRanges = this._getCommentRanges (start, end);
+			
+			// for any sub range that is not a comment, parse code generating tokens (keywords, numbers, brackets, line comments, etc)
+			var offset = start, scanner = this._scanner, token, tokenData;
+			for (var i = 0; i < commentRanges.length; i+= 2) {
+				var commentStart = commentRanges[i];
+				if (offset < commentStart) {
+					scanner.setText(text.substring(offset - start, commentStart - start));
+					while ((token = scanner.nextToken())) {
+						if (scanner.getDataLength() !== 1) { continue; }
+						tokenData = scanner.getData();
+						if (tokenData === bracket) {
+							result.push(scanner.getStartOffset() + offset - start + textOffset);
+						}
+						if (tokenData === closingBracket) {
+							result.push(-(scanner.getStartOffset() + offset - start + textOffset));
+						}
+					}
+				}
+				offset = commentRanges[i+1];
+			}
+			if (offset < end) {
+				scanner.setText(text.substring(offset - start, end - start));
+				while ((token = scanner.nextToken())) {
+					if (scanner.getDataLength() !== 1) { continue; }
+					tokenData = scanner.getData();
+					if (tokenData === bracket) {
+						result.push(scanner.getStartOffset() + offset - start + textOffset);
+					}
+					if (tokenData === closingBracket) {
+						result.push(-(scanner.getStartOffset() + offset - start + textOffset));
+					}
+				}
+			}
+			return result;
+		},
+		_onDestroy: function(e) {
+			this.destroy();
+		},
+		_onLineStyle: function (e) {
+			e.style = this._getLineStyle(e.lineIndex);
+			e.ranges = this._getStyles(e.lineText, e.lineStart);
+		},
+		_onSelection: function(e) {
+			var oldSelection = e.oldValue;
+			var newSelection = e.newValue;
+			var editor = this.editor;
+			var model = editor.getModel();
+			var lineIndex;
+			if (this._matchingBracket !== undefined) {
+				lineIndex = model.getLineAtOffset(this._matchingBracket);
+				editor.redrawLines(lineIndex, lineIndex + 1);
+				this._matchingBracket = this._currentBracket = undefined;
+			}
+			if (this.highlightCaretLine) {
+				var oldLineIndex = model.getLineAtOffset(oldSelection.start);
+				lineIndex = model.getLineAtOffset(newSelection.start);
+				var newEmpty = newSelection.start === newSelection.end;
+				var oldEmpty = oldSelection.start === oldSelection.end;
+				if (!(oldLineIndex === lineIndex && oldEmpty && newEmpty)) {
+					if (oldEmpty) {
+						editor.redrawLines(oldLineIndex, oldLineIndex + 1);
+					}
+					if ((oldLineIndex !== lineIndex || !oldEmpty) && newEmpty) {
+						editor.redrawLines(lineIndex, lineIndex + 1);
+					}
+				}
+			}
+			if (newSelection.start !== newSelection.end || newSelection.start === 0) {
+				return;
+			}
+			var caret = editor.getCaretOffset();
+			if (caret === 0) { return; }
+			var brackets = "{}()[]<>";
+			var bracket = model.getText(caret - 1, caret);
+			var bracketIndex = brackets.indexOf(bracket, 0);
+			if (bracketIndex === -1) { return; }
+			var closingBracket;
+			if (bracketIndex & 1) {
+				closingBracket = brackets.substring(bracketIndex - 1, bracketIndex);
+			} else {
+				closingBracket = brackets.substring(bracketIndex + 1, bracketIndex + 2);
+			}
+			lineIndex = model.getLineAtOffset(caret);
+			var lineText = model.getLine(lineIndex);
+			var lineStart = model.getLineStart(lineIndex);
+			var lineEnd = model.getLineEnd(lineIndex);
+			brackets = this._findBrackets(bracket, closingBracket, lineText, lineStart, lineStart, lineEnd);
+			for (var i=0; i<brackets.length; i++) {
+				var sign = brackets[i] >= 0 ? 1 : -1;
+				if (brackets[i] * sign === caret - 1) {
+					var level = 1;
+					this._currentBracket = brackets[i] * sign;
+					if (bracketIndex & 1) {
+						i--;
+						for (; i>=0; i--) {
+							sign = brackets[i] >= 0 ? 1 : -1;
+							level += sign;
+							if (level === 0) {
+								this._matchingBracket = brackets[i] * sign;
+								editor.redrawLines(lineIndex, lineIndex + 1);
+								return;
+							}
+						}
+						lineIndex -= 1;
+						while (lineIndex >= 0) {
+							lineText = model.getLine(lineIndex);
+							lineStart = model.getLineStart(lineIndex);
+							lineEnd = model.getLineEnd(lineIndex);
+							brackets = this._findBrackets(bracket, closingBracket, lineText, lineStart, lineStart, lineEnd);
+							for (var j=brackets.length - 1; j>=0; j--) {
+								sign = brackets[j] >= 0 ? 1 : -1;
+								level += sign;
+								if (level === 0) {
+									this._matchingBracket = brackets[j] * sign;
+									editor.redrawLines(lineIndex, lineIndex + 1);
+									return;
+								}
+							}
+							lineIndex--;
+						}
+					} else {
+						i++;
+						for (; i<brackets.length; i++) {
+							sign = brackets[i] >= 0 ? 1 : -1;
+							level += sign;
+							if (level === 0) {
+								this._matchingBracket = brackets[i] * sign;
+								editor.redrawLines(lineIndex, lineIndex + 1);
+								return;
+							}
+						}
+						lineIndex += 1;
+						var lineCount = model.getLineCount ();
+						while (lineIndex < lineCount) {
+							lineText = model.getLine(lineIndex);
+							lineStart = model.getLineStart(lineIndex);
+							lineEnd = model.getLineEnd(lineIndex);
+							brackets = this._findBrackets(bracket, closingBracket, lineText, lineStart, lineStart, lineEnd);
+							for (var k=0; k<brackets.length; k++) {
+								sign = brackets[k] >= 0 ? 1 : -1;
+								level += sign;
+								if (level === 0) {
+									this._matchingBracket = brackets[k] * sign;
+									editor.redrawLines(lineIndex, lineIndex + 1);
+									return;
+								}
+							}
+							lineIndex++;
+						}
+					}
+					break;
+				}
+			}
+		},
+		_onModelChanged: function(e) {
+			var start = e.start;
+			var removedCharCount = e.removedCharCount;
+			var addedCharCount = e.addedCharCount;
+			if (this._matchingBracket && start < this._matchingBracket) { this._matchingBracket += addedCharCount + removedCharCount; }
+			if (this._currentBracket && start < this._currentBracket) { this._currentBracket += addedCharCount + removedCharCount; }
+			if (start >= this.commentOffset) { return; }
+			var model = this.editor.getModel();
+			
+//			window.console.log("start=" + start + " added=" + addedCharCount + " removed=" + removedCharCount)
+//			for (var i=0; i< this.commentOffsets.length; i++) {
+//				window.console.log(i +"="+ this.commentOffsets[i]);
+//			}
+
+			var commentCount = this.commentOffsets.length;
+			var extra = Math.max(this.commentStart.length - 1, this.commentEnd.length - 1);
+			if (commentCount === 0) {
+				this.commentOffset = Math.max(0, start - extra);
+				return;
+			}
+			var charCount = model.getCharCount();
+			var oldCharCount = charCount - addedCharCount + removedCharCount;
+			var commentStart = this._binarySearch(this.commentOffsets, start, -1, commentCount);
+			var end = start + removedCharCount;
+			var commentEnd = this._binarySearch(this.commentOffsets, end, commentStart - 1, commentCount);
+//			window.console.log("s=" + commentStart + " e=" + commentEnd);
+			var ts;
+			if (commentStart > 0) {
+				ts = this.commentOffsets[--commentStart];
+			} else {
+				ts = Math.max(0, Math.min(this.commentOffsets[commentStart], start) - extra);
+				--commentStart;
+			}
+			var te;
+			var redrawEnd = charCount;
+			if (commentEnd + 1 < this.commentOffsets.length) {
+				te = this.commentOffsets[++commentEnd];
+				if (end > (te - this.commentEnd.length)) {
+					if (commentEnd + 2 < this.commentOffsets.length) { 
+						commentEnd += 2;
+						te = this.commentOffsets[commentEnd];
+						redrawEnd = te + 1;
+						if (redrawEnd > start) { redrawEnd += addedCharCount - removedCharCount; }
+					} else {
+						te = Math.min(oldCharCount, end + extra);
+						this.commentOffset = te;
+					}
+				}
+			} else {
+				te = Math.min(oldCharCount, end + extra);
+				this.commentOffset = te;
+				if (commentEnd > 0 && commentEnd === this.commentOffsets.length) {
+					commentEnd = this.commentOffsets.length - 1;
+				}
+			}
+			if (ts > start) { ts += addedCharCount - removedCharCount; }
+			if (te > start) { te += addedCharCount - removedCharCount; }
+			
+//			window.console.log("commentStart="+ commentStart + " commentEnd=" + commentEnd + " ts=" + ts + " te=" + te)
+
+			if (this.commentOffsets.length > 1 && this.commentOffsets[this.commentOffsets.length - 1] === oldCharCount) {
+				this.commentOffsets.length--;
+			}
+			
+			var offset = 0;
+			var newComments = [];
+			var t = model.getText(ts, te);
+			if (this.commentOffset < te) { this.commentOffset = te; }
+			while (offset < t.length) {
+				var begin = ((commentStart + 1 + newComments.length) & 1) === 0;
+				var search = begin ? this.commentStart : this.commentEnd;
+				var index = t.indexOf(search, offset);
+				if (index !== -1) {
+					newComments.push(ts + (begin ? index : index + search.length));
+				} else {
+					break;
+				}
+				offset = index + search.length;
+			}
+//			window.console.log("lengths=" + newComments.length + " " + (commentEnd - commentStart) + " t=<" + t + ">")
+//			for (var i=0; i< newComments.length; i++) {
+//				window.console.log(i +"=>"+ newComments[i]);
+//			}
+			var redraw = (commentEnd - commentStart) !== newComments.length;
+			if (!redraw) {
+				for (var i=0; i<newComments.length; i++) {
+					offset = this.commentOffsets[commentStart + 1 + i];
+					if (offset > start) { offset += addedCharCount - removedCharCount; }
+					if (offset !== newComments[i]) {
+						redraw = true;
+						break;
+					} 
+				}
+			}
+			
+			var args = [commentStart + 1, (commentEnd - commentStart)].concat(newComments);
+			Array.prototype.splice.apply(this.commentOffsets, args);
+			for (var k=commentStart + 1 + newComments.length; k< this.commentOffsets.length; k++) {
+				this.commentOffsets[k] += addedCharCount - removedCharCount;
+			}
+			
+			if ((this.commentOffsets.length & 1) === 1) { this.commentOffsets.push(charCount); }
+			
+			if (redraw) {
+//				window.console.log ("redraw " + (start + addedCharCount) + " " + redrawEnd);
+				this.editor.redrawRange(start + addedCharCount, redrawEnd);
+			}
+
+//			for (var i=0; i< this.commentOffsets.length; i++) {
+//				window.console.log(i +"="+ this.commentOffsets[i]);
+//			}
+
+		}
+	};
+	return TextStyler;
+}());
+/*******************************************************************************
+ * Copyright (c) 2010, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ ******************************************************************************/
+
+var eclipse = eclipse || {};
+
+eclipse.Ruler = (function() {
+	function Ruler (rulerLocation, rulerOverview, rulerStyle) {
+		this._location = rulerLocation || "left";
+		this._overview = rulerOverview || "page";
+		this._rulerStyle = rulerStyle;
+		this._editor = null;
+	}
+	Ruler.prototype = {
+		setEditor: function (editor) {
+			if (this._onModelChanged && this._editor) {
+				this._editor.removeEventListener("ModelChanged", this, this._onModelChanged); 
+			}
+			this._editor = editor;
+			if (this._onModelChanged && this._editor) {
+				this._editor.addEventListener("ModelChanged", this, this._onModelChanged);
+			}
+		},
+		getLocation: function() {
+			return this._location;
+		},
+		getOverview: function(editor) {
+			return this._overview;
+		}
+	};
+	return Ruler;
+}());
+
+eclipse.LineNumberRuler = (function() {
+	function LineNumberRuler (rulerLocation, rulerStyle, oddStyle, evenStyle) {
+		eclipse.Ruler.call(this, rulerLocation, "page", rulerStyle);
+		this._oddStyle = oddStyle || {style: {backgroundColor: "white"}};
+		this._evenStyle = evenStyle || {style: {backgroundColor: "white"}};
+		this._numOfDigits = 0;
+	}
+	LineNumberRuler.prototype = new eclipse.Ruler(); 
+	LineNumberRuler.prototype.getStyle = function(lineIndex) {
+		if (lineIndex === undefined) {
+			return this._rulerStyle;
+		} else {
+			return lineIndex & 1 ? this._oddStyle : this._evenStyle;
+		}
+	};
+	LineNumberRuler.prototype.getHTML = function(lineIndex) {
+		if (lineIndex === -1) {
+			var model = this._editor.getModel();
+			return model.getLineCount();
+		} else {
+			return lineIndex + 1;
+		}
+	};
+	LineNumberRuler.prototype._onModelChanged = function(e) {
+		var start = e.start;
+		var model = this._editor.getModel();
+		var lineCount = model.getLineCount();
+		var numOfDigits = (lineCount+"").length;
+		if (this._numOfDigits !== numOfDigits) {
+			this._numOfDigits = numOfDigits;
+			var startLine = model.getLineAtOffset(start);
+			this._editor.redrawLines(startLine, lineCount, this);
+		}
+	};
+	return LineNumberRuler;
+}());
+
+eclipse.AnnotationRuler = (function() {
+	function AnnotationRuler (rulerLocation, rulerStyle, defaultAnnotation) {
+		eclipse.Ruler.call(this, rulerLocation, "page", rulerStyle);
+		this._defaultAnnotation = defaultAnnotation;
+		this._annotations = [];
+	}
+	AnnotationRuler.prototype = new eclipse.Ruler();
+	AnnotationRuler.prototype.clearAnnotations = function() {
+		this._annotations = [];
+		var lineCount = this._editor.getModel().getLineCount();
+		this._editor.redrawLines(0, lineCount, this);
+		if (this._overviewRuler) {
+			this._editor.redrawLines(0, lineCount, this._overviewRuler);
+		}
+	};
+	AnnotationRuler.prototype.getAnnotation = function(lineIndex) {
+		return this._annotations[lineIndex];
+	};
+	AnnotationRuler.prototype.getAnnotations = function() {
+		return this._annotations;
+	};
+	AnnotationRuler.prototype.getStyle = function(lineIndex) {
+		switch (lineIndex) {
+			case undefined:
+				return this._rulerStyle;
+			case -1:
+				return this._defaultAnnotation ? this._defaultAnnotation.style : null;
+			default:
+				return this._annotations[lineIndex] && this._annotations[lineIndex].style ? this._annotations[lineIndex].style : null;
+		}
+	};
+	AnnotationRuler.prototype.getHTML = function(lineIndex) {
+		if (lineIndex === -1) {
+			return this._defaultAnnotation ? this._defaultAnnotation.html : "";
+		} else {
+			return this._annotations[lineIndex] && this._annotations[lineIndex].html ? this._annotations[lineIndex].html : "";
+		}
+	};
+	AnnotationRuler.prototype.setAnnotation = function(lineIndex, annotation) {
+		if (lineIndex === undefined) { return; }
+		this._annotations[lineIndex] = annotation;
+		this._editor.redrawLines(lineIndex, lineIndex + 1, this);
+		if (this._overviewRuler) {
+			this._editor.redrawLines(lineIndex, lineIndex + 1, this._overviewRuler);
+		}
+	};
+	AnnotationRuler.prototype._onModelChanged = function(e) {
+		var start = e.start;
+		var removedLineCount = e.removedLineCount;
+		var addedLineCount = e.addedLineCount;
+		var linesChanged = addedLineCount - removedLineCount;
+		if (linesChanged) {
+			var model = this._editor.getModel();
+			var startLine = model.getLineAtOffset(start);
+			var newLines = [], lines = this._annotations;
+			var changed = false;
+			for (var prop in lines) {
+				var i = prop >>> 0;
+				if (!(startLine < i && i < startLine + removedLineCount)) {
+					var newIndex = i;
+					if (i > startLine) {
+						newIndex += linesChanged;
+						changed = true;
+					}
+					newLines[newIndex] = lines[i];
+				} else {
+					changed = true;
+				}
+			}
+			this._annotations = newLines;
+			if (changed) {
+				var lineCount = model.getLineCount();
+				this._editor.redrawLines(startLine, lineCount, this);
+				//TODO redraw overview (batch it for performance)
+				if (this._overviewRuler) {
+					this._editor.redrawLines(0, lineCount, this._overviewRuler);
+				}
+			}
+		}
+	};
+	return AnnotationRuler;
+}());
+
+eclipse.OverviewRuler = (function() {
+	function OverviewRuler (rulerLocation, rulerStyle, annotationRuler) {
+		eclipse.Ruler.call(this, rulerLocation, "document", rulerStyle);
+		this._annotationRuler = annotationRuler;
+		if (annotationRuler) {
+			annotationRuler._overviewRuler = this;
+		}
+	}
+	OverviewRuler.prototype = new eclipse.Ruler();
+	OverviewRuler.prototype.getAnnotations = function() {
+		var annotations = this._annotationRuler.getAnnotations();
+		var lines = [];
+		for (var prop in annotations) {
+			var i = prop >>> 0;
+			if (annotations[i] !== undefined) {
+				lines.push(i);
+			}
+		}
+		return lines;
+	};
+	OverviewRuler.prototype.getStyle = function(lineIndex) {
+		var result, style;
+		if (lineIndex === undefined) {
+			result = this._rulerStyle || {};
+			style = result.style || (result.style = {});
+			style.lineHeight = "1px";
+			style.fontSize = "1px";
+			style.width = "14px";
+		} else {
+			if (lineIndex !== -1) {
+				var annotation = this._annotationRuler.getAnnotation(lineIndex);
+				result = annotation.overviewStyle || {};
+			} else {
+				result = {};
+			}
+			style = result.style || (result.style = {});
+			style.cursor = "pointer";
+			style.width = "8px";
+			style.height = "3px";
+			style.left = "2px";
+		}
+		return result;
+	};
+	OverviewRuler.prototype.getHTML = function(lineIndex) {
+		return "&nbsp;";
+	};
+	OverviewRuler.prototype.onClick = function(lineIndex, e) {
+		if (lineIndex === undefined) { return; }
+		this._editor.setTopIndex(lineIndex);
+	};
+	return OverviewRuler;
+}());/*******************************************************************************
+ * Copyright (c) 2010, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: IBM Corporation - initial API and implementation
+ ******************************************************************************/
+
+var eclipse = eclipse || {};
+
+eclipse.UndoStack = (function() {
+	var Change = (function() {
+		function Change(offset, text, previousText) {
+			this.offset = offset;
+			this.text = text;
+			this.previousText = previousText;
+		}
+		Change.prototype = {
+			undo: function (editor, select) {
+				this._doUndoRedo(this.offset, this.previousText, this.text, editor, select);
+			},
+			redo: function (editor, select) {
+				this._doUndoRedo(this.offset, this.text, this.previousText, editor, select);
+			},
+			_doUndoRedo: function(offset, text, previousText, editor, select) {
+				editor.setText(text, offset, offset + previousText.length);
+				if (select) {
+					editor.setSelection(offset, offset + text.length);
+				}
+			}
+		};
+		return Change;
+	}());
+
+	var CompoundChange = (function() {
+		function CompoundChange (selection, caret) {
+			this.selection = selection;
+			this.caret = caret;
+			this.changes = [];
+		}
+		CompoundChange.prototype = {
+			add: function (change) {
+				this.changes.push(change);
+			},
+			undo: function (editor, select) {
+				for (var i=this.changes.length - 1; i >= 0; i--) {
+					this.changes[i].undo(editor, false);
+				}
+				if (select) {
+					var start = this.selection.start;
+					var end = this.selection.end;
+					editor.setSelection(this.caret ? start : end, this.caret ? end : start);
+				}
+			},
+			redo: function (editor, select) {
+				for (var i = 0; i < this.changes.length; i++) {
+					this.changes[i].redo(editor, false);
+				}
+				if (select) {
+					var start = this.selection.start;
+					var end = this.selection.end;
+					editor.setSelection(this.caret ? start : end, this.caret ? end : start);
+				}
+			}
+		};
+		return CompoundChange;
+	}());
+
+	function UndoStack (editor, size) {
+		this.editor = editor;
+		this.size = size !== undefined ? size : 100;
+		this.reset();
+		editor.addEventListener("ModelChanging", this, this._onModelChanging);
+		editor.addEventListener("Destroy", this, this._onDestroy);
+	}
+	UndoStack.prototype = {
+		add: function (change) {
+			if (this.compoundChange) {
+				this.compoundChange.add(change);
+			} else {
+				var length = this.stack.length;
+				this.stack.splice(this.index, length-this.index, change);
+				this.index++;
+				if (this.stack.length > this.size) {
+					this.stack.shift();
+					this.index--;
+					this.cleanIndex--;
+				}
+			}
+		},
+		markClean: function() {
+			this.endCompoundChange();
+			this._commitUndo();
+			this.cleanIndex = this.index;
+		},
+		isClean: function() {
+			return this.cleanIndex === this.getSize().undo;
+		},
+		canUndo: function() {
+			return this.getSize().undo > 0;
+		},
+		canRedo: function() {
+			return this.getSize().redo > 0;
+		},
+		endCompoundChange: function() {
+			this.compoundChange = undefined;
+		},
+		getSize: function() {
+			var index = this.index;
+			var length = this.stack.length;
+			if (this._undoStart !== undefined) {
+				index++;
+			}
+			return {undo: index, redo: (length - index)};
+		},
+		undo: function() {
+			this._commitUndo();
+			if (this.index <= 0) {
+				return false;
+			}
+			var change = this.stack[--this.index];
+			this._ignoreUndo = true;
+			change.undo(this.editor, true);
+			this._ignoreUndo = false;
+			return true;
+		},
+		redo: function() {
+			this._commitUndo();
+			if (this.index >= this.stack.length) {
+				return false;
+			}
+			var change = this.stack[this.index++];
+			this._ignoreUndo = true;
+			change.redo(this.editor, true);
+			this._ignoreUndo = false;
+			return true;
+		},
+		reset: function() {
+			this.index = this.cleanIndex = 0;
+			this.stack = [];
+			this._undoStart = undefined;
+			this._undoText = "";
+			this._ignoreUndo = false;
+			this._compoundChange = undefined;
+		},
+		startCompoundChange: function() {
+			var change = new CompoundChange(this.editor.getSelection(), this.editor.getCaretOffset());
+			this.add(change);
+			this.compoundChange = change;
+		},
+		_commitUndo: function () {
+			if (this._undoStart !== undefined) {
+				if (this._undoStart < 0) {
+					this.add(new Change(-this._undoStart, "", this._undoText, ""));
+				} else {
+					this.add(new Change(this._undoStart, this._undoText, ""));
+				}
+				this._undoStart = undefined;
+				this._undoText = "";
+			}
+		},
+		_onDestroy: function() {
+			this.editor.removeEventListener("ModelChanging", this, this._onModelChanging);
+			this.editor.removeEventListener("Destroy", this, this._onDestroy);
+		},
+		_onModelChanging: function(e) {
+			var newText = e.text;
+			var start = e.start;
+			var removedCharCount = e.removedCharCount;
+			var addedCharCount = e.addedCharCount;
+			if (this._ignoreUndo) {
+				return;
+			}
+			if (this._undoStart !== undefined && 
+				!((addedCharCount === 1 && removedCharCount === 0 && start === this._undoStart + this._undoText.length) ||
+					(addedCharCount === 0 && removedCharCount === 1 && (((start + 1) === -this._undoStart) || (start === -this._undoStart)))))
+			{
+				this._commitUndo();
+			}
+			if (!this.compoundChange) {
+				if (addedCharCount === 1 && removedCharCount === 0) {
+					if (this._undoStart === undefined) {
+						this._undoStart = start;
+					}
+					this._undoText = this._undoText + newText;
+					return;
+				} else if (addedCharCount === 0 && removedCharCount === 1) {
+					var deleting = this._undoText.length > 0 && -this._undoStart === start;
+					this._undoStart = -start;
+					if (deleting) {
+						this._undoText = this._undoText + this.editor.getText(start, start + removedCharCount);
+					} else {
+						this._undoText = this.editor.getText(start, start + removedCharCount) + this._undoText;
+					}
+					return;
+				}
+			}
+			this.add(new Change(start, newText, this.editor.getText(start, start + removedCharCount)));
+		}
+	};
+	return UndoStack;
+}());// vim:set noet:
+/*******************************************************************************
+ * Copyright (c) 2010, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: 
+ *		Felipe Heidrich (IBM Corporation) - initial API and implementation
+ *		Silenio Quarti (IBM Corporation) - initial API and implementation
+ ******************************************************************************/
+
+/*global window document navigator setTimeout clearTimeout alert XMLHttpRequest */
+
+/**
+ * @namespace The global container for Eclipse APIs.
+ */ 
+var eclipse = eclipse || {};
+
+/**
+ * Constructs a new key binding with the given key code and modifiers.
+ * 
+ * @param {String|Number} keyCode the key code.
+ * @param {Boolean} mod1 the primary modifier (usually Command on Mac and Control on other platforms).
+ * @param {Boolean} mod2 the secondary modifier (usually Shift).
+ * @param {Boolean} mod3 the third modifier (usually Alt).
+ * @param {Boolean} mod4 the fourth modifier (usually Control on the Mac).
+ * 
+ * @class A KeyBinding represents of a key code and a modifier state that can be triggered by the user using the keyboard.
+ * @name eclipse.KeyBinding
+ * 
+ * @property {String|Number} keyCode The key code.
+ * @property {Boolean} mod1 The primary modifier (usually Command on Mac and Control on other platforms).
+ * @property {Boolean} mod2 The secondary modifier (usually Shift).
+ * @property {Boolean} mod3 The third modifier (usually Alt).
+ * @property {Boolean} mod4 The fourth modifier (usually Control on the Mac).
+ *
+ * @see eclipse.Editor#setKeyBinding
+ */
+eclipse.KeyBinding = (function() {
+	var isMac = navigator.platform.indexOf("Mac") !== -1;
+	/** @private */
+	function KeyBinding (keyCode, mod1, mod2, mod3, mod4) {
+		if (typeof(keyCode) === "string") {
+			this.keyCode = keyCode.toUpperCase().charCodeAt(0);
+		} else {
+			this.keyCode = keyCode;
+		}
+		this.mod1 = mod1 !== undefined && mod1 !== null ? mod1 : false;
+		this.mod2 = mod2 !== undefined && mod2 !== null ? mod2 : false;
+		this.mod3 = mod3 !== undefined && mod3 !== null ? mod3 : false;
+		this.mod4 = mod4 !== undefined && mod4 !== null ? mod4 : false;
+	}
+	KeyBinding.prototype = /** @lends eclipse.KeyBinding.prototype */ {
+		/**
+		 * Returns whether this key binding matches the given key event.
+		 * 
+		 * @param e the key event.
+		 * @returns {Boolean} <code>true</code> whether the key binding matches the key event.
+		 */
+		match: function (e) {
+			if (this.keyCode === e.keyCode) {
+				var mod1 = isMac ? e.metaKey : e.ctrlKey;
+				if (this.mod1 !== mod1) { return false; }
+				if (this.mod2 !== e.shiftKey) { return false; }
+				if (this.mod3 !== e.altKey) { return false; }
+				if (isMac && this.mod4 !== e.ctrlKey) { return false; }
+				return true;
+			}
+			return false;
+		},
+		/**
+		 * Returns whether this key binding is the same as the given parameter.
+		 * 
+		 * @param {eclipse.KeyBinding} kb the key binding to compare with.
+		 * @returns {Boolean} whether or not the parameter and the receiver describe the same key binding.
+		 */
+		equals: function(kb) {
+			if (!kb) { return false; }
+			if (this.keyCode !== kb.keyCode) { return false; }
+			if (this.mod1 !== kb.mod1) { return false; }
+			if (this.mod2 !== kb.mod2) { return false; }
+			if (this.mod3 !== kb.mod3) { return false; }
+			if (this.mod4 !== kb.mod4) { return false; }
+			return true;
+		} 
+	};
+	return KeyBinding;
+}());
+
+/**
+ * Constructs a new editor.
+ * 
+ * @param options the editor options.
+ * @param {String|DOMElement} options.parent the parent element for the editor, it can be either a DOM element or an ID for a DOM element.
+ * @param {eclipse.TextModel} [options.model] the text model for the editor. If this options is not set the editor creates an empty {@link eclipse.TextModel}.
+ * @param {Boolean} [options.readonly=false] whether or not the editor is read-only.
+ * @param {Boolean} [options.fullSelection=true] whether or not the editor is in full selection mode.
+ * @param {String|String[]} [options.stylesheet] one or more stylesheet URIs for the editor.
+ * @param {Number} [options.tabSize] The number of spaces in a tab.
+ * 
+ * @class A Editor is a user interface for editing text.
+ * @name eclipse.Editor
+ */
+eclipse.Editor = (function() {
+
+	/** @private */
+	function addHandler(node, type, handler, capture) {
+		if (typeof node.addEventListener === "function") {
+			node.addEventListener(type, handler, capture === true);
+		} else {
+			node.attachEvent("on" + type, handler);
+		}
+	}
+	/** @private */
+	function removeHandler(node, type, handler, capture) {
+		if (typeof node.removeEventListener === "function") {
+			node.removeEventListener(type, handler, capture === true);
+		} else {
+			node.detachEvent("on" + type, handler);
+		}
+	}
+	var isIE = document.selection && window.ActiveXObject && /MSIE/.test(navigator.userAgent) ? document.documentMode : undefined;
+	var isFirefox = parseFloat(navigator.userAgent.split("Firefox/")[1] || navigator.userAgent.split("Minefield/")[1]) || undefined;
+	var isOpera = navigator.userAgent.indexOf("Opera") !== -1;
+	var isChrome = navigator.userAgent.indexOf("Chrome") !== -1;
+	var isSafari = navigator.userAgent.indexOf("Safari") !== -1;
+	var isWebkit = navigator.userAgent.indexOf("WebKit") !== -1;
+	var isPad = navigator.userAgent.indexOf("iPad") !== -1;
+	var isMac = navigator.platform.indexOf("Mac") !== -1;
+	var isWindows = navigator.platform.indexOf("Win") !== -1;
+	var isLinux = navigator.platform.indexOf("Linux") !== -1;
+	var isW3CEvents = typeof window.document.documentElement.addEventListener === "function";
+	var isRangeRects = (!isIE || isIE >= 9) && typeof window.document.createRange().getBoundingClientRect === "function";
+
+	/** 
+	 * Constructs a new Selection object.
+	 * 
+	 * @class A Selection represents a range of selected text in the editor.
+	 * @name eclipse.Selection
+	 */
+	var Selection = (function() {
+		/** @private */
+		function Selection (start, end, caret) {
+			/**
+			 * The selection start offset.
+			 *
+			 * @name eclipse.Selection#start
+			 */
+			this.start = start;
+			/**
+			 * The selection end offset.
+			 *
+			 * @name eclipse.Selection#end
+			 */
+			this.end = end;
+			/** @private */
+			this.caret = caret; //true if the start, false if the caret is at end
+		}
+		Selection.prototype = /** @lends eclipse.Selection.prototype */ {
+			/** @private */
+			clone: function() {
+				return new Selection(this.start, this.end, this.caret);
+			},
+			/** @private */
+			collapse: function() {
+				if (this.caret) {
+					this.end = this.start;
+				} else {
+					this.start = this.end;
+				}
+			},
+			/** @private */
+			extend: function (offset) {
+				if (this.caret) {
+					this.start = offset;
+				} else {
+					this.end = offset;
+				}
+				if (this.start > this.end) {
+					var tmp = this.start;
+					this.start = this.end;
+					this.end = tmp;
+					this.caret = !this.caret;
+				}
+			},
+			/** @private */
+			setCaret: function(offset) {
+				this.start = offset;
+				this.end = offset;
+				this.caret = false;
+			},
+			/** @private */
+			getCaret: function() {
+				return this.caret ? this.start : this.end;
+			},
+			/** @private */
+			toString: function() {
+				return "start=" + this.start + " end=" + this.end + (this.caret ? " caret is at start" : " caret is at end");
+			},
+			/** @private */
+			isEmpty: function() {
+				return this.start === this.end;
+			},
+			/** @private */
+			equals: function(object) {
+				return this.caret === object.caret && this.start === object.start && this.end === object.end;
+			}
+		};
+		return Selection;
+	}());
+
+	/** 
+	 * Constructs a new EventTable object.
+	 * 
+	 * @class 
+	 * @name eclipse.EventTable
+	 * @private
+	 */
+	var EventTable = (function() {
+		/** @private */
+		function EventTable(){
+		    this._listeners = {};
+		}
+		EventTable.prototype = /** @lends EventTable.prototype */ {
+			/** @private */
+			addEventListener: function(type, context, func, data) {
+				if (!this._listeners[type]) {
+					this._listeners[type] = [];
+				}
+				var listener = {
+						context: context,
+						func: func,
+						data: data
+				};
+				this._listeners[type].push(listener);
+			},
+			/** @private */
+			sendEvent: function(type, event) {
+				var listeners = this._listeners[type];
+				if (listeners) {
+					for (var i=0, len=listeners.length; i < len; i++){
+						var l = listeners[i];
+						if (l && l.context && l.func) {
+							l.func.call(l.context, event, l.data);
+						}
+					}
+				}
+			},
+			/** @private */
+			removeEventListener: function(type, context, func, data){
+				var listeners = this._listeners[type];
+				if (listeners) {
+					for (var i=0, len=listeners.length; i < len; i++){
+						var l = listeners[i];
+						if (l.context === context && l.func === func && l.data === data) {
+							listeners.splice(i, 1);
+							break;
+						}
+					}
+				}
+			}
+		};
+		return EventTable;
+	}());
+	
+	/** @private */
+	function Editor (options) {
+		this._init(options);
+	}
+	
+	Editor.prototype = /** @lends eclipse.Editor.prototype */ {
+		/**
+		 * Adds an event listener to the editor.
+		 * 
+		 * @param {String} type the event type. The supported events are:
+		 * <ul>
+		 * <li>"Modify" See {@link #onModify} </li>
+		 * <li>"Selection" See {@link #onSelection} </li>
+		 * <li>"Scroll" See {@link #onScroll} </li>
+		 * <li>"Verify" See {@link #onVerify} </li>
+		 * <li>"Destroy" See {@link #onDestroy} </li>
+		 * <li>"LineStyle" See {@link #onLineStyle} </li>
+		 * <li>"ModelChanging" See {@link #onModelChanging} </li>
+		 * <li>"ModelChanged" See {@link #onModelChanged} </li>
+		 * <li>"ContextMenu" See {@link #onContextMenu} </li>
+		 * </ul>
+		 * @param {Object} context the context of the function.
+		 * @param {Function} func the function that will be executed when the event happens. 
+		 *   The function should take an event as the first parameter and optional data as the second parameter.
+		 * @param {Object} [data] optional data passed to the function.
+		 * 
+		 * @see #removeEventListener
+		 */
+		addEventListener: function(type, context, func, data) {
+			this._eventTable.addEventListener(type, context, func, data);
+		},
+		/**
+		 * @class This interface represents a ruler for the editor.
+		 * <p>
+		 * A Ruler is a graphical element that is placed either on the left or on the right side of 
+		 * the editor. It can be used to provide the editor with per line decoration such as line numbering,
+		 * bookmarks, breakpoints, folding disclosures, etc. 
+		 * </p><p>
+		 * There are two types of rulers: page and document. A page ruler only shows the content for the lines that are
+		 * visible, while a document ruler always shows the whole content.
+		 * </p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#addRuler}
+		 * </p>		 
+		 * @name eclipse.Ruler
+		 * 
+		 */
+		/**
+		 * Returns the ruler overview type.
+		 *
+		 * @name getOverview
+		 * @methodOf eclipse.Ruler#
+		 * @returns {String} the overview type, which is either "page" or "document".
+		 *
+		 * @see #getLocation
+		 */
+		/**
+		 * Returns the ruler location.
+		 *
+		 * @name getLocation
+		 * @methodOf eclipse.Ruler#
+		 * @returns {String} the ruler location, which is either "left" or "right".
+		 */
+		/**
+		 * Returns the HTML content for the decoration of a given line.
+		 * <p>
+		 * If the line index is <code>-1</code>, the HTML content for the decoration
+		 * that determines the width of the ruler should be returned.
+		 * </p>
+		 *
+		 * @name getHTML
+		 * @methodOf eclipse.Ruler#
+		 * @param {Number} lineIndex
+		 * @returns {String} the HTML content for a given line, or generic line.
+		 *
+		 * @see #getStyle
+		 */
+		/**
+		 * Returns the CSS styling information for the decoration of a given line.
+		 * <p>
+		 * If the line index is <code>-1</code>, the CSS styling information for the decoration
+		 * that determines the width of the ruler should be returned. If the line is
+		 * <code>undefined</code>, the ruler styling information should be returned.
+		 * </p>
+		 *
+		 * @name getStyle
+		 * @methodOf eclipse.Ruler#
+		 * @param {Number} lineIndex
+		 * @returns {eclipse.Style} the CSS styling for ruler, given line, or generic line.
+		 *
+		 * @see #getHTML
+		 */
+		/**
+		 * Returns the indices of the lines that have decoration.
+		 * <p>
+		 * This function is only called for rulers with "document" overview type.
+		 * </p>
+		 * @name getAnnotations
+		 * @methodOf eclipse.Ruler#
+		 * @returns {Number[]} an array of line indices.
+		 */
+		/**
+		 * This event is sent when the user clicks a line decoration.
+		 *
+		 * @name onClick
+		 * @event
+		 * @methodOf eclipse.Ruler#
+		 * @param {Number} lineIndex the line index of the clicked decoration
+		 * @param {DOMEvent} e the click event
+		 */
+		/**
+		 * This event is sent when the user double clicks a line decoration.
+		 *
+		 * @name onDblClick
+		 * @event
+		 * @methodOf eclipse.Ruler#
+		 * @param {Number} lineIndex the line index of the double clicked decoration
+		 * @param {DOMEvent} e the double click event
+		 */
+		/**
+		 * Adds a ruler to the editor.
+		 *
+		 * @param {eclipse.Ruler} ruler the ruler.
+		 */
+		addRuler: function (ruler) {
+			var document = this._frameDocument;
+			var body = document.body;
+			var side = ruler.getLocation();
+			var rulerParent = side === "left" ? this._leftDiv : this._rightDiv;
+			if (!rulerParent) {
+				rulerParent = document.createElement("DIV");
+				rulerParent.style.overflow = "hidden";
+				rulerParent.style.MozUserSelect = "none";
+				rulerParent.style.WebkitUserSelect = "none";
+				if (isIE) {
+					rulerParent.attachEvent("onselectstart", function() {return false;});
+				}
+				rulerParent.style.position = "absolute";
+				rulerParent.style.top = "0px";
+				rulerParent.style.cursor = "default";
+				body.appendChild(rulerParent);
+				if (side === "left") {
+					this._leftDiv = rulerParent;
+					rulerParent.className = "editorLeftRuler";
+				} else {
+					this._rightDiv = rulerParent;
+					rulerParent.className = "editorRightRuler";
+				}
+				var table = document.createElement("TABLE");
+				rulerParent.appendChild(table);
+				table.cellPadding = "0px";
+				table.cellSpacing = "0px";
+				table.border = "0px";
+				table.insertRow(0);
+				var self = this;
+				addHandler(rulerParent, "click", function(e) { self._handleRulerEvent(e); });
+				addHandler(rulerParent, "dblclick", function(e) { self._handleRulerEvent(e); });
+			}
+			var div = document.createElement("DIV");
+			div._ruler = ruler;
+			div.rulerChanged = true;
+			div.style.position = "relative";
+			var row = rulerParent.firstChild.rows[0];
+			var index = row.cells.length;
+			var cell = row.insertCell(index);
+			cell.vAlign = "top";
+			cell.appendChild(div);
+			ruler.setEditor(this);
+			this._updatePage();
+		},
+		/**
+		 * Converts the given rectangle from one coordinate spaces to another.
+		 * <p>The supported coordinate spaces are:
+		 * <ul>
+		 *   <li>"document" - relative to document, the origin is the top-left corner of first line</li>
+		 *   <li>"page" - relative to html page that contains the editor</li>
+		 *   <li>"editor" - relative to editor, the origin is the top-left corner of the editor container</li>
+		 * </ul>
+		 * </p>
+		 * <p>All methods in the editor that take or return a position are in the document coordinate space.</p>
+		 *
+		 * @param rect the rectangle to convert.
+		 * @param rect.x the x of the rectangle.
+		 * @param rect.y the y of the rectangle.
+		 * @param rect.width the width of the rectangle.
+		 * @param rect.height the height of the rectangle.
+		 * @param {String} from the source coordinate space.
+		 * @param {String} to the destination coordinate space.
+		 *
+		 * @see #getLocationAtOffset
+		 * @see #getOffsetAtLocation
+		 * @see #getTopPixel
+		 * @see #setTopPixel
+		 */
+		convert: function(rect, from, to) {
+			var scroll = this._getScroll();
+			var editorPad = this._getEditorPadding();
+			var frame = this._frame.getBoundingClientRect();
+			var editorRect = this._editorDiv.getBoundingClientRect();
+			switch(from) {
+				case "document":
+					if (rect.x !== undefined) {
+						rect.x += - scroll.x + editorRect.left + editorPad.left;
+					}
+					if (rect.y !== undefined) {
+						rect.y += - scroll.y + editorRect.top + editorPad.top;
+					}
+					break;
+				case "page":
+					if (rect.x !== undefined) {
+						rect.x += - frame.left;
+					}
+					if (rect.y !== undefined) {
+						rect.y += - frame.top;
+					}
+					break;
+			}
+			//At this point rect is in the widget coordinate space
+			switch (to) {
+				case "document":
+					if (rect.x !== undefined) {
+						rect.x += scroll.x - editorRect.left - editorPad.left;
+					}
+					if (rect.y !== undefined) {
+						rect.y += scroll.y - editorRect.top - editorPad.top;
+					}
+					break;
+				case "page":
+					if (rect.x !== undefined) {
+						rect.x += frame.left;
+					}
+					if (rect.y !== undefined) {
+						rect.y += frame.top;
+					}
+					break;
+			}
+		},
+		/**
+		 * Destroys the editor. 
+		 * <p>
+		 * Removes the editor from the page and frees all resources created by the editor.
+		 * Calling this function causes the "Destroy" event to be fire so that all components
+		 * attached to editor can release their references.
+		 * </p>
+		 *
+		 * @see #onDestroy
+		 */
+		destroy: function() {
+			this._setGrab(null);
+			this._unhookEvents();
+			
+			/* Destroy rulers*/
+			var destroyRulers = function(rulerDiv) {
+				if (!rulerDiv) {
+					return;
+				}
+				var cells = rulerDiv.firstChild.rows[0].cells;
+				for (var i = 0; i < cells.length; i++) {
+					var div = cells[i].firstChild;
+					div._ruler.setEditor(null);
+				}
+			};
+			destroyRulers (this._leftDiv);
+			destroyRulers (this._rightDiv);
+
+			/* Destroy timers */
+			if (this._autoScrollTimerID) {
+				clearTimeout(this._autoScrollTimerID);
+				this._autoScrollTimerID = null;
+			}
+			if (this._updateTimer) {
+				clearTimeout(this._updateTimer);
+				this._updateTimer = null;
+			}
+			
+			/* Destroy DOM */
+			var parent = this._parent;
+			var frame = this._frame;
+			parent.removeChild(frame);
+			
+			if (isPad) {
+				parent.removeChild(this._touchDiv);
+				this._touchDiv = null;
+				this._selDiv1 = null;
+				this._selDiv2 = null;
+				this._selDiv3 = null;
+				this._textArea = null;
+			}
+			
+			var e = {};
+			this.onDestroy(e);
+			
+			this._parent = null;
+			this._parentDocument = null;
+			this._model = null;
+			this._selection = null;
+			this._doubleClickSelection = null;
+			this._eventTable = null;
+			this._frame = null;
+			this._frameDocument = null;
+			this._frameWindow = null;
+			this._scrollDiv = null;
+			this._editorDiv = null;
+			this._clientDiv = null;
+			this._overlayDiv = null;
+			this._keyBindings = null;
+			this._actions = null;
+		},
+		/**
+		 * Gives focus to the editor.
+		 */
+		focus: function() {
+			/*
+			* Feature in Chrome. When focus is called in the clientDiv without
+			* setting selection the browser will set the selection to the first dom 
+			* element, which can be above the client area. When this happen the 
+			* browser also scrolls the window to show that element.
+			* The fix is to call _updateDOMSelection() before calling focus().
+			*/
+			this._updateDOMSelection();
+			if (isPad) {
+				this._textArea.focus();
+			} else {
+				if (isOpera) { this._clientDiv.blur(); }
+				this._clientDiv.focus();
+			}
+			/*
+			* Feature in Safari. When focus is called the browser selects the clientDiv
+			* itself. The fix is to call _updateDOMSelection() after calling focus().
+			*/
+			this._updateDOMSelection();
+		},
+		/**
+		 * Returns all action names defined in the editor.
+		 * <p>
+		 * There are two types of actions, the predefined actions of the editor 
+		 * and the actions added by application code.
+		 * </p>
+		 * <p>
+		 * The predefined actions are:
+		 * <ul>
+		 *   <li>Navigation actions. These actions move the caret collapsing the selection.</li>
+		 *     <ul>
+		 *       <li>"lineUp" - moves the caret up by one line</li>
+		 *       <li>"lineDown" - moves the caret down by one line</li>
+		 *       <li>"lineStart" - moves the caret to beginning of the current line</li>
+		 *       <li>"lineEnd" - moves the caret to end of the current line </li>
+		 *       <li>"charPrevious" - moves the caret to the previous character</li>
+		 *       <li>"charNext" - moves the caret to the next character</li>
+		 *       <li>"pageUp" - moves the caret up by one page</li>
+		 *       <li>"pageDown" - moves the caret down by one page</li>
+		 *       <li>"wordPrevious" - moves the caret to the previous word</li>
+		 *       <li>"wordNext" - moves the caret to the next word</li>
+		 *       <li>"textStart" - moves the caret to the beginning of the document</li>
+		 *       <li>"textEnd" - moves the caret to the end of the document</li>
+		 *     </ul>
+		 *   <li>Selection actions. These actions move the caret extending the selection.</li>
+		 *     <ul>
+		 *       <li>"selectLineUp" - moves the caret up by one line</li>
+		 *       <li>"selectLineDown" - moves the caret down by one line</li>
+		 *       <li>"selectLineStart" - moves the caret to beginning of the current line</li>
+		 *       <li>"selectLineEnd" - moves the caret to end of the current line </li>
+		 *       <li>"selectCharPrevious" - moves the caret to the previous character</li>
+		 *       <li>"selectCharNext" - moves the caret to the next character</li>
+		 *       <li>"selectPageUp" - moves the caret up by one page</li>
+		 *       <li>"selectPageDown" - moves the caret down by one page</li>
+		 *       <li>"selectWordPrevious" - moves the caret to the previous word</li>
+		 *       <li>"selectWordNext" - moves the caret to the next word</li>
+		 *       <li>"selectTextStart" - moves the caret to the beginning of the document</li>
+		 *       <li>"selectTextEnd" - moves the caret to the end of the document</li>
+		 *       <li>"selectAll" - selects the entire document</li>
+		 *     </ul>
+		 *   <li>Edit actions. These actions modify the editor text</li>
+		 *     <ul>
+		 *       <li>"deletePrevious" - deletes the character preceding the caret</li>
+		 *       <li>"deleteNext" - deletes the charecter following the caret</li>
+		 *       <li>"deleteWordPrevious" - deletes the word preceding the caret</li>
+		 *       <li>"deleteWordNext" - deletes the word following the caret</li>
+		 *       <li>"tab" - inserts a tab character at the caret</li>
+		 *       <li>"enter" - inserts a line delimiter at the caret</li>
+		 *     </ul>
+		 *   <li>Clipboard actions.</li>
+		 *     <ul>
+		 *       <li>"copy" - copies the selected text to the clipboard</li>
+		 *       <li>"cut" - copies the selected text to the clipboard and deletes the selection</li>
+		 *       <li>"paste" - replaces the selected text with the clipboard contents</li>
+		 *     </ul>
+		 * </ul>
+		 * </p>
+		 *
+		 * @param {Boolean} [defaultAction=false] whether or not the predefined actions are included.
+		 * @returns {String[]} an array of action names defined in the editor.
+		 *
+		 * @see #invokeAction
+		 * @see #setAction
+		 * @see #setKeyBinding
+		 * @see #getKeyBindings
+		 */
+		getActions: function (defaultAction) {
+			var result = [];
+			var actions = this._actions;
+			for (var i = 0; i < actions.length; i++) {
+				if (!defaultAction && actions[i].defaultHandler) { continue; }
+				result.push(actions[i].name);
+			}
+			return result;
+		},
+		/**
+		 * Returns the bottom index.
+		 * <p>
+		 * The bottom index is the line that is currently at the bottom of the editor.  This
+		 * line may be partially visible depending on the vertical scroll of the editor. The parameter
+		 * <code>fullyVisible</code> determines whether to return only fully visible lines. 
+		 * </p>
+		 *
+		 * @param {Boolean} [fullyVisible=false] if <code>true</code>, returns the index of the last fully visible line. This
+		 *    parameter is ignored if the editor is not big enough to show one line.
+		 * @returns {Number} the index of the bottom line.
+		 *
+		 * @see #getTopIndex
+		 * @see #setTopIndex
+		 */
+		getBottomIndex: function(fullyVisible) {
+			return this._getBottomIndex(fullyVisible);
+		},
+		/**
+		 * Returns the bottom pixel.
+		 * <p>
+		 * The bottom pixel is the pixel position that is currently at
+		 * the bottom edge of the editor.  This position is relative to the
+		 * beginning of the document.
+		 * </p>
+		 *
+		 * @returns {Number} the bottom pixel.
+		 *
+		 * @see #getTopPixel
+		 * @see #setTopPixel
+		 * @see #convert
+		 */
+		getBottomPixel: function() {
+			return this._getScroll().y + this._getClientHeight();
+		},
+		/**
+		 * Returns the caret offset relative to the start of the document.
+		 *
+		 * @returns the caret offset relative to the start of the document.
+		 *
+		 * @see #setCaretOffset
+		 * @see #setSelection
+		 * @see #getSelection
+		 */
+		getCaretOffset: function () {
+			var s = this._getSelection();
+			return s.getCaret();
+		},
+		/**
+		 * Returns the client area.
+		 * <p>
+		 * The client area is the portion in pixels of the document that is visible. The
+		 * client area position is relative to the beginning of the document.
+		 * </p>
+		 *
+		 * @returns the client area rectangle {x, y, width, height}.
+		 *
+		 * @see #getTopPixel
+		 * @see #getBottomPixel
+		 * @see #getHorizontalPixel
+		 * @see #convert
+		 */
+		getClientArea: function() {
+			var scroll = this._getScroll();
+			return {x: scroll.x, y: scroll.y, width: this._getClientWidth(), height: this._getClientHeight()};
+		},
+		/**
+		 * Returns the horizontal pixel.
+		 * <p>
+		 * The horizontal pixel is the pixel position that is currently at
+		 * the left edge of the editor.  This position is relative to the
+		 * beginning of the document.
+		 * </p>
+		 *
+		 * @returns {Number} the horizontal pixel.
+		 *
+		 * @see #setHorizontalPixel
+		 * @see #convert
+		 */
+		getHorizontalPixel: function() {
+			return this._getScroll().x;
+		},
+		/**
+		 * Returns all the key bindings associated to the given action name.
+		 *
+		 * @param {String} name the action name.
+		 * @returns {eclipse.KeyBinding[]} the array of key bindings associated to the given action name.
+		 *
+		 * @see #setKeyBinding
+		 * @see #setAction
+		 */
+		getKeyBindings: function (name) {
+			var result = [];
+			var keyBindings = this._keyBindings;
+			for (var i = 0; i < keyBindings.length; i++) {
+				if (keyBindings[i].name === name) {
+					result.push(keyBindings[i].keyBinding);
+				}
+			}
+			return result;
+		},
+		/**
+		 * Returns the line height for a given line index.  Returns the default line
+		 * height if the line index is not specified.
+		 *
+		 * @param {Number} [lineIndex] the line index.
+		 * @returns {Number} the height of the line in pixels.
+		 *
+		 * @see #getLinePixel
+		 */
+		getLineHeight: function(lineIndex) {
+			return this._getLineHeight();
+		},
+		/**
+		 * Returns the top pixel position of a given line index relative to the beginning
+		 * of the document.
+		 * <p>
+		 * Clamps out of range indices.
+		 * </p>
+		 *
+		 * @param {Number} lineIndex the line index.
+		 * @returns {Number} the pixel position of the line.
+		 *
+		 * @see #setTopPixel
+		 * @see #convert
+		 */
+		getLinePixel: function(lineIndex) {
+			lineIndex = Math.min(Math.max(0, lineIndex), this._model.getLineCount());
+			var lineHeight = this._getLineHeight();
+			return lineHeight * lineIndex;
+		},
+		/**
+		 * Returns the {x, y} pixel location of the top-left corner of the character
+		 * bounding box at the specified offset in the document.  The pixel location
+		 * is relative to the document.
+		 * <p>
+		 * Clamps out of range offsets.
+		 * </p>
+		 *
+		 * @param {Number} offset the character offset
+		 * @returns the {x, y} pixel location of the given offset.
+		 *
+		 * @see #getOffsetAtLocation
+		 * @see #convert
+		 */
+		getLocationAtOffset: function(offset) {
+			var model = this._model;
+			offset = Math.min(Math.max(0, offset), model.getCharCount());
+			var lineIndex = model.getLineAtOffset(offset);
+			var scroll = this._getScroll();
+			var editorRect = this._editorDiv.getBoundingClientRect();
+			var editorPad = this._getEditorPadding();
+			var x = this._getOffsetToX(offset) + scroll.x - editorRect.left - editorPad.left;
+			var y = this.getLinePixel(lineIndex);
+			return {x: x, y: y};
+		},
+		/**
+		 * Returns the text model of the editor.
+		 *
+		 * @returns {eclipse.TextModel} the text model of the editor.
+		 */
+		getModel: function() {
+			return this._model;
+		},
+		/**
+		 * Returns the character offset nearest to the given pixel location.  The
+		 * pixel location is relative to the document.
+		 *
+		 * @param x the x of the location
+		 * @param y the y of the location
+		 * @returns the character offset at the given location.
+		 *
+		 * @see #getLocationAtOffset
+		 */
+		getOffsetAtLocation: function(x, y) {
+			var model = this._model;
+			var scroll = this._getScroll();
+			var editorRect = this._editorDiv.getBoundingClientRect();
+			var editorPad = this._getEditorPadding();
+			var lineIndex = this._getYToLine(y - scroll.y);
+			x += -scroll.x + editorRect.left + editorPad.left;
+			var offset = this._getXToOffset(lineIndex, x);
+			return offset;
+		},
+		/**
+		 * Returns the editor selection.
+		 * <p>
+		 * The selection is defined by a start and end character offset relative to the
+		 * document. The character at end offset is not included in the selection.
+		 * </p>
+		 * 
+		 * @returns {eclipse.Selection} the editor selection
+		 *
+		 * @see #setSelection
+		 */
+		getSelection: function () {
+			var s = this._getSelection();
+			return {start: s.start, end: s.end};
+		},
+		/**
+		 * Returns the text for the given range.
+		 * <p>
+		 * The text does not include the character at the end offset.
+		 * </p>
+		 *
+		 * @param {Number} [start=0] the start offset of text range.
+		 * @param {Number} [end=char count] the end offset of text range.
+		 *
+		 * @see #setText
+		 */
+		getText: function(start, end) {
+			var model = this._model;
+			return model.getText(start, end);
+		},
+		/**
+		 * Returns the top index.
+		 * <p>
+		 * The top index is the line that is currently at the top of the editor.  This
+		 * line may be partially visible depending on the vertical scroll of the editor. The parameter
+		 * <code>fullyVisible</code> determines whether to return only fully visible lines. 
+		 * </p>
+		 *
+		 * @param {Boolean} [fullyVisible=false] if <code>true</code>, returns the index of the first fully visible line. This
+		 *    parameter is ignored if the editor is not big enough to show one line.
+		 * @returns {Number} the index of the top line.
+		 *
+		 * @see #getBottomIndex
+		 * @see #setTopIndex
+		 */
+		getTopIndex: function(fullyVisible) {
+			return this._getTopIndex(fullyVisible);
+		},
+		/**
+		 * Returns the top pixel.
+		 * <p>
+		 * The top pixel is the pixel position that is currently at
+		 * the top edge of the editor.  This position is relative to the
+		 * beginning of the document.
+		 * </p>
+		 *
+		 * @returns {Number} the top pixel.
+		 *
+		 * @see #getBottomPixel
+		 * @see #setTopPixel
+		 * @see #convert
+		 */
+		getTopPixel: function() {
+			return this._getScroll().y;
+		},
+		/**
+		 * Executes the action handler associated with the given name.
+		 * <p>
+		 * The application defined action takes precedence over predefined actions unless
+		 * the <code>defaultAction</code> paramater is <code>true</code>.
+		 * </p>
+		 * <p>
+		 * If the application defined action returns <code>false</code>, the editor predefined
+		 * action is executed if present.
+		 * </p>
+		 *
+		 * @param {String} name the action name.
+		 * @param {Boolean} [defaultAction] whether to always execute the predefined action.
+		 * @returns {Boolean} <code>true</code> if the action was executed.
+		 *
+		 * @see #setAction
+		 * @see #getActions
+		 */
+		invokeAction: function (name, defaultAction) {
+			var actions = this._actions;
+			for (var i = 0; i < actions.length; i++) {
+				var a = actions[i];
+				if (a.name && a.name === name) {
+					if (!defaultAction && a.userHandler) {
+						if (a.userHandler()) { return; }
+					}
+					if (a.defaultHandler) { return a.defaultHandler(); }
+					return false;
+				}
+			}
+			return false;
+		},
+		/**
+		 * @class This is the event sent when the editor is destroyed.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#event:onDestroy}
+		 * </p>
+		 * @name eclipse.DestroyEvent
+		 */
+		/**
+		 * This event is sent when the editor has been destroyed.
+		 *
+		 * @event
+		 * @param {eclipse.DestroyEvent} destroyEvent the event
+		 *
+		 * @see #destroy
+		 */
+		onDestroy: function(destroyEvent) {
+			this._eventTable.sendEvent("Destroy", destroyEvent);
+		},
+		/**
+		 * @class This object is used to define style information for the editor.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#event:onLineStyle}
+		 * </p>		 
+		 * @name eclipse.Style
+		 * 
+		 * @property {String} styleClass A CSS class name.
+		 * @property {Object} style An object with CSS properties.
+		 */
+		/**
+		 * @class This object is used to style range.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#event:onLineStyle}
+		 * </p>		 
+		 * @name eclipse.StyleRange
+		 * 
+		 * @property {Number} start The start character offset, relative to the document, where the style should be applied.
+		 * @property {Number} end The end character offset (exclusive), relative to the document, where the style should be applied.
+		 * @property {eclipse.Style} style The style for the range.
+		 */
+		/**
+		 * @class This is the event sent when the editor needs the style information for a line.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#event:onLineStyle}
+		 * </p>		 
+		 * @name eclipse.LineStyleEvent
+		 * 
+		 * @property {Number} lineIndex The line index.
+		 * @property {String} lineText The line text.
+		 * @property {Number} lineStart The character offset, relative to document, of the first character in the line.
+		 * @property {eclipse.Style} style The style for the entire line (output argument).
+		 * @property {eclipse.StyleRange[]} ranges An array of style ranges for the line (output argument).		 
+		 */
+		/**
+		 * This event is sent when the editor needs the style information for a line.
+		 *
+		 * @event
+		 * @param {eclipse.LineStyleEvent} lineStyleEvent the event
+		 */
+		onLineStyle: function(lineStyleEvent) {
+			this._eventTable.sendEvent("LineStyle", lineStyleEvent);
+		},
+		/**
+		 * @class This is the event sent when the text in the model has changed.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#event:onModelChanged}<br/>
+		 * {@link eclipse.TextModel#onChanged}
+		 * </p>
+		 * @name eclipse.ModelChangedEvent
+		 * 
+		 * @property {Number} start The character offset in the model where the change has occurred.
+		 * @property {Number} removedCharCount The number of characters removed from the model.
+		 * @property {Number} addedCharCount The number of characters added to the model.
+		 * @property {Number} removedLineCount The number of lines removed from the model.
+		 * @property {Number} addedLineCount The number of lines added to the model.
+		 */
+		/**
+		 * This event is sent when the text in the model has changed.
+		 *
+		 * @event
+		 * @param {eclipse.ModelChangingEvent} modelChangingEvent the event
+		 */
+		onModelChanged: function(modelChangedEvent) {
+			this._eventTable.sendEvent("ModelChanged", modelChangedEvent);
+		},
+		/**
+		 * @class This is the event sent when the text in the model is about to change.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#event:onModelChanging}<br/>
+		 * {@link eclipse.TextModel#onChanging}
+		 * </p>
+		 * @name eclipse.ModelChangingEvent
+		 * 
+		 * @property {String} text The text that is about to be inserted in the model.
+		 * @property {Number} start The character offset in the model where the change will occur.
+		 * @property {Number} removedCharCount The number of characters being removed from the model.
+		 * @property {Number} addedCharCount The number of characters being added to the model.
+		 * @property {Number} removedLineCount The number of lines being removed from the model.
+		 * @property {Number} addedLineCount The number of lines being added to the model.
+		 */
+		/**
+		 * This event is sent when the text in the model is about to change.
+		 *
+		 * @event
+		 * @param {eclipse.ModelChangingEvent} modelChangingEvent the event
+		 */
+		onModelChanging: function(modelChangingEvent) {
+			this._eventTable.sendEvent("ModelChanging", modelChangingEvent);
+		},
+		/**
+		 * @class This is the event sent when the text is modified by the editor.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#event:onModify}
+		 * </p>
+		 * @name eclipse.ModifyEvent
+		 */
+		/**
+		 * This event is sent when the editor has changed text in the model.
+		 * <p>
+		 * If the text is changed directly through the model API, this event
+		 * is not sent.
+		 * </p>
+		 *
+		 * @event
+		 * @param {eclipse.ModifyEvent} modifyEvent the event
+		 */
+		onModify: function(modifyEvent) {
+			this._eventTable.sendEvent("Modify", modifyEvent);
+		},
+		/**
+		 * @class This is the event sent when the selection changes in the editor.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#event:onSelection}
+		 * </p>		 
+		 * @name eclipse.SelectionEvent
+		 * 
+		 * @property {eclipse.Selection} oldValue The old selection.
+		 * @property {eclipse.Selection} newValue The new selection.
+		 */
+		/**
+		 * This event is sent when the editor selection has changed.
+		 *
+		 * @event
+		 * @param {eclipse.SelectionEvent} selectionEvent the event
+		 */
+		onSelection: function(selectionEvent) {
+			this._eventTable.sendEvent("Selection", selectionEvent);
+		},
+		/**
+		 * @class This is the event sent when the editor scrolls.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#event:onScroll}
+		 * </p>		 
+		 * @name eclipse.ScrollEvent
+		 * 
+		 * @property oldValue The old scroll {x,y}.
+		 * @property newValue The new scroll {x,y}.
+		 */
+		/**
+		 * This event is sent when the editor scrolls vertically or horizontally.
+		 *
+		 * @event
+		 * @param {eclipse.ScrollEvent} scrollEvent the event
+		 */
+		onScroll: function(scrollEvent) {
+			this._eventTable.sendEvent("Scroll", scrollEvent);
+		},
+		/**
+		 * @class This is the event sent when the text is about to be modified by the editor.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#event:onVerify}
+		 * </p>
+		 * @name eclipse.VerifyEvent
+		 * 
+		 * @property {String} text The text being inserted.
+		 * @property {Number} start The start offset of the text range to be replaced.
+		 * @property {Number} end The end offset (exclusive) of the text range to be replaced.
+		 */
+		/**
+		 * This event is sent when the editor is about to change text in the model.
+		 * <p>
+		 * If the text is changed directly through the model API, this event
+		 * is not sent.
+		 * </p>
+		 * <p>
+		 * Listeners are allowed to change these parameters. Setting text to null
+		 * or undefined stops the change.
+		 * </p>
+		 *
+		 * @event
+		 * @param {eclipse.VerifyEvent} verifyEvent the event
+		 */
+		onVerify: function(verifyEvent) {
+			this._eventTable.sendEvent("Verify", verifyEvent);
+		},
+
+		/**
+		 * @class This is the event sent when the user right clicks or otherwise
+		 * invokes the context menu of the editor.
+		 * <p>
+		 * <b>See:</b><br/>
+		 * {@link eclipse.Editor}<br/>
+		 * {@link eclipse.Editor#event:onContextMenu}
+		 * </p>
+		 *
+		 * <p>
+		 * The event object is the contextmenu DOM event received from the browser.
+		 * </p>
+		 * @name eclipse.ContextMenuEvent
+		 */
+		/**
+		 * This event is sent when the user invokes the editor context menu.
+		 *
+		 * @event
+		 * @param {eclipse.ContextMenuEvent} contextMenuEvent the event
+		 */
+		onContextMenu: function(contextMenuEvent) {
+			this._eventTable.sendEvent("ContextMenu", contextMenuEvent);
+		},
+		/**
+		 * Redraws the text in the given line range.
+		 * <p>
+		 * The line at the end index is not redrawn.
+		 * </p>
+		 *
+		 * @param {Number} [startLine=0] the start line
+		 * @param {Number} [endLine=line count] the end line
+		 */
+		redrawLines: function(startLine, endLine, ruler) {
+			if (startLine === undefined) { startLine = 0; }
+			if (endLine === undefined) { endLine = this._model.getLineCount(); }
+			if (startLine === endLine) { return; }
+			var div = this._clientDiv;
+			if (ruler) {
+				var location = ruler.getLocation();//"left" or "right"
+				var divRuler = location === "left" ? this._leftDiv : this._rightDiv;
+				var cells = divRuler.firstChild.rows[0].cells;
+				for (var i = 0; i < cells.length; i++) {
+					if (cells[i].firstChild._ruler === ruler) {
+						div = cells[i].firstChild;
+						break;
+					}
+				}
+			}
+			if (ruler) {
+				div.rulerChanged = true;
+			}
+			if (!ruler || ruler.getOverview() === "page") {
+				var child = div.firstChild;
+				while (child) {
+					var lineIndex = child.lineIndex;
+					if (startLine <= lineIndex && lineIndex < endLine) {
+						child.lineChanged = true;
+					}
+					child = child.nextSibling;
+				}
+			}
+			if (!ruler) {
+				if (startLine <= this._maxLineIndex && this._maxLineIndex < endLine) {
+					this._maxLineIndex = -1;
+					this._maxLineWidth = 0;
+				}
+			}
+			this._queueUpdatePage();
+		},
+		/**
+		 * Redraws the text in the given range.
+		 * <p>
+		 * The character at the end offset is not redrawn.
+		 * </p>
+		 *
+		 * @param {Number} [start=0] the start offset of text range
+		 * @param {Number} [end=char count] the end offset of text range
+		 */
+		redrawRange: function(start, end) {
+			var model = this._model;
+			if (start === undefined) { start = 0; }
+			if (end === undefined) { end = model.getCharCount(); }
+			if (start === end) { return; }
+			var startLine = model.getLineAtOffset(start);
+			var endLine = model.getLineAtOffset(Math.max(0, end - 1)) + 1;
+			this.redrawLines(startLine, endLine);
+		},
+		/**
+		 * Removes an event listener from the editor.
+		 * <p>
+		 * All the parameters must be the same ones used to add the listener.
+		 * </p>
+		 * 
+		 * @param {String} type the event type.
+		 * @param {Object} context the context of the function.
+		 * @param {Function} func the function that will be executed when the event happens. 
+		 * @param {Object} [data] optional data passed to the function.
+		 * 
+		 * @see #addEventListener
+		 */
+		removeEventListener: function(type, context, func, data) {
+			this._eventTable.removeEventListener(type, context, func, data);
+		},
+		/**
+		 * Removes a ruler from the editor.
+		 *
+		 * @param {eclipse.Ruler} ruler the ruler.
+		 */
+		removeRuler: function (ruler) {
+			ruler.setEditor(null);
+			var side = ruler.getLocation();
+			var rulerParent = side === "left" ? this._leftDiv : this._rightDiv;
+			var row = rulerParent.firstChild.rows[0];
+			var cells = row.cells;
+			for (var index = 0; index < cells.length; index++) {
+				var cell = cells[index];
+				if (cell.firstChild._ruler === ruler) { break; }
+			}
+			if (index === cells.length) { return; }
+			row.cells[index]._ruler = undefined;
+			row.deleteCell(index);
+			this._updatePage();
+		},
+		/**
+		 * Associates an application defined handler to an action name.
+		 * <p>
+		 * If the action name is a predefined action, the given handler executes before
+		 * the default action handler.  If the given handler returns <code>true</code>, the
+		 * default action handler is not called.
+		 * </p>
+		 *
+		 * @param {String} name the action name.
+		 * @param {Function} handler the action handler.
+		 *
+		 * @see #getActions
+		 * @see #invokeAction
+		 */
+		setAction: function(name, handler) {
+			if (!name) { return; }
+			var actions = this._actions;
+			for (var i = 0; i < actions.length; i++) {
+				var a = actions[i];
+				if (a.name === name) {
+					a.userHandler = handler;
+					return;
+				}
+			}
+			actions.push({name: name, userHandler: handler});
+		},
+		/**
+		 * Associates a key binding with the given action name. Any previous
+		 * association with the specified key binding is overwriten. If the
+		 * action name is <code>null</code>, the association is removed.
+		 * 
+		 * @param {eclipse.KeyBinding} keyBinding the key binding
+		 * @param {String} name the action
+		 */
+		setKeyBinding: function(keyBinding, name) {
+			var keyBindings = this._keyBindings;
+			for (var i = 0; i < keyBindings.length; i++) {
+				var kb = keyBindings[i]; 
+				if (kb.keyBinding.equals(keyBinding)) {
+					if (name) {
+						kb.name = name;
+					} else {
+						if (kb.predefined) {
+							kb.name = null;
+						} else {
+							var oldName = kb.name; 
+							keyBindings.splice(i, 1);
+							var index = 0;
+							while (index < keyBindings.length && oldName !== keyBindings[index].name) {
+								index++;
+							}
+							if (index === keyBindings.length) {
+								/* <p>
+								 * Removing all the key bindings associated to an user action will cause
+								 * the user action to be removed. Editor predefined actions are never
+								 * removed (so they can be reinstalled in the future). 
+								 * </p>
+								 */
+								var actions = this._actions;
+								for (var j = 0; j < actions.length; j++) {
+									if (actions[j].name === oldName) {
+										if (!actions[j].defaultHandler) {
+											actions.splice(j, 1);
+										}
+									}
+								}
+							}
+						}
+					}
+					return;
+				}
+			}
+			if (name) {
+				keyBindings.push({keyBinding: keyBinding, name: name});
+			}
+		},
+		/**
+		 * Sets the caret offset relative to the start of the document.
+		 *
+		 * @param {Number} caret the caret offset relative to the start of the document.
+		 * @param {Boolean} [show=true] if <code>true</coce>, the editor will scroll if needed to show the caret location.
+		 *
+		 * @see #getCaretOffset
+		 * @see #setSelection
+		 * @see #getSelection
+		 */
+		setCaretOffset: function(offset, show) {
+			var charCount = this._model.getCharCount();
+			offset = Math.max(0, Math.min (offset, charCount));
+			var selection = new Selection(offset, offset, false);
+			this._setSelection (selection, show === undefined || show);
+		},
+		/**
+		 * Sets the horizontal pixel.
+		 * <p>
+		 * The horizontal pixel is the pixel position that is currently at
+		 * the left edge of the editor.  This position is relative to the
+		 * beginning of the document.
+		 * </p>
+		 *
+		 * @param {Number} pixel the horizontal pixel.
+		 *
+		 * @see #getHorizontalPixel
+		 * @see #convert
+		 */
+		setHorizontalPixel: function(pixel) {
+			pixel = Math.max(0, pixel);
+			this._scrollView(pixel - this._getScroll().x, 0);
+		},
+		/**
+		 * Sets the text model of the editor.
+		 *
+		 * @param {eclipse.TextModel} model the text model of the editor.
+		 */
+		setModel: function(model) {
+			if (!model) { return; }
+			this._model.removeListener(this._modelListener);
+			var oldLineCount = this._model.getLineCount();
+			var oldCharCount = this._model.getCharCount();
+			var newLineCount = model.getLineCount();
+			var newCharCount = model.getCharCount();
+			var newText = model.getText();
+			var e = {
+				text: newText,
+				start: 0,
+				removedCharCount: oldCharCount,
+				addedCharCount: newCharCount,
+				removedLineCount: oldLineCount,
+				addedLineCount: newLineCount
+			};
+			this.onModelChanging(e); 
+			this.redrawRange();
+			this._model = model;
+			e = {
+				start: 0,
+				removedCharCount: oldCharCount,
+				addedCharCount: newCharCount,
+				removedLineCount: oldLineCount,
+				addedLineCount: newLineCount
+			};
+			this.onModelChanged(e); 
+			this._model.addListener(this._modelListener);
+			this.redrawRange();
+		},
+		/**
+		 * Sets the editor selection.
+		 * <p>
+		 * The selection is defined by a start and end character offset relative to the
+		 * document. The character at end offset is not included in the selection.
+		 * </p>
+		 * <p>
+		 * The caret is always placed at the end offset. The start offset can be
+		 * greater than the end offset to place the caret at the beginning of the
+		 * selection.
+		 * </p>
+		 * <p>
+		 * Clamps out of range offsets.
+		 * </p>
+		 * 
+		 * @param {Number} start the start offset of the selection
+		 * @param {Number} end the end offset of the selection
+		 * @param {Boolean} [show=true] if <code>true</coce>, the editor will scroll if needed to show the caret location.
+		 *
+		 * @see #getSelection
+		 */
+		setSelection: function (start, end, show) {
+			var caret = start > end;
+			if (caret) {
+				var tmp = start;
+				start = end;
+				end = tmp;
+			}
+			var charCount = this._model.getCharCount();
+			start = Math.max(0, Math.min (start, charCount));
+			end = Math.max(0, Math.min (end, charCount));
+			var selection = new Selection(start, end, caret);
+			this._setSelection(selection, show === undefined || show);
+		},
+		/**
+		 * Replaces the text in the given range with the given text.
+		 * <p>
+		 * The character at the end offset is not replaced.
+		 * </p>
+		 * <p>
+		 * When both <code>start</code> and <code>end</code> parameters
+		 * are not specified, the editor places the caret at the beginning
+		 * of the document and scrolls to make it visible.
+		 * </p>
+		 *
+		 * @param {String} text the new text.
+		 * @param {Number} [start=0] the start offset of text range.
+		 * @param {Number} [end=char count] the end offset of text range.
+		 *
+		 * @see #getText
+		 */
+		setText: function (text, start, end) {
+			var reset = start === undefined && end === undefined;
+			if (start === undefined) { start = 0; }
+			if (end === undefined) { end = this._model.getCharCount(); }
+			this._modifyContent({text: text, start: start, end: end, _code: true}, !reset);
+			if (reset) {
+				this._columnX = -1;
+				this._setSelection(new Selection (0, 0, false), true);
+				this._showCaret();
+				
+				/*
+				* Bug in Firefox 4.  For some reason, the caret does not show after the
+				* editor is refreshed.  The fix is to toggle the contentEditable state and
+				* force the clientDiv to loose and receive focus.
+				*/
+				if (isFirefox >= 4) {
+					var clientDiv = this._clientDiv;
+					clientDiv.contentEditable = false;
+					clientDiv.contentEditable = true;
+					clientDiv.blur();
+					clientDiv.focus();
+				}
+			}
+		},
+		/**
+		 * Sets the top index.
+		 * <p>
+		 * The top index is the line that is currently at the top of the editor.  This
+		 * line may be partially visible depending on the vertical scroll of the editor.
+		 * </p>
+		 *
+		 * @param {Number} topIndex the index of the top line.
+		 *
+		 * @see #getBottomIndex
+		 * @see #getTopIndex
+		 */
+		setTopIndex: function(topIndex) {
+			var model = this._model;
+			if (model.getCharCount() === 0) {
+				return;
+			}
+			var lineCount = model.getLineCount();
+			var lineHeight = this._getLineHeight();
+			var pageSize = Math.max(1, Math.min(lineCount, Math.floor(this._getClientHeight () / lineHeight)));
+			if (topIndex < 0) {
+				topIndex = 0;
+			} else if (topIndex > lineCount - pageSize) {
+				topIndex = lineCount - pageSize;
+			}
+			var pixel = topIndex * lineHeight - this._getScroll().y;
+			this._scrollView(0, pixel);
+		},
+		/**
+		 * Sets the top pixel.
+		 * <p>
+		 * The top pixel is the pixel position that is currently at
+		 * the top edge of the editor.  This position is relative to the
+		 * beginning of the document.
+		 * </p>
+		 *
+		 * @param {Number} pixel the top pixel.
+		 *
+		 * @see #getBottomPixel
+		 * @see #getTopPixel
+		 * @see #convert
+		 */
+		setTopPixel: function(pixel) {
+			var lineHeight = this._getLineHeight();
+			var clientHeight = this._getClientHeight();
+			var lineCount = this._model.getLineCount();
+			pixel = Math.min(Math.max(0, pixel), lineHeight * lineCount - clientHeight);
+			this._scrollView(0, pixel - this._getScroll().y);
+		},
+		/**
+		 * Scrolls the selection into view if needed.
+		 *
+		 * @see #getSelection
+		 * @see #setSelection
+		 */
+		showSelection: function() {
+			return this._showCaret();
+		},
+		
+		/**************************************** Event handlers *********************************/
+		_handleBodyMouseDown: function (e) {
+			if (!e) { e = window.event; }
+			/*
+			 * Prevent clicks outside of the editor from taking focus 
+			 * away the editor. Note that in Firefox and Opera clicking on the 
+			 * scrollbar also take focus from the editor. Other browsers
+			 * do not have this problem and stopping the click over the 
+			 * scrollbar for them causes mouse capture problems.
+			 */
+			var topNode = isOpera ? this._clientDiv : this._overlayDiv || this._editorDiv;
+			
+			var temp = e.target ? e.target : e.srcElement;
+			while (temp) {
+				if (topNode === temp) {
+					return;
+				}
+				temp = temp.parentNode;
+			}
+			if (e.preventDefault) { e.preventDefault(); }
+			if (e.stopPropagation){ e.stopPropagation(); }
+			if (!isW3CEvents) {
+				/* In IE 8 is not possible to prevent the default handler from running
+				*  during mouse down event using usual API. The workaround is to use
+				*  setCapture/releaseCapture. 
+				*/ 
+				topNode.setCapture();
+				setTimeout(function() { topNode.releaseCapture(); }, 0);
+			}
+		},
+		_handleBlur: function (e) {
+			if (!e) { e = window.event; }
+			this._hasFocus = false;
+			/*
+			* Bug in IE 8 and earlier. For some reason when text is deselected
+			* the overflow selection at the end of some lines does not get redrawn.
+			* The fix is to create a DOM element in the body to force a redraw.
+			*/
+			if (isIE < 9) {
+				if (!this._getSelection().isEmpty()) {
+					var document = this._frameDocument;
+					var child = document.createElement("DIV");
+					var body = document.body;
+					body.appendChild(child);
+					body.removeChild(child);
+				}
+			}
+			if (isFirefox || isIE) {
+				if (this._selDiv1) {
+					var color = isIE ? "transparent" : "#AFAFAF";
+					this._selDiv1.style.background = color;
+					this._selDiv2.style.background = color;
+					this._selDiv3.style.background = color;
+				}
+			}
+		},
+		_handleContextMenu: function (e) {
+			if (!e) { e = window.event; }
+			if (e.preventDefault) { e.preventDefault(); }
+			return false;
+		},
+		_handleCopy: function (e) {
+			if (this._ignoreCopy) { return; }
+			if (!e) { e = window.event; }
+			if (this._doCopy(e)) {
+				if (e.preventDefault) { e.preventDefault(); }
+				return false;
+			}
+		},
+		_handleCut: function (e) {
+			if (!e) { e = window.event; }
+			if (this._doCut(e)) {
+				if (e.preventDefault) { e.preventDefault(); }
+				return false;
+			}
+		},
+		_handleDataModified: function(e) {
+			this._startIME();
+		},
+		_handleDblclick: function (e) {
+			if (!e) { e = window.event; }
+			var time = e.timeStamp ? e.timeStamp : new Date().getTime();
+			this._lastMouseTime = time;
+			if (this._clickCount !== 2) {
+				this._clickCount = 2;
+				this._handleMouse(e);
+			}
+		},
+		_handleDragStart: function (e) {
+			if (!e) { e = window.event; }
+			if (e.preventDefault) { e.preventDefault(); }
+			return false;
+		},
+		_handleDragOver: function (e) {
+			if (!e) { e = window.event; }
+			e.dataTransfer.dropEffect = "none";
+			if (e.preventDefault) { e.preventDefault(); }
+			return false;
+		},
+		_handleDrop: function (e) {
+			if (!e) { e = window.event; }
+			if (e.preventDefault) { e.preventDefault(); }
+			return false;
+		},
+		_handleDocFocus: function (e) {
+			if (!e) { e = window.event; }
+			this._clientDiv.focus();
+		},
+		_handleFocus: function (e) {
+			if (!e) { e = window.event; }
+			this._hasFocus = true;
+			/*
+			* Feature in IE.  The selection is not restored when the
+			* editor gets focus and the caret is always placed at the
+			* beginning of the document.  The fix is to update the DOM
+			* selection during the focus event.
+			*/
+			if (isIE) {
+				this._updateDOMSelection();
+			}
+			if (isFirefox || isIE) {
+				if (this._selDiv1) {
+					var color = this._hightlightRGB;
+					this._selDiv1.style.background = color;
+					this._selDiv2.style.background = color;
+					this._selDiv3.style.background = color;
+				}
+			}
+		},
+		_handleKeyDown: function (e) {
+			if (!e) { e = window.event; }
+			if (isPad) {
+				if (e.keyCode === 8) {
+					this._doBackspace({});
+					e.preventDefault();
+				}
+				return;
+			}
+			if (e.keyCode === 229) {
+				if (this.readonly) {
+					if (e.preventDefault) { e.preventDefault(); }
+					return false;
+				}
+				this._startIME();
+			} else {
+				this._commitIME();
+			}
+			/*
+			* Feature in Firefox. When a key is held down the browser sends 
+			* right number of keypress events but only one keydown. This is
+			* unexpected and causes the editor to only execute an action
+			* just one time. The fix is to ignore the keydown event and 
+			* execute the actions from the keypress handler.
+			* Note: This only happens on the Mac and Linux (Firefox 3.6).
+			*
+			* Feature in Opera.  Opera sends keypress events even for non-printable
+			* keys.  The fix is to handle actions in keypress instead of keydown.
+			*/
+			if (((isMac || isLinux) && isFirefox < 4) || isOpera) {
+				this._keyDownEvent = e;
+				return true;
+			}
+			
+			if (this._doAction(e)) {
+				if (e.preventDefault) {
+					e.preventDefault(); 
+				} else {
+					e.cancelBubble = true;
+					e.returnValue = false;
+					e.keyCode = 0;
+				}
+				return false;
+			}
+		},
+		_handleKeyPress: function (e) {
+			if (!e) { e = window.event; }
+			/*
+			* Feature in Embedded WebKit.  Embedded WekKit on Mac runs in compatibility mode and
+			* generates key press events for these Unicode values (Function keys).  This does not
+			* happen in Safari or Chrome.  The fix is to ignore these key events.
+			*/
+			if (isMac && isWebkit) {
+				if ((0xF700 <= e.keyCode && e.keyCode <= 0xF7FF) || e.keyCode === 13 || e.keyCode === 8) {
+					if (e.preventDefault) { e.preventDefault(); }
+					return false;
+				}
+			}
+			if (((isMac || isLinux) && isFirefox < 4) || isOpera) {
+				if (this._doAction(this._keyDownEvent)) {
+					if (e.preventDefault) { e.preventDefault(); }
+					return false;
+				}
+			}
+			var ctrlKey = isMac ? e.metaKey : e.ctrlKey;
+			if (e.charCode !== undefined) {
+				if (ctrlKey) {
+					switch (e.charCode) {
+						/*
+						* In Firefox and Safari if ctrl+v, ctrl+c ctrl+x is canceled
+						* the clipboard events are not sent. The fix to allow
+						* the browser to handles these key events.
+						*/
+						case 99://c
+						case 118://v
+						case 120://x
+							return true;
+					}
+				}
+			}
+			var ignore = false;
+			if (isMac) {
+				if (e.ctrlKey || e.metaKey) { ignore = true; }
+			} else {
+				if (isFirefox) {
+					//Firefox clears the state mask when ALT GR generates input
+					if (e.ctrlKey || e.altKey) { ignore = true; }
+				} else {
+					//IE and Chrome only send ALT GR when input is generated
+					if (e.ctrlKey ^ e.altKey) { ignore = true; }
+				}
+			}
+			if (!ignore) {
+				var key = isOpera ? e.which : (e.charCode !== undefined ? e.charCode : e.keyCode);
+				if (key !== 0) {
+					this._doContent(String.fromCharCode (key));
+					if (e.preventDefault) { e.preventDefault(); }
+					return false;
+				}
+			}
+		},
+		_handleKeyUp: function (e) {
+			if (!e) { e = window.event; }
+			
+			// don't commit for space (it happens during JP composition)  
+			if (e.keyCode === 13) {
+				this._commitIME();
+			}
+		},
+		_handleMouse: function (e) {
+			var target = this._frameWindow;
+			if (isIE) { target = this._clientDiv; }
+			if (this._overlayDiv) {
+				var self = this;
+				setTimeout(function () {
+					self.focus();
+				}, 0);
+			}
+			if (this._clickCount === 1) {
+				this._setGrab(target);
+				this._setSelectionTo(e.clientX, e.clientY, e.shiftKey);
+			} else {
+				/*
+				* Feature in IE8 and older, the sequence of events in the IE8 event model
+				* for a doule-click is:
+				*
+				*	down
+				*	up
+				*	up
+				*	dblclick
+				*
+				* Given that the mouse down/up events are not balanced, it is not possible to
+				* grab on mouse down and ungrab on mouse up.  The fix is to grab on the first
+				* mouse down and ungrab on mouse move when the button 1 is not set.
+				*/
+				if (isW3CEvents) { this._setGrab(target); }
+				
+				this._doubleClickSelection = null;
+				this._setSelectionTo(e.clientX, e.clientY, e.shiftKey);
+				this._doubleClickSelection = this._getSelection();
+			}
+		},
+		_handleMouseDown: function (e) {
+			if (!e) { e = window.event; }
+			var left = e.which ? e.button === 0 : e.button === 1;
+			this._commitIME();
+			if (left) {
+				this._isMouseDown = true;
+				var deltaX = Math.abs(this._lastMouseX - e.clientX);
+				var deltaY = Math.abs(this._lastMouseY - e.clientY);
+				var time = e.timeStamp ? e.timeStamp : new Date().getTime();  
+				if ((time - this._lastMouseTime) <= this._clickTime && deltaX <= this._clickDist && deltaY <= this._clickDist) {
+					this._clickCount++;
+				} else {
+					this._clickCount = 1;
+				}
+				this._lastMouseX = e.clientX;
+				this._lastMouseY = e.clientY;
+				this._lastMouseTime = time;
+				this._handleMouse(e);
+				if (isOpera) {
+						if (!this._hasFocus) {
+							this.focus();
+						}
+						e.preventDefault();
+				}
+			}
+		},
+		_handleMouseMove: function (e) {
+			if (!e) { e = window.event; }
+			/*
+			* Feature in IE8 and older, the sequence of events in the IE8 event model
+			* for a doule-click is:
+			*
+			*	down
+			*	up
+			*	up
+			*	dblclick
+			*
+			* Given that the mouse down/up events are not balanced, it is not possible to
+			* grab on mouse down and ungrab on mouse up.  The fix is to grab on the first
+			* mouse down and ungrab on mouse move when the button 1 is not set.
+			*
+			* In order to detect double-click and drag gestures, it is necessary to send
+			* a mouse down event from mouse move when the button is still down and isMouseDown
+			* flag is not set.
+			*/
+			if (!isW3CEvents) {
+				if (e.button === 0) {
+					this._setGrab(null);
+					return true;
+				}
+				if (!this._isMouseDown && e.button === 1 && (this._clickCount & 1) !== 0) {
+					this._clickCount = 2;
+					return this._handleMouse(e, this._clickCount);
+				}
+			}
+			
+			var x = e.clientX;
+			var y = e.clientY;
+			var editorPad = this._getEditorPadding();
+			var editorRect = this._editorDiv.getBoundingClientRect();
+			var width = this._getClientWidth (), height = this._getClientHeight();
+			var leftEdge = editorRect.left + editorPad.left;
+			var topEdge = editorRect.top + editorPad.top;
+			var rightEdge = editorRect.left + editorPad.left + width;
+			var bottomEdge = editorRect.top + editorPad.top + height;
+			var model = this._model;
+			var caretLine = model.getLineAtOffset(this._getSelection().getCaret());
+			if (y < topEdge && caretLine !== 0) {
+				this._doAutoScroll("up", x, y - topEdge);
+			} else if (y > bottomEdge && caretLine !== model.getLineCount() - 1) {
+				this._doAutoScroll("down", x, y - bottomEdge);
+			} else if (x < leftEdge) {
+				this._doAutoScroll("left", x - leftEdge, y);
+			} else if (x > rightEdge) {
+				this._doAutoScroll("right", x - rightEdge, y);
+			} else {
+				this._endAutoScroll();
+				this._setSelectionTo(x, y, true);
+				/*
+				* Feature in IE. IE does redraw the selection background right
+				* away after the selection changes because of mouse move events.
+				* The fix is to call getBoundingClientRect() on the
+				* body element to force the selection to be redraw. Some how
+				* calling this method forces a redraw.
+				*/
+				if (isIE) {
+					var body = this._frameDocument.body;
+					body.getBoundingClientRect();
+				}
+			}
+		},
+		_handleMouseUp: function (e) {
+			if (!e) { e = window.event; }
+			this._endAutoScroll();
+			var left = e.which ? e.button === 0 : e.button === 1;
+			if (left) {
+				this._isMouseDown=false;
+				
+				/*
+				* Feature in IE8 and older, the sequence of events in the IE8 event model
+				* for a doule-click is:
+				*
+				*	down
+				*	up
+				*	up
+				*	dblclick
+				*
+				* Given that the mouse down/up events are not balanced, it is not possible to
+				* grab on mouse down and ungrab on mouse up.  The fix is to grab on the first
+				* mouse down and ungrab on mouse move when the button 1 is not set.
+				*/
+				if (isW3CEvents) { this._setGrab(null); }
+			}
+		},
+		_handleMouseWheel: function (e) {
+			if (!e) { e = window.event; }
+			var lineHeight = this._getLineHeight();
+			var pixelX = 0, pixelY = 0;
+			// Note: On the Mac the correct behaviour is to scroll by pixel.
+			if (isFirefox) {
+				var pixel;
+				if (isMac) {
+					pixel = e.detail * 3;
+				} else {
+					var limit = 256;
+					pixel = Math.max(-limit, Math.min(limit, e.detail)) * lineHeight;
+				}
+				if (e.axis === e.HORIZONTAL_AXIS) {
+					pixelX = pixel;
+				} else {
+					pixelY = pixel;
+				}
+			} else {
+				//Webkit
+				if (isMac) {
+					/*
+					* In Safari, the wheel delta is a multiple of 120. In order to
+					* convert delta to pixel values, it is necessary to divide delta
+					* by 40.
+					*
+					* In Chrome, the wheel delta depends on the type of the mouse. In
+					* general, it is the pixel value for Mac mice and track pads, but
+					* it is a multiple of 120 for other mice. There is no presise
+					* way to determine if it is pixel value or a multiple of 120.
+					* 
+					* Note that the current approach does not calculate the correct
+					* pixel value for Mac mice when the delta is a multiple of 120.
+					*/
+					var denominatorX = 40, denominatorY = 40;
+					if (isChrome) {
+						if (e.wheelDeltaX % 120 !== 0) { denominatorX = 1; }
+						if (e.wheelDeltaY % 120 !== 0) { denominatorY = 1; }
+					}
+					pixelX = -e.wheelDeltaX / denominatorX;
+					if (-1 < pixelX && pixelX < 0) { pixelX = -1; }
+					if (0 < pixelX && pixelX < 1) { pixelX = 1; }
+					pixelY = -e.wheelDeltaY / denominatorY;
+					if (-1 < pixelY && pixelY < 0) { pixelY = -1; }
+					if (0 < pixelY && pixelY < 1) { pixelY = 1; }
+				} else {
+					pixelX = -e.wheelDeltaX;
+					var linesToScroll = 8;
+					pixelY = (-e.wheelDeltaY / 120 * linesToScroll) * lineHeight;
+				}
+			}
+			/* 
+			* Feature in Safari. If the event target is removed from the DOM 
+			* safari stops smooth scrolling. The fix is keep the element target
+			* in the DOM and remove it on a later time. 
+			*
+			* Note: Using a timer is not a solution, because the timeout needs to
+			* be at least as long as the gesture (which is too long).
+			*/
+			if (isSafari) {
+				var lineDiv = e.target;
+				while (lineDiv && lineDiv.lineIndex === undefined) {
+					lineDiv = lineDiv.parentNode;
+				}
+				this._mouseWheelLine = lineDiv;
+			}
+			var oldScroll = this._getScroll();
+			this._scrollView(pixelX, pixelY);
+			var newScroll = this._getScroll();
+			if (isSafari) { this._mouseWheelLine = null; }
+			if (oldScroll.x !== newScroll.x || oldScroll.y !== newScroll.y) {
+				if (e.preventDefault) { e.preventDefault(); }
+				return false;
+			}
+		},
+		_handlePaste: function (e) {
+			if (this._ignorePaste) { return; }
+			if (!e) { e = window.event; }
+			if (this._doPaste(e)) {
+				if (isIE) {
+					/*
+					 * Bug in IE,  
+					 */
+					var self = this;
+					setTimeout(function() {self._updateDOMSelection();}, 0);
+				}
+				if (e.preventDefault) { e.preventDefault(); }
+				return false;
+			}
+		},
+		_handleResize: function (e) {
+			if (!e) { e = window.event; }
+			var element = this._frameDocument.documentElement;
+			var newWidth = element.clientWidth;
+			var newHeight = element.clientHeight;
+			if (this._frameWidth !== newWidth || this._frameHeight !== newHeight) {
+				this._frameWidth = newWidth;
+				this._frameHeight = newHeight;
+				this._updatePage();
+			}
+		},
+		_handleRulerEvent: function (e) {
+			if (!e) { e = window.event; }
+			var target = e.target ? e.target : e.srcElement;
+			var lineIndex = target.lineIndex;
+			var element = target;
+			while (element && !element._ruler) {
+				if (lineIndex === undefined && element.lineIndex !== undefined) {
+					lineIndex = element.lineIndex;
+				}
+				element = element.parentNode;
+			}
+			var ruler = element ? element._ruler : null;
+			if (isPad && lineIndex === undefined && ruler && ruler.getOverview() === "document") {
+				var buttonHeight = 17;
+				var clientHeight = this._getClientHeight ();
+				var lineHeight = this._getLineHeight ();
+				var editorPad = this._getEditorPadding();
+				var trackHeight = clientHeight + editorPad.top + editorPad.bottom - 2 * buttonHeight;
+				var pixels = this._model.getLineCount () * lineHeight;
+				this.setTopPixel(Math.floor((e.clientY - buttonHeight - lineHeight) * pixels / trackHeight));
+			}
+			if (ruler) {
+				switch (e.type) {
+					case "click":
+						if (ruler.onClick) { ruler.onClick(lineIndex, e); }
+						break;
+					case "dblclick": 
+						if (ruler.onDblClick) { ruler.onDblClick(lineIndex, e); }
+						break;
+				}
+			}
+		},
+		_handleScroll: function () {
+			this._doScroll(this._getScroll());
+		},
+		_handleSelectStart: function (e) {
+			if (!e) { e = window.event; }
+			if (this._ignoreSelect) {
+				if (e && e.preventDefault) { e.preventDefault(); }
+				return false;
+			}
+		},
+		_handleInput: function (e) {
+			var textArea = this._textArea;
+			this._doContent(textArea.value);
+			textArea.selectionStart = textArea.selectionEnd = 0;
+			textArea.value = "";
+			e.preventDefault();
+		},
+		_handleTextInput: function (e) {
+			this._doContent(e.data);
+			e.preventDefault();
+		},
+		_touchConvert: function (touch) {
+			var rect = this._frame.getBoundingClientRect();
+			var body = this._parentDocument.body;
+			return {left: touch.clientX - rect.left - body.scrollLeft, top: touch.clientY - rect.top - body.scrollTop};
+		},
+		_handleTouchStart: function (e) {
+			var touches = e.touches, touch, pt, sel;
+			this._touchMoved = false;
+			this._touchStartScroll = undefined;
+			if (touches.length === 1) {
+				touch = touches[0];
+				var pageX = touch.pageX;
+				var pageY = touch.pageY;
+				this._touchStartX = pageX;
+				this._touchStartY = pageY;
+				this._touchStartTime = e.timeStamp;
+				this._touchStartScroll = this._getScroll();
+				sel = this._getSelection();
+				pt = this._touchConvert(touches[0]);
+				this._touchGesture = "none";
+				if (!sel.isEmpty()) {
+					if (this._hitOffset(sel.end, pt.left, pt.top)) {
+						this._touchGesture = "extendEnd";
+					} else if (this._hitOffset(sel.start, pt.left, pt.top)) {
+						this._touchGesture = "extendStart";
+					}
+				}
+				if (this._touchGesture === "none") {
+					var textArea = this._textArea;
+					textArea.value = "";
+					textArea.style.left = "-1000px";
+					textArea.style.top = "-1000px";
+					textArea.style.width = "3000px";
+					textArea.style.height = "3000px";
+					var self = this;
+					var f = function() {
+						self._touchTimeout = null;
+						self._clickCount = 1;
+						self._setSelectionTo(pt.left, pt.top, false);
+					};
+					this._touchTimeout = setTimeout(f, 200);
+				}
+			} else if (touches.length === 2) {
+				this._touchGesture = "select";
+				if (this._touchTimeout) {
+					clearTimeout(this._touchTimeout);
+					this._touchTimeout = null;
+				}
+				pt = this._touchConvert(touches[0]);
+				var offset1 = this._getXToOffset(this._getYToLine(pt.top), pt.left);
+				pt = this._touchConvert(touches[1]);
+				var offset2 = this._getXToOffset(this._getYToLine(pt.top), pt.left);
+				sel = this._getSelection();
+				sel.setCaret(offset1);
+				sel.extend(offset2);
+				this._setSelection(sel, true, true);
+			}
+			//Cannot prevent to show maginifier
+//			e.preventDefault();
+		},
+		_handleTouchMove: function (e) {
+			this._touchMoved = true;
+			var touches = e.touches, pt, sel;
+			if (touches.length === 1) {
+				var touch = touches[0];
+				var pageX = touch.pageX;
+				var pageY = touch.pageY;
+				var deltaX = this._touchStartX - pageX;
+				var deltaY = this._touchStartY - pageY;
+				pt = this._touchConvert(touch);
+				sel = this._getSelection();
+				if (this._touchTimeout) {
+					clearTimeout(this._touchTimeout);
+					this._touchTimeout = null;
+				}
+				if (this._touchGesture === "none") {
+					if ((e.timeStamp - this._touchStartTime) < 200 && (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)) {
+						this._touchGesture = "scroll";
+					} else {
+						this._touchGesture = "caret";
+					}
+				}
+				if (this._touchGesture === "select") {
+					if (this._hitOffset(sel.end, pt.left, pt.top)) {
+						this._touchGesture = "extendEnd";
+					} else if (this._hitOffset(sel.start, pt.left, pt.top)) {
+						this._touchGesture = "extendStart";
+					} else {
+						this._touchGesture = "caret";
+					}
+				}
+				switch (this._touchGesture) {
+					case "scroll":
+						this._touchStartX = pageX;
+						this._touchStartY = pageY;
+						this._scrollView(deltaX, deltaY);
+						break;
+					case "extendStart":
+					case "extendEnd":
+						this._clickCount = 1;
+						var lineIndex = this._getYToLine(pt.top);
+						var offset = this._getXToOffset(lineIndex, pt.left);
+						sel.setCaret(this._touchGesture === "extendStart" ? sel.end : sel.start);
+						sel.extend(offset);
+						if (offset >= sel.end && this._touchGesture === "extendStart") {
+							this._touchGesture = "extendEnd";
+						}
+						if (offset <= sel.start && this._touchGesture === "extendEnd") {
+							this._touchGesture = "extendStart";
+						}
+						this._setSelection(sel, true, true);
+						break;
+					case "caret":
+						this._setSelectionTo(pt.left, pt.top, false);
+						break;
+				}
+			} else if (touches.length === 2) {
+				pt = this._touchConvert(touches[0]);
+				var offset1 = this._getXToOffset(this._getYToLine(pt.top), pt.left);
+				pt = this._touchConvert(touches[1]);
+				var offset2 = this._getXToOffset(this._getYToLine(pt.top), pt.left);
+				sel = this._getSelection();
+				sel.setCaret(offset1);
+				sel.extend(offset2);
+				this._setSelection(sel, true, true);
+			}
+			e.preventDefault();
+		},
+		_handleTouchEnd: function (e) {
+			if (!this._touchMoved) {
+				if (e.touches.length === 0 && e.changedTouches.length === 1 && this._touchTimeout) {
+					clearTimeout(this._touchTimeout);
+					this._touchTimeout = null;
+					var touch = e.changedTouches[0];
+					this._clickCount = 1;
+					var pt = this._touchConvert(touch);
+					this._setSelectionTo(pt.left, pt.top, false);
+				}
+			}
+			if (e.touches.length === 0) {
+				var self = this;
+				setTimeout(function() {
+					var selection = self._getSelection();
+					var text = self._model.getText(selection.start, selection.end);
+					var textArea = self._textArea;
+					textArea.value = text;
+					textArea.selectionStart = 0;
+					textArea.selectionEnd = text.length;
+					if (!selection.isEmpty()) {
+						var touchRect = self._touchDiv.getBoundingClientRect();
+						var bounds = self._getOffsetBounds(selection.start);
+						textArea.style.left = (touchRect.width / 2) + "px";
+						textArea.style.top = ((bounds.top > 40 ? bounds.top - 30 : bounds.top + 30)) + "px";
+					}
+				}, 0);
+			}
+			e.preventDefault();
+		},
+
+		/************************************ Actions ******************************************/
+		_doAction: function (e) {
+			var keyBindings = this._keyBindings;
+			for (var i = 0; i < keyBindings.length; i++) {
+				var kb = keyBindings[i];
+				if (kb.keyBinding.match(e)) {
+					if (kb.name) {
+						var actions = this._actions;
+						for (var j = 0; j < actions.length; j++) {
+							var a = actions[j];
+							if (a.name === kb.name) {
+								if (a.userHandler) {
+									if (!a.userHandler()) {
+										if (a.defaultHandler) {
+											a.defaultHandler();
+										}
+									}
+								} else if (a.defaultHandler) {
+									a.defaultHandler();
+								}
+								break;
+							}
+						}
+					}
+					return true;
+				}
+			}
+			return false;
+		},
+		_doBackspace: function (args) {
+			var selection = this._getSelection();
+			if (selection.isEmpty()) {
+				var model = this._model;
+				var caret = selection.getCaret();
+				var lineIndex = model.getLineAtOffset(caret);
+				if (caret === model.getLineStart(lineIndex)) {
+					if (lineIndex > 0) {
+						selection.extend(model.getLineEnd(lineIndex - 1));
+					}
+				} else {
+					selection.extend(this._getOffset(caret, args.unit, -1));
+				}
+			}
+			this._modifyContent({text: "", start: selection.start, end: selection.end}, true);
+			return true;
+		},
+		_doContent: function (text) {
+			var selection = this._getSelection();
+			this._modifyContent({text: text, start: selection.start, end: selection.end, _ignoreDOMSelection: true}, true);
+		},
+		_doCopy: function (e) {
+			var selection = this._getSelection();
+			if (!selection.isEmpty()) {
+				var text = this._model.getText(selection.start, selection.end);
+				return this._setClipboardText(text, e);
+			}
+			return true;
+		},
+		_doCursorNext: function (args) {
+			if (!args.select) {
+				if (this._clearSelection("next")) { return true; }
+			}
+			var model = this._model;
+			var selection = this._getSelection();
+			var caret = selection.getCaret();
+			var lineIndex = model.getLineAtOffset(caret);
+			if (caret === model.getLineEnd(lineIndex)) {
+				if (lineIndex + 1 < model.getLineCount()) {
+					selection.extend(model.getLineStart(lineIndex + 1));
+				}
+			} else {
+				selection.extend(this._getOffset(caret, args.unit, 1));
+			}
+			if (!args.select) { selection.collapse(); }
+			this._setSelection(selection, true);
+			return true;
+		},
+		_doCursorPrevious: function (args) {
+			if (!args.select) {
+				if (this._clearSelection("previous")) { return true; }
+			}
+			var model = this._model;
+			var selection = this._getSelection();
+			var caret = selection.getCaret();
+			var lineIndex = model.getLineAtOffset(caret);
+			if (caret === model.getLineStart(lineIndex)) {
+				if (lineIndex > 0) {
+					selection.extend(model.getLineEnd(lineIndex - 1));
+				}
+			} else {
+				selection.extend(this._getOffset(caret, args.unit, -1));
+			}
+			if (!args.select) { selection.collapse(); }
+			this._setSelection(selection, true);
+			return true;
+		},
+		_doCut: function (e) {
+			var selection = this._getSelection();
+			if (!selection.isEmpty()) {
+				var text = this._model.getText(selection.start, selection.end);
+				this._doContent("");
+				return this._setClipboardText(text, e);
+			}
+			return true;
+		},
+		_doDelete: function (args) {
+			var selection = this._getSelection();
+			if (selection.isEmpty()) {
+				var model = this._model;
+				var caret = selection.getCaret();
+				var lineIndex = model.getLineAtOffset(caret);
+				if (caret === model.getLineEnd (lineIndex)) {
+					if (lineIndex + 1 < model.getLineCount()) {
+						selection.extend(model.getLineStart(lineIndex + 1));
+					}
+				} else {
+					selection.extend(this._getOffset(caret, args.unit, 1));
+				}
+			}
+			this._modifyContent({text: "", start: selection.start, end: selection.end}, true);
+			return true;
+		},
+		_doEnd: function (args) {
+			var selection = this._getSelection();
+			var model = this._model;
+			if (args.ctrl) {
+				selection.extend(model.getCharCount());
+			} else {
+				var lineIndex = model.getLineAtOffset(selection.getCaret());
+				selection.extend(model.getLineEnd(lineIndex)); 
+			}
+			if (!args.select) { selection.collapse(); }
+			this._setSelection(selection, true);
+			return true;
+		},
+		_doEnter: function (args) {
+			var model = this._model;
+			this._doContent(model.getLineDelimiter()); 
+			return true;
+		},
+		_doHome: function (args) {
+			var selection = this._getSelection();
+			var model = this._model;
+			if (args.ctrl) {
+				selection.extend(0);
+			} else {
+				var lineIndex = model.getLineAtOffset(selection.getCaret());
+				selection.extend(model.getLineStart(lineIndex)); 
+			}
+			if (!args.select) { selection.collapse(); }
+			this._setSelection(selection, true);
+			return true;
+		},
+		_doLineDown: function (args) {
+			var model = this._model;
+			var selection = this._getSelection();
+			var caret = selection.getCaret();
+			var lineIndex = model.getLineAtOffset(caret);
+			if (lineIndex + 1 < model.getLineCount()) {
+				var x = this._columnX;
+				if (x === -1 || args.select) {
+					x = this._getOffsetToX(caret);
+				}
+				selection.extend(this._getXToOffset(lineIndex + 1, x));
+				if (!args.select) { selection.collapse(); }
+				this._setSelection(selection, true, true);
+				this._columnX = x;//fix x by scrolling
+			}
+			return true;
+		},
+		_doLineUp: function (args) {
+			var model = this._model;
+			var selection = this._getSelection();
+			var caret = selection.getCaret();
+			var lineIndex = model.getLineAtOffset(caret);
+			if (lineIndex > 0) {
+				var x = this._columnX;
+				if (x === -1 || args.select) {
+					x = this._getOffsetToX(caret);
+				}
+				selection.extend(this._getXToOffset(lineIndex - 1, x));
+				if (!args.select) { selection.collapse(); }
+				this._setSelection(selection, true, true);
+				this._columnX = x;//fix x by scrolling
+			}
+			return true;
+		},
+		_doPageDown: function (args) {
+			var model = this._model;
+			var selection = this._getSelection();
+			var caret = selection.getCaret();
+			var caretLine = model.getLineAtOffset(caret);
+			var lineCount = model.getLineCount();
+			if (caretLine < lineCount - 1) {
+				var clientHeight = this._getClientHeight();
+				var lineHeight = this._getLineHeight();
+				var lines = Math.floor(clientHeight / lineHeight);
+				var scrollLines = Math.min(lineCount - caretLine - 1, lines);
+				scrollLines = Math.max(1, scrollLines);
+				var x = this._columnX;
+				if (x === -1 || args.select) {
+					x = this._getOffsetToX(caret);
+				}
+				selection.extend(this._getXToOffset(caretLine + scrollLines, x));
+				if (!args.select) { selection.collapse(); }
+				this._setSelection(selection, false, false);
+				
+				var verticalMaximum = lineCount * lineHeight;
+				var verticalScrollOffset = this._getScroll().y;
+				var scrollOffset = verticalScrollOffset + scrollLines * lineHeight;
+				if (scrollOffset + clientHeight > verticalMaximum) {
+					scrollOffset = verticalMaximum - clientHeight;
+				} 
+				if (scrollOffset > verticalScrollOffset) {
+					this._scrollView(0, scrollOffset - verticalScrollOffset);
+				} else {
+					this._updateDOMSelection();
+				}
+				this._columnX = x;//fix x by scrolling
+			}
+			return true;
+		},
+		_doPageUp: function (args) {
+			var model = this._model;
+			var selection = this._getSelection();
+			var caret = selection.getCaret();
+			var caretLine = model.getLineAtOffset(caret);
+			if (caretLine > 0) {
+				var clientHeight = this._getClientHeight();
+				var lineHeight = this._getLineHeight();
+				var lines = Math.floor(clientHeight / lineHeight);
+				var scrollLines = Math.max(1, Math.min(caretLine, lines));
+				var x = this._columnX;
+				if (x === -1 || args.select) {
+					x = this._getOffsetToX(caret);
+				}
+				selection.extend(this._getXToOffset(caretLine - scrollLines, x));
+				if (!args.select) { selection.collapse(); }
+				this._setSelection(selection, false, false);
+				
+				var verticalScrollOffset = this._getScroll().y;
+				var scrollOffset = Math.max(0, verticalScrollOffset - scrollLines * lineHeight);
+				if (scrollOffset < verticalScrollOffset) {
+					this._scrollView(0, scrollOffset - verticalScrollOffset);
+				} else {
+					this._updateDOMSelection();
+				}
+				this._columnX = x;//fix x by scrolling
+			}
+			return true;
+		},
+		_doPaste: function(e) {
+			var text = this._getClipboardText(e);
+			if (text) {
+				this._doContent(text);
+			}
+			return text !== null;
+		},
+		_doScroll: function (scroll) {
+			var oldX = this._hScroll;
+			var oldY = this._vScroll;
+			if (oldX !== scroll.x || oldY !== scroll.y) {
+				this._hScroll = scroll.x;
+				this._vScroll = scroll.y;
+				this._commitIME();
+				this._updatePage();
+				var e = {
+					oldValue: {x: oldX, y: oldY},
+					newValue: scroll
+				};
+				this.onScroll(e);
+			}
+		},
+		_doSelectAll: function (args) {
+			var model = this._model;
+			var selection = this._getSelection();
+			selection.setCaret(0);
+			selection.extend(model.getCharCount());
+			this._setSelection(selection, false);
+			return true;
+		},
+		_doTab: function (args) {
+			this._doContent("\t"); 
+			return true;
+		},
+		
+		/************************************ Internals ******************************************/
+		_applyStyle: function(style, node) {
+			if (!style) {
+				return;
+			}
+			if (style.styleClass) {
+				node.className = style.styleClass;
+			}
+			var properties = style.style;
+			if (properties) {
+				for (var s in properties) {
+					if (properties.hasOwnProperty(s)) {
+						node.style[s] = properties[s];
+					}
+				}
+			}
+		},
+		_autoScroll: function () {
+			var selection = this._getSelection();
+			var line;
+			var x = this._autoScrollX;
+			if (this._autoScrollDir === "up" || this._autoScrollDir === "down") {
+				var scroll = this._autoScrollY / this._getLineHeight();
+				scroll = scroll < 0 ? Math.floor(scroll) : Math.ceil(scroll);
+				line = this._model.getLineAtOffset(selection.getCaret());
+				line = Math.max(0, Math.min(this._model.getLineCount() - 1, line + scroll));
+			} else if (this._autoScrollDir === "left" || this._autoScrollDir === "right") {
+				line = this._getYToLine(this._autoScrollY);
+				x += this._getOffsetToX(selection.getCaret());
+			}
+			selection.extend(this._getXToOffset(line, x));
+			this._setSelection(selection, true);
+		},
+		_autoScrollTimer: function () {
+			this._autoScroll();
+			var self = this;
+			this._autoScrollTimerID = setTimeout(function () {self._autoScrollTimer();}, this._AUTO_SCROLL_RATE);
+		},
+		_calculateLineHeight: function() {
+			var parent = this._clientDiv;
+			var document = this._frameDocument;
+			var c = " ";
+			var line = document.createElement("DIV");
+			line.style.position = "fixed";
+			line.style.left = "-1000px";
+			var span1 = document.createElement("SPAN");
+			span1.appendChild(document.createTextNode(c));
+			line.appendChild(span1);
+			var span2 = document.createElement("SPAN");
+			span2.style.fontStyle = "italic";
+			span2.appendChild(document.createTextNode(c));
+			line.appendChild(span2);
+			var span3 = document.createElement("SPAN");
+			span3.style.fontWeight = "bold";
+			span3.appendChild(document.createTextNode(c));
+			line.appendChild(span3);
+			var span4 = document.createElement("SPAN");
+			span4.style.fontWeight = "bold";
+			span4.style.fontStyle = "italic";
+			span4.appendChild(document.createTextNode(c));
+			line.appendChild(span4);
+			parent.appendChild(line);
+			var spanRect1 = span1.getBoundingClientRect();
+			var spanRect2 = span2.getBoundingClientRect();
+			var spanRect3 = span3.getBoundingClientRect();
+			var spanRect4 = span4.getBoundingClientRect();
+			var h1 = spanRect1.bottom - spanRect1.top;
+			var h2 = spanRect2.bottom - spanRect2.top;
+			var h3 = spanRect3.bottom - spanRect3.top;
+			var h4 = spanRect4.bottom - spanRect4.top;
+			var fontStyle = 0;
+			var lineHeight = h1;
+			if (h2 > h1) {
+				lineHeight = h2;
+				fontStyle = 1;
+			}
+			if (h3 > h2) {
+				lineHeight = h3;
+				fontStyle = 2;
+			}
+			if (h4 > h3) {
+				lineHeight = h4;
+				fontStyle = 3;
+			}
+			this._largestFontStyle = fontStyle;
+			parent.removeChild(line);
+			return lineHeight;
+		},
+		_calculatePadding: function() {
+			var document = this._frameDocument;
+			var parent = this._clientDiv;
+			var pad = this._getPadding(this._editorDiv);
+			var div1 = document.createElement("DIV");
+			div1.style.position = "fixed";
+			div1.style.left = "-1000px";
+			div1.style.paddingLeft = pad.left + "px";
+			div1.style.paddingTop = pad.top + "px";
+			div1.style.paddingRight = pad.right + "px";
+			div1.style.paddingBottom = pad.bottom + "px";
+			div1.style.width = "100px";
+			div1.style.height = "100px";
+			var div2 = document.createElement("DIV");
+			div2.style.width = "100%";
+			div2.style.height = "100%";
+			div1.appendChild(div2);
+			parent.appendChild(div1);
+			var rect1 = div1.getBoundingClientRect();
+			var rect2 = div2.getBoundingClientRect();
+			parent.removeChild(div1);
+			pad = {
+				left: rect2.left - rect1.left,
+				top: rect2.top - rect1.top,
+				right: rect1.right - rect2.right,
+				bottom: rect1.bottom - rect2.bottom
+			};
+			return pad;
+		},
+		_clearSelection: function (direction) {
+			var selection = this._getSelection();
+			if (selection.isEmpty()) { return false; }
+			if (direction === "next") {
+				selection.start = selection.end;
+			} else {
+				selection.end = selection.start;
+			}
+			this._setSelection(selection, true);
+			return true;
+		},
+		_commitIME: function () {
+			if (this._imeOffset === -1) { return; }
+			// make the state of the IME match the state the editor expects it be in
+			// when the editor commits the text and IME also need to be committed
+			// this can be accomplished by changing the focus around
+			this._scrollDiv.focus();
+			this._clientDiv.focus();
+			
+			var model = this._model;
+			var lineIndex = model.getLineAtOffset(this._imeOffset);
+			var lineStart = model.getLineStart(lineIndex);
+			var newText = this._getDOMText(lineIndex);
+			var oldText = model.getLine(lineIndex);
+			var start = this._imeOffset - lineStart;
+			var end = start + newText.length - oldText.length;
+			if (start !== end) {
+				var insertText = newText.substring(start, end);
+				this._doContent(insertText);
+			}
+			this._imeOffset = -1;
+		},
+		_createActions: function () {
+			var KeyBinding = eclipse.KeyBinding;
+			//no duplicate keybindings
+			var bindings = this._keyBindings = [];
+
+			// Cursor Navigation
+			bindings.push({name: "lineUp",		keyBinding: new KeyBinding(38), predefined: true});
+			bindings.push({name: "lineDown",	keyBinding: new KeyBinding(40), predefined: true});
+			bindings.push({name: "charPrevious",	keyBinding: new KeyBinding(37), predefined: true});
+			bindings.push({name: "charNext",	keyBinding: new KeyBinding(39), predefined: true});
+			bindings.push({name: "pageUp",		keyBinding: new KeyBinding(33), predefined: true});
+			bindings.push({name: "pageDown",	keyBinding: new KeyBinding(34), predefined: true});
+			if (isMac) {
+				bindings.push({name: "lineStart",	keyBinding: new KeyBinding(37, true), predefined: true});
+				bindings.push({name: "lineEnd",		keyBinding: new KeyBinding(39, true), predefined: true});
+				bindings.push({name: "wordPrevious",	keyBinding: new KeyBinding(37, null, null, true), predefined: true});
+				bindings.push({name: "wordNext",	keyBinding: new KeyBinding(39, null, null, true), predefined: true});
+				bindings.push({name: "textStart",	keyBinding: new KeyBinding(36), predefined: true});
+				bindings.push({name: "textEnd",		keyBinding: new KeyBinding(35), predefined: true});
+				bindings.push({name: "textStart",	keyBinding: new KeyBinding(38, true), predefined: true});
+				bindings.push({name: "textEnd",		keyBinding: new KeyBinding(40, true), predefined: true});
+			} else {
+				bindings.push({name: "lineStart",	keyBinding: new KeyBinding(36), predefined: true});
+				bindings.push({name: "lineEnd",		keyBinding: new KeyBinding(35), predefined: true});
+				bindings.push({name: "wordPrevious",	keyBinding: new KeyBinding(37, true), predefined: true});
+				bindings.push({name: "wordNext",	keyBinding: new KeyBinding(39, true), predefined: true});
+				bindings.push({name: "textStart",	keyBinding: new KeyBinding(36, true), predefined: true});
+				bindings.push({name: "textEnd",		keyBinding: new KeyBinding(35, true), predefined: true});
+			}
+
+			// Select Cursor Navigation
+			bindings.push({name: "selectLineUp",		keyBinding: new KeyBinding(38, null, true), predefined: true});
+			bindings.push({name: "selectLineDown",		keyBinding: new KeyBinding(40, null, true), predefined: true});
+			bindings.push({name: "selectCharPrevious",	keyBinding: new KeyBinding(37, null, true), predefined: true});
+			bindings.push({name: "selectCharNext",		keyBinding: new KeyBinding(39, null, true), predefined: true});
+			bindings.push({name: "selectPageUp",		keyBinding: new KeyBinding(33, null, true), predefined: true});
+			bindings.push({name: "selectPageDown",		keyBinding: new KeyBinding(34, null, true), predefined: true});
+			if (isMac) {
+				bindings.push({name: "selectLineStart",	keyBinding: new KeyBinding(37, true, true), predefined: true});
+				bindings.push({name: "selectLineEnd",		keyBinding: new KeyBinding(39, true, true), predefined: true});
+				bindings.push({name: "selectWordPrevious",	keyBinding: new KeyBinding(37, null, true, true), predefined: true});
+				bindings.push({name: "selectWordNext",	keyBinding: new KeyBinding(39, null, true, true), predefined: true});
+				bindings.push({name: "selectTextStart",	keyBinding: new KeyBinding(36, null, true), predefined: true});
+				bindings.push({name: "selectTextEnd",		keyBinding: new KeyBinding(35, null, true), predefined: true});
+				bindings.push({name: "selectTextStart",	keyBinding: new KeyBinding(38, true, true), predefined: true});
+				bindings.push({name: "selectTextEnd",		keyBinding: new KeyBinding(40, true, true), predefined: true});
+			} else {
+				bindings.push({name: "selectLineStart",		keyBinding: new KeyBinding(36, null, true), predefined: true});
+				bindings.push({name: "selectLineEnd",		keyBinding: new KeyBinding(35, null, true), predefined: true});
+				bindings.push({name: "selectWordPrevious",	keyBinding: new KeyBinding(37, true, true), predefined: true});
+				bindings.push({name: "selectWordNext",		keyBinding: new KeyBinding(39, true, true), predefined: true});
+				bindings.push({name: "selectTextStart",		keyBinding: new KeyBinding(36, true, true), predefined: true});
+				bindings.push({name: "selectTextEnd",		keyBinding: new KeyBinding(35, true, true), predefined: true});
+			}
+
+			//Misc
+			bindings.push({name: "deletePrevious",		keyBinding: new KeyBinding(8), predefined: true});
+			bindings.push({name: "deletePrevious",		keyBinding: new KeyBinding(8, null, true), predefined: true});
+			bindings.push({name: "deleteNext",		keyBinding: new KeyBinding(46), predefined: true});
+			bindings.push({name: "deleteWordPrevious",	keyBinding: new KeyBinding(8, true), predefined: true});
+			bindings.push({name: "deleteWordPrevious",	keyBinding: new KeyBinding(8, true, true), predefined: true});
+			bindings.push({name: "deleteWordNext",		keyBinding: new KeyBinding(46, true), predefined: true});
+			bindings.push({name: "tab",			keyBinding: new KeyBinding(9), predefined: true});
+			bindings.push({name: "enter",			keyBinding: new KeyBinding(13), predefined: true});
+			bindings.push({name: "selectAll",		keyBinding: new KeyBinding('a', true), predefined: true});
+			if (isMac) {
+				bindings.push({name: "deleteNext",		keyBinding: new KeyBinding(46, null, true), predefined: true});
+				bindings.push({name: "deleteWordPrevious",	keyBinding: new KeyBinding(8, null, null, true), predefined: true});
+				bindings.push({name: "deleteWordNext",		keyBinding: new KeyBinding(46, null, null, true), predefined: true});
+			}
+				
+			/*
+			* Feature in IE/Chrome: prevent ctrl+'u', ctrl+'i', and ctrl+'b' from applying styles to the text.
+			*
+			* Note that Chrome applies the styles on the Mac with Ctrl instead of Cmd.
+			*/
+			var isMacChrome = isMac && isChrome;
+			bindings.push({name: null, keyBinding: new KeyBinding('u', !isMacChrome, false, false, isMacChrome), predefined: true});
+			bindings.push({name: null, keyBinding: new KeyBinding('i', !isMacChrome, false, false, isMacChrome), predefined: true});
+			bindings.push({name: null, keyBinding: new KeyBinding('b', !isMacChrome, false, false, isMacChrome), predefined: true});
+
+			if (isFirefox) {
+				bindings.push({name: "copy", keyBinding: new KeyBinding(45, true), predefined: true});
+				bindings.push({name: "paste", keyBinding: new KeyBinding(45, null, true), predefined: true});
+				bindings.push({name: "cut", keyBinding: new KeyBinding(46, null, true), predefined: true});
+			}
+
+			//1 to 1, no duplicates
+			var self = this;
+			this._actions = [
+				{name: "lineUp",		defaultHandler: function() {return self._doLineUp({select: false});}},
+				{name: "lineDown",		defaultHandler: function() {return self._doLineDown({select: false});}},
+				{name: "lineStart",		defaultHandler: function() {return self._doHome({select: false, ctrl:false});}},
+				{name: "lineEnd",		defaultHandler: function() {return self._doEnd({select: false, ctrl:false});}},
+				{name: "charPrevious",		defaultHandler: function() {return self._doCursorPrevious({select: false, unit:"character"});}},
+				{name: "charNext",		defaultHandler: function() {return self._doCursorNext({select: false, unit:"character"});}},
+				{name: "pageUp",		defaultHandler: function() {return self._doPageUp({select: false});}},
+				{name: "pageDown",		defaultHandler: function() {return self._doPageDown({select: false});}},
+				{name: "wordPrevious",		defaultHandler: function() {return self._doCursorPrevious({select: false, unit:"word"});}},
+				{name: "wordNext",		defaultHandler: function() {return self._doCursorNext({select: false, unit:"word"});}},
+				{name: "textStart",		defaultHandler: function() {return self._doHome({select: false, ctrl:true});}},
+				{name: "textEnd",		defaultHandler: function() {return self._doEnd({select: false, ctrl:true});}},
+				
+				{name: "selectLineUp",		defaultHandler: function() {return self._doLineUp({select: true});}},
+				{name: "selectLineDown",	defaultHandler: function() {return self._doLineDown({select: true});}},
+				{name: "selectLineStart",	defaultHandler: function() {return self._doHome({select: true, ctrl:false});}},
+				{name: "selectLineEnd",		defaultHandler: function() {return self._doEnd({select: true, ctrl:false});}},
+				{name: "selectCharPrevious",	defaultHandler: function() {return self._doCursorPrevious({select: true, unit:"character"});}},
+				{name: "selectCharNext",	defaultHandler: function() {return self._doCursorNext({select: true, unit:"character"});}},
+				{name: "selectPageUp",		defaultHandler: function() {return self._doPageUp({select: true});}},
+				{name: "selectPageDown",	defaultHandler: function() {return self._doPageDown({select: true});}},
+				{name: "selectWordPrevious",	defaultHandler: function() {return self._doCursorPrevious({select: true, unit:"word"});}},
+				{name: "selectWordNext",	defaultHandler: function() {return self._doCursorNext({select: true, unit:"word"});}},
+				{name: "selectTextStart",	defaultHandler: function() {return self._doHome({select: true, ctrl:true});}},
+				{name: "selectTextEnd",		defaultHandler: function() {return self._doEnd({select: true, ctrl:true});}},
+				
+				{name: "deletePrevious",	defaultHandler: function() {return self._doBackspace({unit:"character"});}},
+				{name: "deleteNext",		defaultHandler: function() {return self._doDelete({unit:"character"});}},
+				{name: "deleteWordPrevious",	defaultHandler: function() {return self._doBackspace({unit:"word"});}},
+				{name: "deleteWordNext",	defaultHandler: function() {return self._doDelete({unit:"word"});}},
+				{name: "tab",			defaultHandler: function() {return self._doTab();}},
+				{name: "enter",			defaultHandler: function() {return self._doEnter();}},
+				{name: "selectAll",		defaultHandler: function() {return self._doSelectAll();}},
+				{name: "copy",			defaultHandler: function() {return self._doCopy();}},
+				{name: "cut",			defaultHandler: function() {return self._doCut();}},
+				{name: "paste",			defaultHandler: function() {return self._doPaste();}}
+			];
+		},
+		_createLine: function(parent, sibling, document, lineIndex, model) {
+			var lineText = model.getLine(lineIndex);
+			var lineStart = model.getLineStart(lineIndex);
+			var e = {lineIndex: lineIndex, lineText: lineText, lineStart: lineStart};
+			this.onLineStyle(e);
+			var child = document.createElement("DIV");
+			child.lineIndex = lineIndex;
+			this._applyStyle(e.style, child);
+			if (lineText.length !== 0) {
+				var start = 0;
+				var tabSize = this._tabSize;
+				if (tabSize && tabSize !== 8) {
+					var tabIndex = lineText.indexOf("\t"), ignoreChars = 0;
+					while (tabIndex !== -1) {
+						this._createRange(child, document, e.ranges, start, tabIndex, lineText, lineStart);
+						var spacesCount = tabSize - ((tabIndex + ignoreChars) % tabSize);
+						var spaces = "\u00A0";
+						for (var i = 1; i < spacesCount; i++) {
+							spaces += " ";
+						}
+						var tabSpan = document.createElement("SPAN");
+						tabSpan.appendChild(document.createTextNode(spaces));
+						tabSpan.ignoreChars = spacesCount - 1;
+						ignoreChars += tabSpan.ignoreChars;
+						if (e.ranges) {
+							for (var j = 0; j < e.ranges.length; j++) {
+								var range = e.ranges[j];
+								var styleStart = range.start - lineStart;
+								var styleEnd = range.end - lineStart;
+								if (styleStart > tabIndex) { break; } 
+								if (styleStart <= tabIndex && tabIndex < styleEnd) {
+									this._applyStyle(range.style, tabSpan);
+									break;
+								}
+							}
+						} 
+						child.appendChild(tabSpan);
+						start = tabIndex + 1;
+						tabIndex = lineText.indexOf("\t", start);
+					}
+				}
+				this._createRange(child, document, e.ranges, start, lineText.length, lineText, lineStart);
+			}
+			
+			/*
+			* Firefox, Opera and IE9 do not extend the selection at the end of the line
+			* when the line is fully selected. The fix is to add an extra space at the end
+			* of the line.
+			*
+			* Note: the height of a div with only an empty span is zero.  The fix is
+			* the add a extra zero-width non-break space to preserve the default
+			* height in the line div. In Chrome this character shows a glyph, so the
+			* zero-width non-joiner character is used instead.
+			*
+			* Note: in order to support bold and italic fonts with fixed line
+			* height all lines need to have at least one span with the largest
+			* font.
+			*/
+			var span = document.createElement("SPAN");
+			span.ignoreChars = 1;
+			if ((this._largestFontStyle & 1) !== 0) {
+				span.style.fontStyle = "italic";
+			}
+			if ((this._largestFontStyle & 2) !== 0) {
+				span.style.fontWeight = "bold";
+			}
+			var fullSelection = this._fullSelection;
+			var extendSelection = !fullSelection && (isFirefox || isOpera || isIE >= 9);
+			var c = extendSelection ? " " : (isWebkit || isFirefox ? "\u200C" : "\uFEFF");
+			span.appendChild(document.createTextNode(c));
+			child.appendChild(span);
+			
+			parent.insertBefore(child, sibling);
+			return child;
+		},
+		_createRange: function(parent, document, ranges, start, end, text, lineStart) {
+			if (start >= end) { return; }
+			var span;
+			if (ranges) {
+				for (var i = 0; i < ranges.length; i++) {
+					var range = ranges[i];
+					if (range.end <= lineStart + start) { continue; }
+					var styleStart = Math.max(lineStart + start, range.start) - lineStart;
+					if (styleStart >= end) { break; }
+					var styleEnd = Math.min(lineStart + end, range.end) - lineStart;
+					if (styleStart < styleEnd) {
+						styleStart = Math.max(start, styleStart);
+						styleEnd = Math.min(end, styleEnd);
+						if (start < styleStart) {
+							span = document.createElement("SPAN");
+							span.appendChild(document.createTextNode(text.substring(start, styleStart)));
+							parent.appendChild(span);
+						}
+						span = document.createElement("SPAN");
+						span.appendChild(document.createTextNode(text.substring(styleStart, styleEnd)));
+						this._applyStyle(range.style, span);
+						parent.appendChild(span);
+						start = styleEnd;
+					}
+				}
+			}
+			if (start < end) {
+				span = document.createElement("SPAN");
+				span.appendChild(document.createTextNode(text.substring(start, end)));
+				parent.appendChild(span);
+			}
+		},
+		_doAutoScroll: function (direction, x, y) {
+			this._autoScrollDir = direction;
+			this._autoScrollX = x;
+			this._autoScrollY = y;
+			if (!this._autoScrollTimerID) {
+				this._autoScrollTimer();
+			}
+		},
+		_endAutoScroll: function () {
+			if (this._autoScrollTimerID) { clearTimeout(this._autoScrollTimerID); }
+			this._autoScrollDir = undefined;
+			this._autoScrollTimerID = undefined;
+		},
+		_getBoundsAtOffset: function (offset) {
+			var model = this._model;
+			var document = this._frameDocument;
+			var clientDiv = this._clientDiv;
+			var lineIndex = model.getLineAtOffset(offset);
+			var dummy;
+			var child = this._getLineNode(lineIndex);
+			if (!child) {
+				child = dummy = this._createLine(clientDiv, null, document, lineIndex, model);
+			}
+			var result = null;
+			if (offset < model.getLineEnd(lineIndex)) {
+				var lineOffset = model.getLineStart(lineIndex);
+				var lineChild = child.firstChild;
+				while (lineChild) {
+					var textNode = lineChild.firstChild;
+					var nodeLength = textNode.length; 
+					if (lineChild.ignoreChars) {
+						nodeLength -= lineChild.ignoreChars;
+					}
+					if (lineOffset + nodeLength > offset) {
+						var index = offset - lineOffset;
+						var range;
+						if (isRangeRects) {
+							range = document.createRange();
+							range.setStart(textNode, index);
+							range.setEnd(textNode, index + 1);
+							result = range.getBoundingClientRect();
+						} else if (isIE) {
+							range = document.body.createTextRange();
+							range.moveToElementText(lineChild);
+							range.collapse();
+							range.moveEnd("character", index + 1);
+							range.moveStart("character", index);
+							result = range.getBoundingClientRect();
+						} else {
+							var text = textNode.data;
+							lineChild.removeChild(textNode);
+							lineChild.appendChild(document.createTextNode(text.substring(0, index)));
+							var span = document.createElement("SPAN");
+							span.appendChild(document.createTextNode(text.substring(index, index + 1)));
+							lineChild.appendChild(span);
+							lineChild.appendChild(document.createTextNode(text.substring(index + 1)));
+							result = span.getBoundingClientRect();
+							lineChild.innerHTML = "";
+							lineChild.appendChild(textNode);
+							if (!dummy) {
+								/*
+								 * Removing the element node that holds the selection start or end
+								 * causes the selection to be lost. The fix is to detect this case
+								 * and restore the selection. 
+								 */
+								var s = this._getSelection();
+								if ((lineOffset <= s.start && s.start < lineOffset + nodeLength) ||  (lineOffset <= s.end && s.end < lineOffset + nodeLength)) {
+									this._updateDOMSelection();
+								}
+							}
+						}
+						if (isIE) {
+							var logicalXDPI = window.screen.logicalXDPI;
+							var deviceXDPI = window.screen.deviceXDPI;
+							result.left = result.left * logicalXDPI / deviceXDPI;
+							result.right = result.right * logicalXDPI / deviceXDPI;
+						}
+						break;
+					}
+					lineOffset += nodeLength;
+					lineChild = lineChild.nextSibling;
+				}
+			}
+			if (!result) {
+				var rect = this._getLineBoundingClientRect(child);
+				result = {left: rect.right, right: rect.right};
+			}
+			if (dummy) { clientDiv.removeChild(dummy); }
+			return result;
+		},
+		_getBottomIndex: function (fullyVisible) {
+			var child = this._bottomChild;
+			if (fullyVisible && this._getClientHeight() > this._getLineHeight()) {
+				var rect = child.getBoundingClientRect();
+				var clientRect = this._clientDiv.getBoundingClientRect();
+				if (rect.bottom > clientRect.bottom) {
+					child = this._getLinePrevious(child) || child;
+				}
+			}
+			return child.lineIndex;
+		},
+		_getFrameHeight: function() {
+			return this._frameDocument.documentElement.clientHeight;
+		},
+		_getFrameWidth: function() {
+			return this._frameDocument.documentElement.clientWidth;
+		},
+		_getClientHeight: function() {
+			var editorPad = this._getEditorPadding();
+			return Math.max(0, this._editorDiv.clientHeight - editorPad.top - editorPad.bottom);
+		},
+		_getClientWidth: function() {
+			var editorPad = this._getEditorPadding();
+			return Math.max(0, this._editorDiv.clientWidth - editorPad.left - editorPad.right);
+		},
+		_getClipboardText: function (event) {
+			if (this._frameWindow.clipboardData) {
+				//IE
+				return this._frameWindow.clipboardData.getData("Text");
+			}
+			if (isFirefox) {
+				var window = this._frameWindow;
+				var document = this._frameDocument;
+				var child = document.createElement("PRE");
+				child.style.position = "fixed";
+				child.style.left = "-1000px";
+				child.appendChild(document.createTextNode(" "));
+				this._clientDiv.appendChild(child);
+				var range = document.createRange();
+				range.selectNodeContents(child);
+				var sel = window.getSelection();
+				if (sel.rangeCount > 0) { sel.removeAllRanges(); }
+				sel.addRange(range);
+				var self = this;
+				var cleanup = function() {
+					self._updateDOMSelection();
+					self._clientDiv.removeChild(child);
+				};
+				var delimiter = this._model.getLineDelimiter();
+				var _getText = function() {
+					/*
+					* Use the selection anchor to determine the end of the pasted text as it is possible that
+					* some browsers (like Firefox) add extra elements (<BR>) after the pasted text.
+					*/
+					var endNode = null;
+					if (sel.anchorNode.nodeType !== child.TEXT_NODE) {
+						endNode = sel.anchorNode.childNodes[sel.anchorOffset];
+					}
+					var text = [];
+					var getNodeText = function(node) {
+						var nodeChild = node.firstChild;
+						while (nodeChild !== endNode) {
+							if (nodeChild.nodeType === child.TEXT_NODE) {
+								text.push(nodeChild !== sel.anchorNode ? nodeChild.data : nodeChild.data.substring(0, sel.anchorOffset));
+							} else if (nodeChild.tagName === "BR") {
+								text.push(delimiter); 
+							} else {
+								getNodeText(nodeChild);
+							}
+							nodeChild = nodeChild.nextSibling;
+						}
+					};
+					getNodeText(child);
+					cleanup();
+					return text.join("");
+				};
+				
+				/* Try execCommand first. Works on firefox with clipboard permission. */
+				var result = false;
+				this._ignorePaste = true;
+				try {
+					result = document.execCommand("paste", false, null);
+				} catch (ex) {}
+				this._ignorePaste = false;
+				if (!result) {
+					/*
+					* Try native paste in DOM, works for firefox during the paste event.
+					*/
+					if (event) {
+						setTimeout(function() {
+							var text = _getText();
+							if (text) { self._doContent(text); }
+						}, 0);
+						return null;
+					} else {
+						/* no event and no clipboard permission, paste can't be performed */
+						cleanup();
+						return "";
+					}
+				}
+				return _getText();
+			}
+			//webkit
+			if (event && event.clipboardData) {
+				/*
+				* Webkit (Chrome/Safari) allows getData during the paste event
+				* Note: setData is not allowed, not even during copy/cut event
+				*/
+				return event.clipboardData.getData("text/plain");
+			} else {
+				//TODO try paste using extension (Chrome only)
+			}
+			return "";
+		},
+		_getDOMText: function(lineIndex) {
+			var child = this._getLineNode(lineIndex);
+			var lineChild = child.firstChild;
+			var text = "";
+			while (lineChild) {
+				var textNode = lineChild.firstChild;
+				while (textNode) {
+					if (lineChild.ignoreChars) {
+						for (var i = 0; i < textNode.length; i++) {
+							var ch = textNode.data.substring(i, i + 1);
+							if (ch !== " ") {
+								text += ch;
+							}
+						}
+					} else {
+						text += textNode.data;
+					}
+					textNode = textNode.nextSibling;
+				}
+				lineChild = lineChild.nextSibling;
+			}
+			return text;
+		},
+		_getEditorPadding: function() {
+			return this._editorPadding;
+		},
+		_getLineBoundingClientRect: function (child) {
+			var rect = child.getBoundingClientRect();
+			var lastChild = child.lastChild;
+			//Remove any artificial trailing whitespace in the line
+			while (lastChild && lastChild.ignoreChars === lastChild.firstChild.length) {
+				lastChild = lastChild.previousSibling;
+			}
+			if (!lastChild) {
+				return {left: rect.left, top: rect.top, right: rect.left, bottom: rect.bottom};
+			}
+			var lastRect = lastChild.getBoundingClientRect();
+			return {left: rect.left, top: rect.top, right: lastRect.right, bottom: rect.bottom};
+		},
+		_getLineHeight: function() {
+			return this._lineHeight;
+		},
+		_getLineNode: function (lineIndex) {
+			var clientDiv = this._clientDiv;
+			var child = clientDiv.firstChild;
+			while (child) {
+				if (lineIndex === child.lineIndex) {
+					return child;
+				}
+				child = child.nextSibling;
+			}
+			return undefined;
+		},
+		_getLineNext: function (lineNode) {
+			var node = lineNode ? lineNode.nextSibling : this._clientDiv.firstChild;
+			while (node && node.lineIndex === -1) {
+				node = node.nextSibling;
+			}
+			return node;
+		},
+		_getLinePrevious: function (lineNode) {
+			var node = lineNode ? lineNode.previousSibling : this._clientDiv.lastChild;
+			while (node && node.lineIndex === -1) {
+				node = node.previousSibling;
+			}
+			return node;
+		},
+		_getOffset: function (offset, unit, direction) {
+			if (unit === "wordend") {
+				return this._getOffset_W3C(offset, unit, direction);
+			}
+			return isIE ? this._getOffset_IE(offset, unit, direction) : this._getOffset_W3C(offset, unit, direction);
+		},
+		_getOffset_W3C: function (offset, unit, direction) {
+			function _isPunctuation(c) {
+				return (33 <= c && c <= 47) || (58 <= c && c <= 64) || (91 <= c && c <= 94) || c === 96 || (123 <= c && c <= 126);
+			}
+			function _isWhitespace(c) {
+				return c === 32 || c === 9;
+			}
+			if (unit === "word" || unit === "wordend") {
+				var model = this._model;
+				var lineIndex = model.getLineAtOffset(offset);
+				var lineText = model.getLine(lineIndex);
+				var lineStart = model.getLineStart(lineIndex);
+				var lineEnd = model.getLineEnd(lineIndex);
+				var lineLength = lineText.length;
+				var offsetInLine = offset - lineStart;
+				
+				
+				var c, previousPunctuation, previousLetterOrDigit, punctuation, letterOrDigit;
+				if (direction > 0) {
+					if (offsetInLine === lineLength) { return lineEnd; }
+					c = lineText.charCodeAt(offsetInLine);
+					previousPunctuation = _isPunctuation(c); 
+					previousLetterOrDigit = !previousPunctuation && !_isWhitespace(c);
+					offsetInLine++;
+					while (offsetInLine < lineLength) {
+						c = lineText.charCodeAt(offsetInLine);
+						punctuation = _isPunctuation(c);
+						if (unit === "wordend") {
+							if (!punctuation && previousPunctuation) { break; }
+						} else {
+							if (punctuation && !previousPunctuation) { break; }
+						}
+						letterOrDigit  = !punctuation && !_isWhitespace(c);
+						if (unit === "wordend") {
+							if (!letterOrDigit && previousLetterOrDigit) { break; }
+						} else {
+							if (letterOrDigit && !previousLetterOrDigit) { break; }
+						}
+						previousLetterOrDigit = letterOrDigit;
+						previousPunctuation = punctuation;
+						offsetInLine++;
+					}
+				} else {
+					if (offsetInLine === 0) { return lineStart; }
+					offsetInLine--;
+					c = lineText.charCodeAt(offsetInLine);
+					previousPunctuation = _isPunctuation(c); 
+					previousLetterOrDigit = !previousPunctuation && !_isWhitespace(c);
+					while (0 < offsetInLine) {
+						c = lineText.charCodeAt(offsetInLine - 1);
+						punctuation = _isPunctuation(c);
+						if (unit === "wordend") {
+							if (punctuation && !previousPunctuation) { break; }
+						} else {
+							if (!punctuation && previousPunctuation) { break; }
+						}
+						letterOrDigit  = !punctuation && !_isWhitespace(c);
+						if (unit === "wordend") {
+							if (letterOrDigit && !previousLetterOrDigit) { break; }
+						} else {
+							if (!letterOrDigit && previousLetterOrDigit) { break; }
+						}
+						previousLetterOrDigit = letterOrDigit;
+						previousPunctuation = punctuation;
+						offsetInLine--;
+					}
+				}
+				return lineStart + offsetInLine;
+			}
+			return offset + direction;
+		},
+		_getOffset_IE: function (offset, unit, direction) {
+			var document = this._frameDocument;
+			var model = this._model;
+			var lineIndex = model.getLineAtOffset(offset);
+			var clientDiv = this._clientDiv;
+			var dummy;
+			var child = this._getLineNode(lineIndex);
+			if (!child) {
+				child = dummy = this._createLine(clientDiv, null, document, lineIndex, model);
+			}
+			var result = 0, range, length;
+			var lineOffset = model.getLineStart(lineIndex);
+			if (offset === model.getLineEnd(lineIndex)) {
+				range = document.body.createTextRange();
+				range.moveToElementText(child.lastChild);
+				length = range.text.length;
+				range.moveEnd(unit, direction);
+				result = offset + range.text.length - length;
+			} else if (offset === lineOffset && direction < 0) {
+				result = lineOffset;
+			} else {
+				var lineChild = child.firstChild;
+				while (lineChild) {
+					var textNode = lineChild.firstChild;
+					var nodeLength = textNode.length;
+					if (lineChild.ignoreChars) {
+						nodeLength -= lineChild.ignoreChars;
+					}
+					if (lineOffset + nodeLength > offset) {
+						range = document.body.createTextRange();
+						if (offset === lineOffset && direction < 0) {
+							range.moveToElementText(lineChild.previousSibling);
+						} else {
+							range.moveToElementText(lineChild);
+							range.collapse();
+							range.moveEnd("character", offset - lineOffset);
+						}
+						length = range.text.length;
+						range.moveEnd(unit, direction);
+						result = offset + range.text.length - length;
+						break;
+					}
+					lineOffset = nodeLength + lineOffset;
+					lineChild = lineChild.nextSibling;
+				}
+			}
+			if (dummy) { clientDiv.removeChild(dummy); }
+			return result;
+		},
+		_getOffsetToX: function (offset) {
+			return this._getBoundsAtOffset(offset).left;
+		},
+		_getPadding: function (node) {
+			var left,top,right,bottom;
+			if (node.currentStyle) {
+				left = node.currentStyle.paddingLeft;
+				top = node.currentStyle.paddingTop;
+				right = node.currentStyle.paddingRight;
+				bottom = node.currentStyle.paddingBottom;
+			} else if (this._frameWindow.getComputedStyle) {
+				var style = this._frameWindow.getComputedStyle(node, null);
+				left = style.getPropertyValue("padding-left");
+				top = style.getPropertyValue("padding-top");
+				right = style.getPropertyValue("padding-right");
+				bottom = style.getPropertyValue("padding-bottom");
+			}
+			return {
+					left: parseInt(left, 10), 
+					top: parseInt(top, 10),
+					right: parseInt(right, 10),
+					bottom: parseInt(bottom, 10)
+			};
+		},
+		_getScroll: function() {
+			var editorDiv = this._editorDiv;
+			return {x: editorDiv.scrollLeft, y: editorDiv.scrollTop};
+		},
+		_getSelection: function () {
+			return this._selection.clone();
+		},
+		_getTopIndex: function (fullyVisible) {
+			var child = this._topChild;
+			if (fullyVisible && this._getClientHeight() > this._getLineHeight()) {
+				var rect = child.getBoundingClientRect();
+				var editorPad = this._getEditorPadding();
+				var editorRect = this._editorDiv.getBoundingClientRect();
+				if (rect.top < editorRect.top + editorPad.top) {
+					child = this._getLineNext(child) || child;
+				}
+			}
+			return child.lineIndex;
+		},
+		_getXToOffset: function (lineIndex, x) {
+			var model = this._model;
+			var lineStart = model.getLineStart(lineIndex);
+			var lineEnd = model.getLineEnd(lineIndex);
+			if (lineStart === lineEnd) {
+				return lineStart;
+			}
+			var document = this._frameDocument;
+			var clientDiv = this._clientDiv;
+			var dummy;
+			var child = this._getLineNode(lineIndex);
+			if (!child) {
+				child = dummy = this._createLine(clientDiv, null, document, lineIndex, model);
+			}
+			var lineRect = this._getLineBoundingClientRect(child);
+			if (x < lineRect.left) { x = lineRect.left; }
+			if (x > lineRect.right) { x = lineRect.right; }
+			/*
+			* Bug in IE 8 and earlier. The coordinates of getClientRects() are relative to
+			* the browser window.  The fix is to convert to the frame window before using it. 
+			*/
+			var deltaX = 0, rects;
+			if (isIE < 9) {
+				rects = child.getClientRects();
+				var minLeft = rects[0].left;
+				for (var i=1; i<rects.length; i++) {
+					minLeft = Math.min(rects[i].left, minLeft);
+				}
+				deltaX = minLeft - lineRect.left;
+			}
+			var scrollX = this._getScroll().x;
+			function _getClientRects(element) {
+				var rects, newRects, i, r;
+				if (!element._rectsCache) {
+					rects = element.getClientRects();
+					newRects = [rects.length];
+					for (i = 0; i<rects.length; i++) {
+						r = rects[i];
+						newRects[i] = {left: r.left - deltaX + scrollX, top: r.top, right: r.right - deltaX + scrollX, bottom: r.bottom};
+					}
+					element._rectsCache = newRects; 
+				}
+				rects = element._rectsCache;
+				newRects = [rects.length];
+				for (i = 0; i<rects.length; i++) {
+					r = rects[i];
+					newRects[i] = {left: r.left - scrollX, top: r.top, right: r.right - scrollX, bottom: r.bottom};
+				}
+				return newRects;
+			}
+			var logicalXDPI = isIE ? window.screen.logicalXDPI : 1;
+			var deviceXDPI = isIE ? window.screen.deviceXDPI : 1;
+			var offset = lineStart;
+			var lineChild = child.firstChild;
+			done:
+			while (lineChild) {
+				var textNode = lineChild.firstChild;
+				var nodeLength = textNode.length;
+				if (lineChild.ignoreChars) {
+					nodeLength -= lineChild.ignoreChars;
+				}
+				rects = _getClientRects(lineChild);
+				for (var j = 0; j < rects.length; j++) {
+					var rect = rects[j];
+					if (rect.left <= x && x < rect.right) {
+						var range, start, end;
+						if (isIE || isRangeRects) {
+							range = isRangeRects ? document.createRange() : document.body.createTextRange();
+							var high = nodeLength;
+							var low = -1;
+							while ((high - low) > 1) {
+								var mid = Math.floor((high + low) / 2);
+								start = low + 1;
+								end = mid === nodeLength - 1 && lineChild.ignoreChars ? textNode.length : mid + 1;
+								if (isRangeRects) {
+									range.setStart(textNode, start);
+									range.setEnd(textNode, end);
+								} else {
+									range.moveToElementText(lineChild);
+									range.move("character", start);
+									range.moveEnd("character", end - start);
+								}
+								rects = range.getClientRects();
+								var found = false;
+								for (var k = 0; k < rects.length; k++) {
+									rect = rects[k];
+									var rangeLeft = rect.left * logicalXDPI / deviceXDPI - deltaX;
+									var rangeRight = rect.right * logicalXDPI / deviceXDPI - deltaX;
+									if (rangeLeft <= x && x < rangeRight) {
+										found = true;
+										break;
+									}
+								}
+								if (found) {
+									high = mid;
+								} else {
+									low = mid;
+								}
+							}
+							offset += high;
+							start = high;
+							end = high === nodeLength - 1 && lineChild.ignoreChars ? textNode.length : high + 1;
+							if (isRangeRects) {
+								range.setStart(textNode, start);
+								range.setEnd(textNode, end);
+							} else {
+								range.moveToElementText(lineChild);
+								range.move("character", start);
+								range.moveEnd("character", end - start);
+							}
+							rect = range.getClientRects()[0];
+							//TODO test for character trailing (wrong for bidi)
+							if (x > ((rect.left * logicalXDPI / deviceXDPI - deltaX) + ((rect.right - rect.left) * logicalXDPI / deviceXDPI / 2))) {
+								offset++;
+							}
+						} else {
+							var newText = [];
+							for (var q = 0; q < nodeLength; q++) {
+								newText.push("<span>");
+								if (q === nodeLength - 1) {
+									newText.push(textNode.data.substring(q));
+								} else {
+									newText.push(textNode.data.substring(q, q + 1));
+								}
+								newText.push("</span>");
+							}
+							lineChild.innerHTML = newText.join("");
+							var rangeChild = lineChild.firstChild;
+							while (rangeChild) {
+								rect = rangeChild.getBoundingClientRect();
+								if (rect.left <= x && x < rect.right) {
+									//TODO test for character trailing (wrong for bidi)
+									if (x > rect.left + (rect.right - rect.left) / 2) {
+										offset++;
+									}
+									break;
+								}
+								offset++;
+								rangeChild = rangeChild.nextSibling;
+							}
+							if (!dummy) {
+								lineChild.innerHTML = "";
+								lineChild.appendChild(textNode);
+								/*
+								 * Removing the element node that holds the selection start or end
+								 * causes the selection to be lost. The fix is to detect this case
+								 * and restore the selection. 
+								 */
+								var s = this._getSelection();
+								if ((offset <= s.start && s.start < offset + nodeLength) || (offset <= s.end && s.end < offset + nodeLength)) {
+									this._updateDOMSelection();
+								}
+							}
+						}
+						break done;
+					}
+				}
+				offset += nodeLength;
+				lineChild = lineChild.nextSibling;
+			}
+			if (dummy) { clientDiv.removeChild(dummy); }
+			return Math.min(lineEnd, Math.max(lineStart, offset));
+		},
+		_getYToLine: function (y) {
+			var editorPad = this._getEditorPadding();
+			var editorRect = this._editorDiv.getBoundingClientRect();
+			y -= editorRect.top + editorPad.top;
+			var lineHeight = this._getLineHeight();
+			var lineIndex = Math.floor((y + this._getScroll().y) / lineHeight);
+			var lineCount = this._model.getLineCount();
+			return Math.max(0, Math.min(lineCount - 1, lineIndex));
+		},
+		_getOffsetBounds: function(offset) {
+			var model = this._model;
+			var lineIndex = model.getLineAtOffset(offset);
+			var lineHeight = this._getLineHeight();
+			var scroll = this._getScroll();
+			var editorPad = this._getEditorPadding();
+			var editorRect = this._editorDiv.getBoundingClientRect();
+			var bounds = this._getBoundsAtOffset(offset);
+			var left = bounds.left;
+			var right = bounds.right;
+			var top = (lineIndex * lineHeight) - scroll.y + editorRect.top + editorPad.top;
+			var bottom = top + lineHeight;
+			return {left: left, top: top, right: right, bottom: bottom};
+		},
+		_hitOffset: function (offset, x, y) {
+			var bounds = this._getOffsetBounds(offset);
+			var left = bounds.left;
+			var right = bounds.right;
+			var top = bounds.top;
+			var bottom = bounds.bottom;
+			var area = 20;
+			left -= area;
+			top -= area;
+			right += area;
+			bottom += area;
+			return (left <= x && x <= right && top <= y && y <= bottom);
+		},
+		_hookEvents: function() {
+			var self = this;
+			this._modelListener = {
+				/** @private */
+				onChanging: function(newText, start, removedCharCount, addedCharCount, removedLineCount, addedLineCount) {
+					self._onModelChanging(newText, start, removedCharCount, addedCharCount, removedLineCount, addedLineCount);
+				},
+				/** @private */
+				onChanged: function(start, removedCharCount, addedCharCount, removedLineCount, addedLineCount) {
+					self._onModelChanged(start, removedCharCount, addedCharCount, removedLineCount, addedLineCount);
+				}
+			};
+			this._model.addListener(this._modelListener);
+			
+			this._mouseMoveClosure = function(e) { return self._handleMouseMove(e);};
+			this._mouseUpClosure = function(e) { return self._handleMouseUp(e);};
+			
+			var clientDiv = this._clientDiv;
+			var editorDiv = this._editorDiv;
+			var body = this._frameDocument.body; 
+			var handlers = this._handlers = [];
+			var resizeNode = isIE < 9 ? this._frame : this._frameWindow;
+			var focusNode = isPad ? this._textArea : (isIE ||  isFirefox ? this._clientDiv: this._frameWindow);
+			handlers.push({target: resizeNode, type: "resize", handler: function(e) { return self._handleResize(e);}});
+			handlers.push({target: focusNode, type: "blur", handler: function(e) { return self._handleBlur(e);}});
+			handlers.push({target: focusNode, type: "focus", handler: function(e) { return self._handleFocus(e);}});
+			handlers.push({target: editorDiv, type: "scroll", handler: function(e) { return self._handleScroll(e);}});
+			if (isPad) {
+				var touchDiv = this._touchDiv;
+				var textArea = this._textArea;
+				handlers.push({target: textArea, type: "keydown", handler: function(e) { return self._handleKeyDown(e);}});
+				handlers.push({target: textArea, type: "input", handler: function(e) { return self._handleInput(e); }});
+				handlers.push({target: textArea, type: "textInput", handler: function(e) { return self._handleTextInput(e); }});
+				handlers.push({target: touchDiv, type: "touchstart", handler: function(e) { return self._handleTouchStart(e); }});
+				handlers.push({target: touchDiv, type: "touchmove", handler: function(e) { return self._handleTouchMove(e); }});
+				handlers.push({target: touchDiv, type: "touchend", handler: function(e) { return self._handleTouchEnd(e); }});
+			} else {
+				var topNode = this._overlayDiv || this._clientDiv;
+				handlers.push({target: clientDiv, type: "keydown", handler: function(e) { return self._handleKeyDown(e);}});
+				handlers.push({target: clientDiv, type: "keypress", handler: function(e) { return self._handleKeyPress(e);}});
+				handlers.push({target: clientDiv, type: "keyup", handler: function(e) { return self._handleKeyUp(e);}});
+				handlers.push({target: clientDiv, type: "selectstart", handler: function(e) { return self._handleSelectStart(e);}});
+				handlers.push({target: clientDiv, type: "contextmenu", handler: function(e) { return self._handleContextMenu(e);}});
+				handlers.push({target: clientDiv, type: "copy", handler: function(e) { return self._handleCopy(e);}});
+				handlers.push({target: clientDiv, type: "cut", handler: function(e) { return self._handleCut(e);}});
+				handlers.push({target: clientDiv, type: "paste", handler: function(e) { return self._handlePaste(e);}});
+				handlers.push({target: topNode, type: "mousedown", handler: function(e) { return self._handleMouseDown(e);}});
+				handlers.push({target: body, type: "mousedown", handler: function(e) { return self._handleBodyMouseDown(e);}});
+				handlers.push({target: topNode, type: "dragstart", handler: function(e) { return self._handleDragStart(e);}});
+				handlers.push({target: topNode, type: "dragover", handler: function(e) { return self._handleDragOver(e);}});
+				handlers.push({target: topNode, type: "drop", handler: function(e) { return self._handleDrop(e);}});
+				if (isIE) {
+					handlers.push({target: this._frameDocument, type: "activate", handler: function(e) { return self._handleDocFocus(e); }});
+				}
+				if (isFirefox) {
+					handlers.push({target: this._frameDocument, type: "focus", handler: function(e) { return self._handleDocFocus(e); }});
+				}
+				if (!isIE && !isOpera) {
+					var wheelEvent = isFirefox ? "DOMMouseScroll" : "mousewheel";
+					handlers.push({target: this._editorDiv, type: wheelEvent, handler: function(e) { return self._handleMouseWheel(e); }});
+				}
+				if (isFirefox && !isWindows) {
+					handlers.push({target: this._clientDiv, type: "DOMCharacterDataModified", handler: function (e) { return self._handleDataModified(e); }});
+				}
+				if (this._overlayDiv) {
+					handlers.push({target: this._overlayDiv, type: "contextmenu", handler: function(e) { return self._handleContextMenu(e); }});
+				}
+				if (!isW3CEvents) {
+					handlers.push({target: this._clientDiv, type: "dblclick", handler: function(e) { return self._handleDblclick(e); }});
+				}
+
+				handlers.push({target: topNode, type: "contextmenu", handler: function(e) { return self.onContextMenu(e || window.event);}});
+			}
+			for (var i=0; i<handlers.length; i++) {
+				var h = handlers[i];
+				addHandler(h.target, h.type, h.handler, h.capture);
+			}
+		},
+		_init: function(options) {
+			var parent = options.parent;
+			if (typeof(parent) === "string") {
+				parent = window.document.getElementById(parent);
+			}
+			if (!parent) { throw "no parent"; }
+			this._parent = parent;
+			this._model = options.model ? options.model : new eclipse.TextModel();
+			this.readonly = options.readonly === true;
+			this._selection = new Selection (0, 0, false);
+			this._eventTable = new EventTable();
+			this._maxLineWidth = 0;
+			this._maxLineIndex = -1;
+			this._ignoreSelect = true;
+			this._columnX = -1;
+
+			/* Auto scroll */
+			this._autoScrollX = null;
+			this._autoScrollY = null;
+			this._autoScrollTimerID = null;
+			this._AUTO_SCROLL_RATE = 50;
+			this._grabControl = null;
+			this._moseMoveClosure  = null;
+			this._mouseUpClosure = null;
+			
+			/* Double click */
+			this._lastMouseX = 0;
+			this._lastMouseY = 0;
+			this._lastMouseTime = 0;
+			this._clickCount = 0;
+			this._clickTime = 250;
+			this._clickDist = 5;
+			this._isMouseDown = false;
+			this._doubleClickSelection = null;
+			
+			/* Scroll */
+			this._hScroll = 0;
+			this._vScroll = 0;
+
+			/* IME */
+			this._imeOffset = -1;
+			
+			/* Create elements */
+			while (parent.hasChildNodes()) { parent.removeChild(parent.lastChild); }
+			var parentDocument = parent.document || parent.ownerDocument;
+			this._parentDocument = parentDocument;
+			var frame = parentDocument.createElement("IFRAME");
+			this._frame = frame;
+			frame.frameBorder = "0px";//for IE, needs to be set before the frame is added to the parent
+			frame.style.width = "100%";
+			frame.style.height = "100%";
+			frame.scrolling = "no";
+			frame.style.border = "0px";
+			parent.appendChild(frame);
+
+			var html = [];
+			html.push("<!DOCTYPE html>");
+			html.push("<html>");
+			html.push("<head>");
+			if (isIE < 9) {
+				html.push("<meta http-equiv='X-UA-Compatible' content='IE=EmulateIE7'/>");
+			}
+			html.push("<style>");
+			html.push(".editorContainer {font-family: monospace; font-size: 10pt;}");
+			html.push(".editor {padding: 1px 2px;}");
+			html.push(".editorContent {}");
+			html.push("</style>");
+			if (options.stylesheet) {
+				var stylesheet = typeof(options.stylesheet) === "string" ? [options.stylesheet] : options.stylesheet;
+				for (var i = 0; i < stylesheet.length; i++) {
+					try {
+						//Force CSS to be loaded synchronously so lineHeight can be calculated
+						var objXml = new XMLHttpRequest();
+						objXml.open("GET", stylesheet[i], false);
+						objXml.send(null);
+						html.push("<style>");
+						html.push(objXml.responseText);
+						html.push("</style>");
+					} catch (e) {
+						html.push("<link rel='stylesheet' type='text/css' href='");
+						html.push(stylesheet[i]);
+						html.push("'></link>");
+					}
+				}
+			}
+			html.push("</head>");
+			html.push("<body spellcheck='false'></body>");
+			html.push("</html>");
+
+			var frameWindow = frame.contentWindow;
+			this._frameWindow = frameWindow;
+			var document = frameWindow.document;
+			this._frameDocument = document;
+			document.open();
+			document.write(html.join(""));
+			document.close();
+			
+			var body = document.body;
+			body.className = "editorContainer";
+			body.style.margin = "0px";
+			body.style.borderWidth = "0px";
+			body.style.padding = "0px";
+			
+			if (isPad) {
+				var touchDiv = parentDocument.createElement("DIV");
+				this._touchDiv = touchDiv;
+				touchDiv.style.position = "absolute";
+				touchDiv.style.border = "0px";
+				touchDiv.style.padding = "0px";
+				touchDiv.style.margin = "0px";
+				touchDiv.style.zIndex = "2";
+				touchDiv.style.overflow = "hidden";
+				touchDiv.style.background="transparent";
+//				touchDiv.style.background="green";
+//				touchDiv.style.opacity="0.5";
+				touchDiv.style.WebkitUserSelect = "none";
+				parent.appendChild(touchDiv);
+
+				var textArea = parentDocument.createElement("TEXTAREA");
+				this._textArea = textArea;
+				textArea.style.position = "absolute";
+				textArea.style.whiteSpace = "pre";
+				textArea.style.left = "-1000px";
+				textArea.tabIndex = 1;
+				textArea.autocapitalize = false;
+				textArea.autocorrect = false;
+				textArea.className = "editorContainer";
+				textArea.style.background = "transparent";
+				textArea.style.color = "transparent";
+				textArea.style.border = "0px";
+				textArea.style.padding = "0px";
+				textArea.style.margin = "0px";
+				textArea.style.borderRadius = "0px";
+				textArea.style.WebkitAppearance = "none";
+				textArea.style.WebkitTapHighlightColor = "transparent";
+				touchDiv.appendChild(textArea);
+			}
+
+			var editorDiv = document.createElement("DIV");
+			editorDiv.className = "editor";
+			this._editorDiv = editorDiv;
+			editorDiv.id = "editorDiv";
+			editorDiv.tabIndex = -1;
+			editorDiv.style.overflow = "auto";
+			editorDiv.style.position = "absolute";
+			editorDiv.style.top = "0px";
+			editorDiv.style.borderWidth = "0px";
+			editorDiv.style.margin = "0px";
+			editorDiv.style.MozOutline = "none";
+			editorDiv.style.outline = "none";
+			body.appendChild(editorDiv);
+				
+			var scrollDiv = document.createElement("DIV");
+			this._scrollDiv = scrollDiv;
+			scrollDiv.id = "scrollDiv";
+			scrollDiv.style.margin = "0px";
+			scrollDiv.style.borderWidth = "0px";
+			scrollDiv.style.padding = "0px";
+			editorDiv.appendChild(scrollDiv);
+
+			this._fullSelection = options.fullSelection === undefined || options.fullSelection;
+			if (isPad || (this._fullSelection && !isWebkit)) {
+				this._hightlightRGB = "Highlight";
+				var selDiv1 = document.createElement("DIV");
+				this._selDiv1 = selDiv1;
+				selDiv1.id = "selDiv1";
+				selDiv1.style.position = "fixed";
+				selDiv1.style.borderWidth = "0px";
+				selDiv1.style.margin = "0px";
+				selDiv1.style.padding = "0px";
+				selDiv1.style.MozOutline = "none";
+				selDiv1.style.outline = "none";
+				selDiv1.style.background = this._hightlightRGB;
+				selDiv1.style.width="0px";
+				selDiv1.style.height="0px";
+				scrollDiv.appendChild(selDiv1);
+				var selDiv2 = document.createElement("DIV");
+				this._selDiv2 = selDiv2;
+				selDiv2.id = "selDiv2";
+				selDiv2.style.position = "fixed";
+				selDiv2.style.borderWidth = "0px";
+				selDiv2.style.margin = "0px";
+				selDiv2.style.padding = "0px";
+				selDiv2.style.MozOutline = "none";
+				selDiv2.style.outline = "none";
+				selDiv2.style.background = this._hightlightRGB;
+				selDiv2.style.width="0px";
+				selDiv2.style.height="0px";
+				scrollDiv.appendChild(selDiv2);
+				var selDiv3 = document.createElement("DIV");
+				this._selDiv3 = selDiv3;
+				selDiv3.id = "selDiv3";
+				selDiv3.style.position = "fixed";
+				selDiv3.style.borderWidth = "0px";
+				selDiv3.style.margin = "0px";
+				selDiv3.style.padding = "0px";
+				selDiv3.style.MozOutline = "none";
+				selDiv3.style.outline = "none";
+				selDiv3.style.background = this._hightlightRGB;
+				selDiv3.style.width="0px";
+				selDiv3.style.height="0px";
+				scrollDiv.appendChild(selDiv3);
+				
+				/*
+				* Bug in Firefox. The Highlight color is mapped to list selection
+				* background instead of the text selection background.  The fix
+				* is to map known colors using a table or fallback to light blue.
+				*/
+				if (isFirefox && isMac) {
+					var style = frameWindow.getComputedStyle(selDiv3, null);
+					var rgb = style.getPropertyValue("background-color");
+					switch (rgb) {
+						case "rgb(119, 141, 168)": rgb = "rgb(199, 208, 218)"; break;
+						case "rgb(127, 127, 127)": rgb = "rgb(198, 198, 198)"; break;
+						case "rgb(255, 193, 31)": rgb = "rgb(250, 236, 115)"; break;
+						case "rgb(243, 70, 72)": rgb = "rgb(255, 176, 139)"; break;
+						case "rgb(255, 138, 34)": rgb = "rgb(255, 209, 129)"; break;
+						case "rgb(102, 197, 71)": rgb = "rgb(194, 249, 144)"; break;
+						case "rgb(140, 78, 184)": rgb = "rgb(232, 184, 255)"; break;
+						default: rgb = "rgb(180, 213, 255)"; break;
+					}
+					this._hightlightRGB = rgb;
+					selDiv1.style.background = rgb;
+					selDiv2.style.background = rgb;
+					selDiv3.style.background = rgb;
+					var styleSheet = document.styleSheets[0];
+					styleSheet.insertRule("::-moz-selection {background: " + rgb + "; }", 0);
+				}
+			}
+
+			var clientDiv = document.createElement("DIV");
+			clientDiv.className = "editorContent";
+			this._clientDiv = clientDiv;
+			clientDiv.id = "clientDiv";
+			clientDiv.style.whiteSpace = "pre";
+			clientDiv.style.position = "fixed";
+			clientDiv.style.borderWidth = "0px";
+			clientDiv.style.margin = "0px";
+			clientDiv.style.padding = "0px";
+			clientDiv.style.MozOutline = "none";
+			clientDiv.style.outline = "none";
+			if (isPad) {
+				clientDiv.style.WebkitTapHighlightColor = "transparent";
+			}
+			scrollDiv.appendChild(clientDiv);
+
+			if (isFirefox) {
+				var overlayDiv = document.createElement("DIV");
+				this._overlayDiv = overlayDiv;
+				overlayDiv.id = "overlayDiv";
+				overlayDiv.style.position = clientDiv.style.position;
+				overlayDiv.style.borderWidth = clientDiv.style.borderWidth;
+				overlayDiv.style.margin = clientDiv.style.margin;
+				overlayDiv.style.padding = clientDiv.style.padding;
+				overlayDiv.style.cursor = "text";
+				overlayDiv.style.zIndex = "1";
+				scrollDiv.appendChild(overlayDiv);
+			}
+			if (!isPad) {
+				clientDiv.contentEditable = "true";
+			}
+			this._lineHeight = this._calculateLineHeight();
+			this._editorPadding = this._calculatePadding();
+			if (isIE) {
+				body.style.lineHeight = this._lineHeight + "px";
+			}
+			if (options.tabSize) {
+				if (isOpera) {
+					clientDiv.style.OTabSize = options.tabSize+"";
+				} else if (isFirefox >= 4) {
+					clientDiv.style.MozTabSize = options.tabSize+"";
+				} else if (options.tabSize !== 8) {
+					this._tabSize = options.tabSize;
+				}
+			}
+			this._createActions();
+			this._hookEvents();
+		},
+		_modifyContent: function(e, updateCaret) {
+			if (this.readonly && !e._code) {
+				return;
+			}
+
+			this.onVerify(e);
+
+			if (e.text === null || e.text === undefined) { return; }
+			
+			var model = this._model;
+			if (e._ignoreDOMSelection) { this._ignoreDOMSelection = true; }
+			model.setText (e.text, e.start, e.end);
+			if (e._ignoreDOMSelection) { this._ignoreDOMSelection = false; }
+			
+			if (updateCaret) {
+				var selection = this._getSelection ();
+				selection.setCaret(e.start + e.text.length);
+				this._setSelection(selection, true);
+				this._showCaret();
+			}
+			this.onModify({});
+		},
+		_onModelChanged: function(start, removedCharCount, addedCharCount, removedLineCount, addedLineCount) {
+			var e = {
+				start: start,
+				removedCharCount: removedCharCount,
+				addedCharCount: addedCharCount,
+				removedLineCount: removedLineCount,
+				addedLineCount: addedLineCount
+			};
+			this.onModelChanged(e);
+			
+			var selection = this._getSelection();
+			if (selection.end > start) {
+				if (selection.end > start && selection.start < start + removedCharCount) {
+					// selection intersects replaced text. set caret behind text change
+					selection.setCaret(start + addedCharCount);
+				} else {
+					// move selection to keep same text selected
+					selection.start +=  addedCharCount - removedCharCount;
+					selection.end +=  addedCharCount - removedCharCount;
+				}
+				this._setSelection(selection, false, false);
+			}
+			
+			var model = this._model;
+			var startLine = model.getLineAtOffset(start);
+			var child = this._getLineNext();
+			while (child) {
+				var lineIndex = child.lineIndex;
+				if (startLine <= lineIndex && lineIndex <= startLine + removedLineCount) {
+					child.lineChanged = true;
+				}
+				if (lineIndex > startLine + removedLineCount) {
+					child.lineIndex = lineIndex + addedLineCount - removedLineCount;
+				}
+				child = this._getLineNext(child);
+			}
+			if (startLine <= this._maxLineIndex && this._maxLineIndex <= startLine + removedLineCount) {
+				this._maxLineIndex = -1;
+				this._maxLineWidth = 0;
+			}
+			this._updatePage();
+		},
+		_onModelChanging: function(newText, start, removedCharCount, addedCharCount, removedLineCount, addedLineCount) {
+			var e = {
+				text: newText,
+				start: start,
+				removedCharCount: removedCharCount,
+				addedCharCount: addedCharCount,
+				removedLineCount: removedLineCount,
+				addedLineCount: addedLineCount
+			};
+			this.onModelChanging(e);
+		},
+		_queueUpdatePage: function() {
+			if (this._updateTimer) { return; }
+			var self = this;
+			this._updateTimer = setTimeout(function() { 
+				self._updateTimer = null;
+				self._updatePage();
+			}, 0);
+		},
+		_resizeTouchDiv: function() {
+			var editorRect = this._editorDiv.getBoundingClientRect();
+			var parentRect = this._frame.getBoundingClientRect();
+			var temp = this._frame;
+			while (temp) {
+				if (temp.style && temp.style.top) { break; }
+				temp = temp.parentNode;
+			}
+			var parentTop = parentRect.top;
+			if (temp) {
+				parentTop -= temp.getBoundingClientRect().top;
+			} else {
+				parentTop += this._parentDocument.body.scrollTop;
+			}
+			temp = this._frame;
+			while (temp) {
+				if (temp.style && temp.style.left) { break; }
+				temp = temp.parentNode;
+			}
+			var parentLeft = parentRect.left;
+			if (temp) {
+				parentLeft -= temp.getBoundingClientRect().left;
+			} else {
+				parentLeft += this._parentDocument.body.scrollLeft;
+			}
+			var touchDiv = this._touchDiv;
+			touchDiv.style.left = (parentLeft + editorRect.left) + "px";
+			touchDiv.style.top = (parentTop + editorRect.top) + "px";
+			touchDiv.style.width = editorRect.width + "px";
+			touchDiv.style.height = editorRect.height + "px";
+		},
+		_scrollView: function (pixelX, pixelY) {
+			/*
+			* Always set _ensureCaretVisible to false so that the editor does not scroll
+			* to show the caret when scrollView is not called from showCaret().
+			*/
+			this._ensureCaretVisible = false;
+			
+			/*
+			* Scrolling is done only by setting the scrollLeft and scrollTop fields in the
+			* editor div. This causes an updatePage from the scroll event. In some browsers 
+			* this event is asynchromous and forcing update page to run synchronously
+			* (by calling doScroll) leads to redraw problems. On Chrome 11, the editor 
+			* stops redrawing at times when holding PageDown/PageUp key.
+			* On Firefox 4 for Linux, the editor redraws the first page when holding 
+			* PageDown/PageUp key, but it will not redraw again until the key is released.
+			*/
+			var editorDiv = this._editorDiv;
+			if (pixelX) { editorDiv.scrollLeft += pixelX; }
+			if (pixelY) { editorDiv.scrollTop += pixelY; }
+		},
+		_setClipboardText: function (text, event) {
+			if (this._frameWindow.clipboardData) {
+				//IE
+				return this._frameWindow.clipboardData.setData("Text", text);
+			}
+			/* Feature in Chrome, clipboardData.setData is no-op on Chrome even though it returns true */
+			if (isChrome || isFirefox || !event) {
+				var window = this._frameWindow;
+				var document = this._frameDocument;
+				var child = document.createElement("PRE");
+				child.style.position = "fixed";
+				child.style.left = "-1000px";
+				var cr = 0, lf = 0, index = 0, length = text.length;
+				while (index < length) {
+					if (cr !== -1 && cr <= index) { cr = text.indexOf("\r", index); }
+					if (lf !== -1 && lf <= index) { lf = text.indexOf("\n", index); }
+					var start = index, end;
+					if (lf === -1 && cr === -1) {
+						child.appendChild(document.createTextNode(text.substring(index)));
+						break;
+					}
+					if (cr !== -1 && lf !== -1) {
+						if (cr + 1 === lf) {
+							end = cr;
+							index = lf + 1;
+						} else {
+							end = cr < lf ? cr : lf;
+							index = (cr < lf ? cr : lf) + 1;
+						}
+					} else if (cr !== -1) {
+						end = cr;
+						index = cr + 1;
+					} else {
+						end = lf;
+						index = lf + 1;
+					}
+					child.appendChild(document.createTextNode(text.substring(start, end)));
+					child.appendChild(document.createElement("BR"));
+				}
+				child.appendChild(document.createTextNode(" "));
+				this._clientDiv.appendChild(child);
+				var range = document.createRange();
+				range.setStart(child.firstChild, 0);
+				range.setEndBefore(child.lastChild);
+				var sel = window.getSelection();
+				if (sel.rangeCount > 0) { sel.removeAllRanges(); }
+				sel.addRange(range);
+				var self = this;
+				var cleanup = function() {
+					self._clientDiv.removeChild(child);
+					self._updateDOMSelection();
+				};
+				var result = false;
+				/* 
+				* Try execCommand first, it works on firefox with clipboard permission,
+				* chrome 5, safari 4.
+				*/
+				this._ignoreCopy = true;
+				try {
+					result = document.execCommand("copy", false, null);
+				} catch (e) {}
+				this._ignoreCopy = false;
+				if (!result) {
+					if (event) {
+						setTimeout(cleanup, 0);
+						return false;
+					}
+				}
+				/* no event and no permission, copy can not be done */
+				cleanup();
+				return true;
+			}
+			if (event && event.clipboardData) {
+				//webkit
+				return event.clipboardData.setData("text/plain", text); 
+			}
+		},
+		_setDOMSelection: function (startNode, startOffset, endNode, endOffset) {
+			var window = this._frameWindow;
+			var document = this._frameDocument;
+			var startLineNode, startLineOffset, endLineNode, endLineOffset;
+			var offset = 0;
+			var lineChild = startNode.firstChild;
+			var node, nodeLength, model = this._model;
+			var startLineEnd = model.getLine(startNode.lineIndex).length;
+			while (lineChild) {
+				node = lineChild.firstChild;
+				nodeLength = node.length;
+				if (lineChild.ignoreChars) {
+					nodeLength -= lineChild.ignoreChars;
+				}
+				if (offset + nodeLength > startOffset || offset + nodeLength >= startLineEnd) {
+					startLineNode = node;
+					startLineOffset = startOffset - offset;
+					if (lineChild.ignoreChars && nodeLength > 0 && startLineOffset === nodeLength) {
+						startLineOffset += lineChild.ignoreChars; 
+					}
+					break;
+				}
+				offset += nodeLength;
+				lineChild = lineChild.nextSibling;
+			}
+			offset = 0;
+			lineChild = endNode.firstChild;
+			var endLineEnd = this._model.getLine(endNode.lineIndex).length;
+			while (lineChild) {
+				node = lineChild.firstChild;
+				nodeLength = node.length;
+				if (lineChild.ignoreChars) {
+					nodeLength -= lineChild.ignoreChars;
+				}
+				if (nodeLength + offset > endOffset || offset + nodeLength >= endLineEnd) {
+					endLineNode = node;
+					endLineOffset = endOffset - offset;
+					if (lineChild.ignoreChars && nodeLength > 0 && endLineOffset === nodeLength) {
+						endLineOffset += lineChild.ignoreChars; 
+					}
+					break;
+				}
+				offset += nodeLength;
+				lineChild = lineChild.nextSibling;
+			}
+			
+			if (this._selDiv1) {
+				var startLineBounds, l;
+				startLineBounds = this._getLineBoundingClientRect(startNode);
+				if (startOffset === 0) {
+					l = startLineBounds.left;
+				} else {
+					if (startOffset >= startLineEnd) {
+						l = startLineBounds.right;
+					} else {
+						this._ignoreDOMSelection = true;
+						l = this._getBoundsAtOffset(model.getLineStart(startNode.lineIndex) + startOffset).left;
+						this._ignoreDOMSelection = false;
+					}
+				}
+				var textArea = this._textArea;
+				if (textArea) {
+					textArea.selectionStart = textArea.selectionEnd = 0;
+					var rect = this._frame.getBoundingClientRect();
+					var touchRect = this._touchDiv.getBoundingClientRect();
+					var editorBounds = this._editorDiv.getBoundingClientRect();
+					if (!(editorBounds.left <= l && l <= editorBounds.left + editorBounds.width &&
+						editorBounds.top <= startLineBounds.top && startLineBounds.top <= editorBounds.top + editorBounds.height) ||
+						!(startNode === endNode && startOffset === endOffset))
+					{
+						textArea.style.left = "-1000px";
+					} else {
+						textArea.style.left = (l - 4 + rect.left - touchRect.left) + "px";
+					}
+					textArea.style.top = (startLineBounds.top + rect.top - touchRect.top) + "px";
+					textArea.style.width = "6px";
+					textArea.style.height = (startLineBounds.bottom - startLineBounds.top) + "px";
+				}
+			
+				var selDiv = this._selDiv1;
+				selDiv.style.width = "0px";
+				selDiv.style.height = "0px";
+				selDiv = this._selDiv2;
+				selDiv.style.width = "0px";
+				selDiv.style.height = "0px";
+				selDiv = this._selDiv3;
+				selDiv.style.width = "0px";
+				selDiv.style.height = "0px";
+				if (!(startNode === endNode && startOffset === endOffset)) {
+					var handleWidth = isPad ? 2 : 0;
+					var handleBorder = handleWidth + "px blue solid";
+					var editorPad = this._getEditorPadding();
+					var clientRect = this._clientDiv.getBoundingClientRect();
+					var editorRect = this._editorDiv.getBoundingClientRect();
+					var left = editorRect.left + editorPad.left;
+					var right = clientRect.right;
+					var top = editorRect.top + editorPad.top;
+					var bottom = clientRect.bottom;
+					var r;
+					var endLineBounds = this._getLineBoundingClientRect(endNode);
+					if (endOffset === 0) {
+						r = endLineBounds.left;
+					} else {
+						if (endOffset >= endLineEnd) {
+							r = endLineBounds.right;
+						} else {
+							this._ignoreDOMSelection = true;
+							r = this._getBoundsAtOffset(model.getLineStart(endNode.lineIndex) + endOffset).left;
+							this._ignoreDOMSelection = false;
+						}
+					}
+					var sel1Div = this._selDiv1;
+					var sel1Left = Math.min(right, Math.max(left, l));
+					var sel1Top = Math.min(bottom, Math.max(top, startLineBounds.top));
+					var sel1Right = right;
+					var sel1Bottom = Math.min(bottom, Math.max(top, startLineBounds.bottom));
+					sel1Div.style.left = sel1Left + "px";
+					sel1Div.style.top = sel1Top + "px";
+					sel1Div.style.width = Math.max(0, sel1Right - sel1Left) + "px";
+					sel1Div.style.height = Math.max(0, sel1Bottom - sel1Top) + (isPad ? 1 : 0) + "px";
+					if (isPad) {
+						sel1Div.style.borderLeft = handleBorder;
+						sel1Div.style.borderRight = "0px";
+					}
+					if (startNode === endNode) {
+						sel1Right = Math.min(r, right);
+						sel1Div.style.width = Math.max(0, sel1Right - sel1Left - handleWidth * 2) + "px";
+						if (isPad) {
+							sel1Div.style.borderRight = handleBorder;
+						}
+					} else {
+						var sel3Left = left;
+						var sel3Top = Math.min(bottom, Math.max(top, endLineBounds.top));
+						var sel3Right = Math.min(right, Math.max(left, r));
+						var sel3Bottom = Math.min(bottom, Math.max(top, endLineBounds.bottom));
+						var sel3Div = this._selDiv3;
+						sel3Div.style.left = sel3Left + "px";
+						sel3Div.style.top = sel3Top + "px";
+						sel3Div.style.width = Math.max(0, sel3Right - sel3Left - handleWidth) + "px";
+						sel3Div.style.height = Math.max(0, sel3Bottom - sel3Top) + "px";
+						if (isPad) {
+							sel3Div.style.borderRight = handleBorder;
+						}
+						if (sel3Top - sel1Bottom > 0) {
+							var sel2Div = this._selDiv2;
+							sel2Div.style.left = left + "px";
+							sel2Div.style.top = sel1Bottom + "px";
+							sel2Div.style.width = Math.max(0, right - left) + "px";
+							sel2Div.style.height = Math.max(0, sel3Top - sel1Bottom) + (isPad ? 1 : 0) + "px";
+						}
+					}
+				}
+				if (isPad) { return; }
+			}
+			var range;
+			if (window.getSelection) {
+				//W3C
+				range = document.createRange();
+				range.setStart(startLineNode, startLineOffset);
+				range.setEnd(endLineNode, endLineOffset);
+				var sel = window.getSelection();
+				this._ignoreSelect = false;
+				if (sel.rangeCount > 0) { sel.removeAllRanges(); }
+				sel.addRange(range);
+				this._ignoreSelect = true;
+			} else if (document.selection) {
+				//IE < 9
+				var body = document.body;
+
+				/*
+				* Bug in IE. For some reason when text is deselected the overflow
+				* selection at the end of some lines does not get redrawn.  The
+				* fix is to create a DOM element in the body to force a redraw.
+				*/
+				var child = document.createElement("DIV");
+				body.appendChild(child);
+				body.removeChild(child);
+				
+				range = body.createTextRange();
+				range.moveToElementText(startLineNode.parentNode);
+				range.moveStart("character", startLineOffset);
+				var endRange = body.createTextRange();
+				endRange.moveToElementText(endLineNode.parentNode);
+				endRange.moveStart("character", endLineOffset);
+				range.setEndPoint("EndToStart", endRange);
+				this._ignoreSelect = false;
+				range.select();
+				this._ignoreSelect = true;
+			}
+		},
+		_setGrab: function (target) {
+			if (target === this._grabControl) { return; }
+			if (target) {
+				addHandler(target, "mousemove", this._mouseMoveClosure);
+				addHandler(target, "mouseup", this._mouseUpClosure);
+				if (target.setCapture) { target.setCapture(); }
+				this._grabControl = target;
+			} else {
+				removeHandler(this._grabControl, "mousemove", this._mouseMoveClosure);
+				removeHandler(this._grabControl, "mouseup", this._mouseUpClosure);
+				if (this._grabControl.releaseCapture) { this._grabControl.releaseCapture(); }
+				this._grabControl = null;
+			}
+		},
+		_setSelection: function (selection, scroll, update) {
+			if (selection) {
+				this._columnX = -1;
+				if (update === undefined) { update = true; }
+				var oldSelection = this._selection; 
+				if (!oldSelection.equals(selection)) {
+					this._selection = selection;
+					var e = {
+						oldValue: {start:oldSelection.start, end:oldSelection.end},
+						newValue: {start:selection.start, end:selection.end}
+					};
+					this.onSelection(e);
+					if (scroll) { update = !this._showCaret(); }
+				}
+				
+				/* Sometimes the browser changes the selection 
+				 * as result of method calls or "leaked" events. 
+				 * The fix is to set the visual selection even
+				 * when the logical selection is not changed.
+				 */
+				if (update) { this._updateDOMSelection(); }
+			}
+		},
+		_setSelectionTo: function (x,y,extent) {
+			var model = this._model, offset;
+			var selection = this._getSelection();
+			var lineIndex = this._getYToLine(y);
+			if (this._clickCount === 1) {
+				offset = this._getXToOffset(lineIndex, x);
+				selection.extend(offset);
+				if (!extent) { selection.collapse(); }
+			} else {
+				var word = (this._clickCount & 1) === 0;
+				var start, end;
+				if (word) {
+					offset = this._getXToOffset(lineIndex, x);
+					if (this._doubleClickSelection) {
+						if (offset >= this._doubleClickSelection.start) {
+							start = this._doubleClickSelection.start;
+							end = this._getOffset(offset, "wordend", +1);
+						} else {
+							start = this._getOffset(offset, "word", -1);
+							end = this._doubleClickSelection.end;
+						}
+					} else {
+						start = this._getOffset(offset, "word", -1);
+						end = this._getOffset(start, "wordend", +1);
+					}
+				} else {
+					if (this._doubleClickSelection) {
+						var doubleClickLine = model.getLineAtOffset(this._doubleClickSelection.start);
+						if (lineIndex >= doubleClickLine) {
+							start = model.getLineStart(doubleClickLine);
+							end = model.getLineEnd(lineIndex);
+						} else {
+							start = model.getLineStart(lineIndex);
+							end = model.getLineEnd(doubleClickLine);
+						}
+					} else {
+						start = model.getLineStart(lineIndex);
+						end = model.getLineEnd(lineIndex);
+					}
+				}
+				selection.setCaret(start);
+				selection.extend(end);
+			} 
+			this._setSelection(selection, true, true);
+		},
+		_showCaret: function () {
+			var model = this._model;
+			var selection = this._getSelection();
+			var scroll = this._getScroll();
+			var caret = selection.getCaret();
+			var start = selection.start;
+			var end = selection.end;
+			var startLine = model.getLineAtOffset(start); 
+			var endLine = model.getLineAtOffset(end);
+			var endInclusive = Math.max(Math.max(start, model.getLineStart(endLine)), end - 1);
+			var editorPad = this._getEditorPadding();
+			
+			var clientWidth = this._getClientWidth();
+			var leftEdge = editorPad.left;
+			var rightEdge = editorPad.left + clientWidth;
+			var bounds = this._getBoundsAtOffset(caret === start ? start : endInclusive);
+			var left = bounds.left;
+			var right = bounds.right;
+			var minScroll = clientWidth / 4;
+			if (!selection.isEmpty() && startLine === endLine) {
+				bounds = this._getBoundsAtOffset(caret === end ? start : endInclusive);
+				var selectionWidth = caret === start ? bounds.right - left : right - bounds.left;
+				if ((clientWidth - minScroll) > selectionWidth) {
+					if (left > bounds.left) { left = bounds.left; }
+					if (right < bounds.right) { right = bounds.right; }
+				}
+			}
+			var editorRect = this._editorDiv.getBoundingClientRect(); 
+			left -= editorRect.left;
+			right -= editorRect.left;
+			var pixelX = 0;
+			if (left < leftEdge) {
+				pixelX = Math.min(left - leftEdge, -minScroll);
+			}
+			if (right > rightEdge) {
+				var maxScroll = this._scrollDiv.scrollWidth - scroll.x - clientWidth;
+				pixelX = Math.min(maxScroll,  Math.max(right - rightEdge, minScroll));
+			}
+
+			var pixelY = 0;
+			var topIndex = this._getTopIndex(true);
+			var bottomIndex = this._getBottomIndex(true);
+			var caretLine = model.getLineAtOffset(caret);
+			var clientHeight = this._getClientHeight();
+			if (!(topIndex <= caretLine && caretLine <= bottomIndex)) {
+				var lineHeight = this._getLineHeight();
+				var selectionHeight = (endLine - startLine) * lineHeight;
+				pixelY = caretLine * lineHeight;
+				pixelY -= scroll.y;
+				if (pixelY + lineHeight > clientHeight) {
+					pixelY -= clientHeight - lineHeight;
+					if (caret === start && start !== end) {
+						pixelY += Math.min(clientHeight - lineHeight, selectionHeight);
+					}
+				} else {
+					if (caret === end) {
+						pixelY -= Math.min (clientHeight - lineHeight, selectionHeight);
+					}
+				}
+			}
+
+			if (pixelX !== 0 || pixelY !== 0) {
+				this._scrollView (pixelX, pixelY);
+				/*
+				* When the editor scrolls it is possible that one of the scrollbars can show over the caret.
+				* Depending on the browser scrolling can be synchronous (Safari), in which case the change 
+				* can be detected before showCaret() returns. When scrolling is asynchronous (most browsers), 
+				* the detection is done during the next update page.
+				*/
+				if (clientHeight !== this._getClientHeight() || clientWidth !== this._getClientWidth()) {
+					this._showCaret();
+				} else {
+					this._ensureCaretVisible = true;
+				}
+				return true;
+			}
+			return false;
+		},
+		_startIME: function () {
+			if (this._imeOffset !== -1) { return; }
+			var selection = this._getSelection();
+			if (!selection.isEmpty()) {
+				this._modifyContent({text: "", start: selection.start, end: selection.end}, true);
+			}
+			this._imeOffset = selection.start;
+		},
+		_unhookEvents: function() {
+			this._model.removeListener(this._modelListener);
+			this._modelListener = null;
+
+			this._mouseMoveClosure = null;
+			this._mouseUpClosure = null;
+
+			for (var i=0; i<this._handlers.length; i++) {
+				var h = this._handlers[i];
+				removeHandler(h.target, h.type, h.handler);
+			}
+			this._handlers = null;
+		},
+		_updateDOMSelection: function () {
+			if (this._ignoreDOMSelection) { return; }
+			var selection = this._getSelection();
+			var model = this._model;
+			var startLine = model.getLineAtOffset(selection.start);
+			var endLine = model.getLineAtOffset(selection.end);
+			var firstNode = this._getLineNext();
+			/*
+			* Bug in Firefox. For some reason, after a update page sometimes the 
+			* firstChild returns null incorrectly. The fix is to ignore show selection.
+			*/
+			if (!firstNode) { return; }
+			var lastNode = this._getLinePrevious();
+			
+			var topNode, bottomNode, topOffset, bottomOffset;
+			if (startLine < firstNode.lineIndex) {
+				topNode = firstNode;
+				topOffset = 0;
+			} else if (startLine > lastNode.lineIndex) {
+				topNode = lastNode;
+				topOffset = 0;
+			} else {
+				topNode = this._getLineNode(startLine);
+				topOffset = selection.start - model.getLineStart(startLine);
+			}
+
+			if (endLine < firstNode.lineIndex) {
+				bottomNode = firstNode;
+				bottomOffset = 0;
+			} else if (endLine > lastNode.lineIndex) {
+				bottomNode = lastNode;
+				bottomOffset = 0;
+			} else {
+				bottomNode = this._getLineNode(endLine);
+				bottomOffset = selection.end - model.getLineStart(endLine);
+			}
+			this._setDOMSelection(topNode, topOffset, bottomNode, bottomOffset);
+		},
+		_updatePage: function() {
+			if (this._updateTimer) { 
+				clearTimeout(this._updateTimer);
+				this._updateTimer = null;
+			}
+			var document = this._frameDocument;
+			var frameWidth = this._getFrameWidth();
+			var frameHeight = this._getFrameHeight();
+			document.body.style.width = frameWidth + "px";
+			document.body.style.height = frameHeight + "px";
+			
+			var editorDiv = this._editorDiv;
+			var clientDiv = this._clientDiv;
+			var editorPad = this._getEditorPadding();
+			
+			/* Update editor height in order to have client height computed */
+			editorDiv.style.height = Math.max(0, (frameHeight - editorPad.top - editorPad.bottom)) + "px";
+			
+			var model = this._model;
+			var lineHeight = this._getLineHeight();
+			var scrollY = this._getScroll().y;
+			var firstLine = Math.max(0, scrollY) / lineHeight;
+			var topIndex = Math.floor(firstLine);
+			var lineStart = Math.max(0, topIndex - 1);
+			var top = Math.round((firstLine - lineStart) * lineHeight);
+			var lineCount = model.getLineCount();
+			var clientHeight = this._getClientHeight();
+			var partialY = Math.round((firstLine - topIndex) * lineHeight);
+			var linesPerPage = Math.floor((clientHeight + partialY) / lineHeight);
+			var bottomIndex = Math.min(topIndex + linesPerPage, lineCount - 1);
+			var lineEnd = Math.min(bottomIndex + 1, lineCount - 1);
+			this._partialY = partialY;
+			
+			var lineIndex, lineWidth;
+			var child = clientDiv.firstChild;
+			while (child) {
+				lineIndex = child.lineIndex;
+				var nextChild = child.nextSibling;
+				if (!(lineStart <= lineIndex && lineIndex <= lineEnd) || child.lineChanged || child.lineIndex === -1) {
+					if (this._mouseWheelLine === child) {
+						child.style.display = "none";
+						child.lineIndex = -1;
+					} else {
+						clientDiv.removeChild(child);
+					}
+				}
+				child = nextChild;
+			}
+
+			child = this._getLineNext();
+			var frag = document.createDocumentFragment();
+			for (lineIndex=lineStart; lineIndex<=lineEnd; lineIndex++) {
+				if (!child || child.lineIndex > lineIndex) {
+					this._createLine(frag, null, document, lineIndex, model);
+				} else {
+					if (frag.firstChild) {
+						clientDiv.insertBefore(frag, child);
+						frag = document.createDocumentFragment();
+					}
+					child = this._getLineNext(child);
+				}
+			}
+			if (frag.firstChild) { clientDiv.insertBefore(frag, child); }
+
+			/*
+			* Feature in WekKit. Webkit limits the width of the lines
+			* computed below to the width of the client div.  This causes
+			* the lines to be wrapped even though "pre" is set.  The fix
+			* is to set the width of the client div to a larger number
+			* before computing the lines width.  Note that this value is
+			* reset to the appropriate value further down.
+			*/ 
+			if (isWebkit) {
+				clientDiv.style.width = (0x7FFFF).toString() + "px";
+			}
+
+			child = this._getLineNext();
+			while (child) {
+				lineWidth = child.lineWidth;
+				if (lineWidth === undefined) {
+					var rect = this._getLineBoundingClientRect(child);
+					lineWidth = child.lineWidth = rect.right - rect.left;
+				}
+				if (lineWidth >= this._maxLineWidth) {
+					this._maxLineWidth = lineWidth;
+					this._maxLineIndex = child.lineIndex;
+				}
+				if (child.lineIndex === topIndex) { this._topChild = child; }
+				if (child.lineIndex === bottomIndex) { this._bottomChild = child; }
+				child = this._getLineNext(child);
+			}
+
+			// Update rulers
+			this._updateRuler(this._leftDiv, topIndex, bottomIndex);
+			this._updateRuler(this._rightDiv, topIndex, bottomIndex);
+			
+			var leftWidth = this._leftDiv ? this._leftDiv.scrollWidth : 0;
+			var rightWidth = this._rightDiv ? this._rightDiv.scrollWidth : 0;
+			editorDiv.style.left = leftWidth + "px";
+			editorDiv.style.width = Math.max(0, frameWidth - leftWidth - rightWidth - editorPad.left - editorPad.right) + "px";
+			if (this._rightDiv) {
+				this._rightDiv.style.left = (frameWidth - rightWidth) + "px"; 
+			}
+			
+			var scrollDiv = this._scrollDiv;
+			/* Need to set the height first in order for the width to consider the vertical scrollbar */
+			var scrollHeight = lineCount * lineHeight;
+			scrollDiv.style.height = scrollHeight + "px";
+			var clientWidth = this._getClientWidth();
+			var width = Math.max(this._maxLineWidth, clientWidth);
+			/*
+			* Except by IE 8 and earlier, all other browsers are not allocating enough space for the right padding 
+			* in the scrollbar. It is possible this a bug since all other paddings are considered.
+			*/
+			var scrollWidth = width;
+			if (!isIE || isIE >= 9) { width += editorPad.right; }
+			scrollDiv.style.width = width + "px";
+
+//			/*
+//			* Get client height after both scrollbars are visible and updatePage again to recalculate top and bottom indices.
+//			* 
+//			* Note that updateDOMSelection() has to be called on IE before getting the new client height because it
+//			* forces the client area to be recomputed.
+//			*/
+//			if (!isPad) {
+//				this._updateDOMSelection();
+//			}
+			// Get the left scroll after setting the width of the scrollDiv as this can change the horizontal scroll offset.
+			var scroll = this._getScroll();
+			var left = scroll.x;
+			var clipLeft = left;
+			var clipTop = top;
+			var clipRight = left + clientWidth;
+			var clipBottom = top + clientHeight;
+			if (clipLeft === 0) { clipLeft -= editorPad.left; }
+			if (clipTop === 0) { clipTop -= editorPad.top; }
+			if (clipRight === scrollWidth) { clipRight += editorPad.right; }
+			if (scroll.y + clientHeight === scrollHeight) { clipBottom += editorPad.bottom; }
+			clientDiv.style.clip = "rect(" + clipTop + "px," + clipRight + "px," + clipBottom + "px," + clipLeft + "px)";
+			clientDiv.style.left = (-left + leftWidth + editorPad.left) + "px";
+			clientDiv.style.top = (-top + editorPad.top) + "px";
+			clientDiv.style.width = (isWebkit ? scrollWidth : clientWidth + left) + "px";
+			clientDiv.style.height = (clientHeight + top) + "px";
+			var overlayDiv = this._overlayDiv;
+			if (overlayDiv) {
+				overlayDiv.style.clip = clientDiv.style.clip;
+				overlayDiv.style.left = clientDiv.style.left;
+				overlayDiv.style.top = clientDiv.style.top;
+				overlayDiv.style.width = clientDiv.style.width;
+				overlayDiv.style.height = clientDiv.style.height;
+			}
+			function _updateRulerSize(divRuler) {
+				if (!divRuler) { return; }
+				var rulerHeight = clientHeight + editorPad.top + editorPad.bottom;
+				var cells = divRuler.firstChild.rows[0].cells;
+				for (var i = 0; i < cells.length; i++) {
+					var div = cells[i].firstChild;
+					var offset = lineHeight;
+					if (div._ruler.getOverview() === "page") { offset += partialY; }
+					div.style.top = -offset + "px";
+					div.style.height = (rulerHeight + offset) + "px";
+					div = div.nextSibling;
+				}
+				divRuler.style.height = rulerHeight + "px";
+			}
+			_updateRulerSize(this._leftDiv);
+			_updateRulerSize(this._rightDiv);
+			if (isPad) {
+				var self = this;
+				setTimeout(function() {self._resizeTouchDiv();}, 0);
+			}
+			this._updateDOMSelection();
+
+			/*
+			* If the client height changed during the update page it means that scrollbar has either been shown or hidden.
+			* When this happens update page has to run again to ensure that the top and bottom lines div are correct.
+			* 
+			* Note: On IE, updateDOMSelection() has to be called before getting the new client height because it
+			* forces the client area to be recomputed.
+			*/
+			var ensureCaretVisible = this._ensureCaretVisible;
+			this._ensureCaretVisible = false;
+			if (clientHeight !== this._getClientHeight()) {
+				this._updatePage();
+				if (ensureCaretVisible) {
+					this._showCaret();
+				}
+			}
+		},
+		_updateRuler: function (divRuler, topIndex, bottomIndex) {
+			if (!divRuler) { return; }
+			var cells = divRuler.firstChild.rows[0].cells;
+			var lineHeight = this._getLineHeight();
+			var parentDocument = this._frameDocument;
+			var editorPad = this._getEditorPadding();
+			for (var i = 0; i < cells.length; i++) {
+				var div = cells[i].firstChild;
+				var ruler = div._ruler, style;
+				if (div.rulerChanged) {
+					this._applyStyle(ruler.getStyle(), div);
+				}
+				
+				var widthDiv;
+				var child = div.firstChild;
+				if (child) {
+					widthDiv = child;
+					child = child.nextSibling;
+				} else {
+					widthDiv = parentDocument.createElement("DIV");
+					widthDiv.style.visibility = "hidden";
+					div.appendChild(widthDiv);
+				}
+				var lineIndex;
+				if (div.rulerChanged) {
+					if (widthDiv) {
+						lineIndex = -1;
+						this._applyStyle(ruler.getStyle(lineIndex), widthDiv);
+						widthDiv.innerHTML = ruler.getHTML(lineIndex);
+						widthDiv.lineIndex = lineIndex;
+						widthDiv.style.height = (lineHeight + editorPad.top) + "px";
+					}
+				}
+
+				var overview = ruler.getOverview(), lineDiv, frag;
+				if (overview === "page") {
+					while (child) {
+						lineIndex = child.lineIndex;
+						var nextChild = child.nextSibling;
+						if (!(topIndex <= lineIndex && lineIndex <= bottomIndex) || child.lineChanged) {
+							div.removeChild(child);
+						}
+						child = nextChild;
+					}
+					child = div.firstChild.nextSibling;
+					frag = document.createDocumentFragment();
+					for (lineIndex=topIndex; lineIndex<=bottomIndex; lineIndex++) {
+						if (!child || child.lineIndex > lineIndex) {
+							lineDiv = parentDocument.createElement("DIV");
+							this._applyStyle(ruler.getStyle(lineIndex), lineDiv);
+							lineDiv.innerHTML = ruler.getHTML(lineIndex);
+							lineDiv.lineIndex = lineIndex;
+							lineDiv.style.height = lineHeight + "px";
+							frag.appendChild(lineDiv);
+						} else {
+							if (frag.firstChild) {
+								div.insertBefore(frag, child);
+								frag = document.createDocumentFragment();
+							}
+							if (child) {
+								child = child.nextSibling;
+							}
+						}
+					}
+					if (frag.firstChild) { div.insertBefore(frag, child); }
+				} else {
+					var buttonHeight = 17;
+					var clientHeight = this._getClientHeight ();
+					var trackHeight = clientHeight + editorPad.top + editorPad.bottom - 2 * buttonHeight;
+					var lineCount = this._model.getLineCount ();
+					var divHeight = trackHeight / lineCount;
+					if (div.rulerChanged) {
+						var count = div.childNodes.length;
+						while (count > 1) {
+							div.removeChild(div.lastChild);
+							count--;
+						}
+						var lines = ruler.getAnnotations ();
+						frag = document.createDocumentFragment();
+						for (var j = 0; j < lines.length; j++) {
+							lineIndex = lines[j];
+							lineDiv = parentDocument.createElement("DIV");
+							this._applyStyle(ruler.getStyle(lineIndex), lineDiv);
+							lineDiv.style.position = "absolute";
+							lineDiv.style.top = buttonHeight + lineHeight + Math.floor(lineIndex * divHeight) + "px";
+							lineDiv.innerHTML = ruler.getHTML(lineIndex);
+							lineDiv.lineIndex = lineIndex;
+							frag.appendChild(lineDiv);
+						}
+						div.appendChild(frag);
+					} else if (div._oldTrackHeight !== trackHeight) {
+						lineDiv = div.firstChild ? div.firstChild.nextSibling : null;
+						while (lineDiv) {
+							lineDiv.style.top = buttonHeight + lineHeight + Math.floor(lineDiv.lineIndex * divHeight) + "px";
+							lineDiv = lineDiv.nextSibling;
+						}
+					}
+					div._oldTrackHeight = trackHeight;
+				}
+				div.rulerChanged = false;
+				div = div.nextSibling;
+			}
+		}
+	};//end prototype
+	
+	return Editor;
+}());
+/*******************************************************************************
+ * Copyright (c) 2010, 2011 IBM Corporation and others.
+ * All rights reserved. This program and the accompanying materials are made 
+ * available under the terms of the Eclipse Public License v1.0 
+ * (http://www.eclipse.org/legal/epl-v10.html), and the Eclipse Distribution 
+ * License v1.0 (http://www.eclipse.org/org/documents/edl-v10.html). 
+ * 
+ * Contributors: 
+ *		Felipe Heidrich (IBM Corporation) - initial API and implementation
+ *		Silenio Quarti (IBM Corporation) - initial API and implementation
+ ******************************************************************************/
+ 
+/*global navigator */
+
+/**
+ * @namespace The global container for eclipse APIs.
+ */ 
+var eclipse = eclipse || {};
+
+/**
+ * Constructs a new TextModel with the given text and default line delimiter.
+ *
+ * @param {String} [text=""] the text that the model will store
+ * @param {String} [lineDelimiter=platform delimiter] the line delimiter used when inserting new lines to the model.
+ *
+ * @name eclipse.TextModel
+ * @class The TextModel is an interface that provides text for the editor. Applications may
+ * implement the TextModel interface to provide a custom store for the editor content. The
+ * editor interacts with its text model in order to access and update the text that is being
+ * displayed and edited in the editor. This is the default implementation.
+ * <p>
+ * <b>See:</b><br/>
+ * {@link eclipse.Editor}<br/>
+ * {@link eclipse.Editor#setModel}
+ * </p>
+ */
+eclipse.TextModel = (function() {
+	var isWindows = navigator.platform.indexOf("Win") !== -1;
+
+	/** @private */
+	function TextModel(text, lineDelimiter) {
+		this._listeners = [];
+		this._lineDelimiter = lineDelimiter ? lineDelimiter : (isWindows ? "\r\n" : "\n"); 
+		this._lastLineIndex = -1;
+		this._text = [""];
+		this._lineOffsets = [0];
+		this.setText(text);
+	}
+
+	TextModel.prototype = /** @lends eclipse.TextModel.prototype */ {
+		/**
+		 * Adds a listener to the model.
+		 * 
+		 * @param {Object} listener the listener to add.
+		 * @param {Function} [listener.onChanged] see {@link #onChanged}.
+		 * @param {Function} [listener.onChanging] see {@link #onChanging}.
+		 * 
+		 * @see removeListener
+		 */
+		addListener: function(listener) {
+			this._listeners.push(listener);
+		},
+		/**
+		 * Removes a listener from the model.
+		 * 
+		 * @param {Object} listener the listener to remove
+		 * 
+		 * @see #addListener
+		 */
+		removeListener: function(listener) {
+			for (var i = 0; i < this._listeners.length; i++) {
+				if (this._listeners[i] === listener) {
+					this._listeners.splice(i, 1);
+					return;
+				}
+			}
+		},
+		/**
+		 * Returns the number of characters in the model.
+		 *
+		 * @returns {Number} the number of characters in the model.
+		 */
+		getCharCount: function() {
+			var count = 0;
+			for (var i = 0; i<this._text.length; i++) {
+				count += this._text[i].length;
+			}
+			return count;
+		},
+		/**
+		 * Returns the text of the line at the given index.
+		 * <p>
+		 * The valid indices are 0 to line count exclusive.  Returns <code>null</code> 
+		 * if the index is out of range. 
+		 * </p>
+		 *
+		 * @param {Number} lineIndex the zero based index of the line.
+		 * @param {Boolean} [includeDelimiter=false] whether or not to include the line delimiter. 
+		 * @returns {String} the line text or <code>null</code> if out of range.
+		 *
+		 * @see #getLineAtOffset
+		 */
+		getLine: function(lineIndex, includeDelimiter) {
+			var lineCount = this.getLineCount();
+			if (!(0 <= lineIndex && lineIndex < lineCount)) {
+				return null;
+			}
+			var start = this._lineOffsets[lineIndex];
+			if (lineIndex + 1 < lineCount) {
+				var text = this.getText(start, this._lineOffsets[lineIndex + 1]);
+				if (includeDelimiter) {
+					return text;
+				}
+				var end = text.length, c;
+				while (((c = text.charCodeAt(end - 1)) === 10) || (c === 13)) {
+					end--;
+				}
+				return text.substring(0, end);
+			} else {
+				return this.getText(start); 
+			}
+		},
+		/**
+		 * Returns the line index at the given character offset.
+		 * <p>
+		 * The valid offsets are 0 to char count inclusive. The line index for
+		 * char count is <code>line count - 1</code>. Returns <code>-1</code> if
+		 * the offset is out of range.
+		 * </p>
+		 *
+		 * @param {Number} offset a character offset.
+		 * @returns {Number} the zero based line index or <code>-1</code> if out of range.
+		 */
+		getLineAtOffset: function(offset) {
+			if (!(0 <= offset && offset <= this.getCharCount())) {
+				return -1;
+			}
+			var lineCount = this.getLineCount();
+			var charCount = this.getCharCount();
+			if (offset === charCount) {
+				return lineCount - 1; 
+			}
+			var lineStart, lineEnd;
+			var index = this._lastLineIndex;
+			if (0 <= index && index < lineCount) {
+				lineStart = this._lineOffsets[index];
+				lineEnd = index + 1 < lineCount ? this._lineOffsets[index + 1] : charCount;
+				if (lineStart <= offset && offset < lineEnd) {
+					return index;
+				}
+			}
+			var high = lineCount;
+			var low = -1;
+			while (high - low > 1) {
+				index = Math.floor((high + low) / 2);
+				lineStart = this._lineOffsets[index];
+				lineEnd = index + 1 < lineCount ? this._lineOffsets[index + 1] : charCount;
+				if (offset <= lineStart) {
+					high = index;
+				} else if (offset < lineEnd) {
+					high = index;
+					break;
+				} else {
+					low = index;
+				}
+			}
+			this._lastLineIndex = high;
+			return high;
+		},
+		/**
+		 * Returns the number of lines in the model.
+		 * <p>
+		 * The model always has at least one line.
+		 * </p>
+		 *
+		 * @returns {Number} the number of lines.
+		 */
+		getLineCount: function() {
+			return this._lineOffsets.length;
+		},
+		/**
+		 * Returns the line delimiter that is used by the editor
+		 * when inserting new lines. New lines entered using key strokes 
+		 * and paste operations use this line delimiter.
+		 *
+		 * @return {String} the line delimiter that is used by the editor when inserting new lines.
+		 */
+		getLineDelimiter: function() {
+			return this._lineDelimiter;
+		},
+		/**
+		 * Returns the end character offset for the given line. 
+		 * <p>
+		 * The end offset is not inclusive. This means that when the line delimiter is included, the 
+		 * offset is either the start offset of the next line or char count. When the line delimiter is
+		 * not included, the offset is the offset of the line delimiter.
+		 * </p>
+		 * <p>
+		 * The valid indices are 0 to line count exclusive.  Returns <code>-1</code> 
+		 * if the index is out of range. 
+		 * </p>
+		 *
+		 * @param {Number} lineIndex the zero based index of the line.
+		 * @param {Boolean} [includeDelimiter=false] whether or not to include the line delimiter. 
+		 * @return {Number} the line end offset or <code>-1</code> if out of range.
+		 *
+		 * @see #getLineStart
+		 */
+		getLineEnd: function(lineIndex, includeDelimiter) {
+			var lineCount = this.getLineCount();
+			if (!(0 <= lineIndex && lineIndex < lineCount)) {
+				return -1;
+			}
+			if (lineIndex + 1 < lineCount) {
+				var end = this._lineOffsets[lineIndex + 1];
+				if (includeDelimiter) {
+					return end;
+				}
+				var text = this.getText(Math.max(this._lineOffsets[lineIndex], end - 2), end);
+				var i = text.length, c;
+				while (((c = text.charCodeAt(i - 1)) === 10) || (c === 13)) {
+					i--;
+				}
+				return end - (text.length - i);
+			} else {
+				return this.getCharCount();
+			}
+		},
+		/**
+		 * Returns the start character offset for the given line.
+		 * <p>
+		 * The valid indices are 0 to line count exclusive.  Returns <code>-1</code> 
+		 * if the index is out of range. 
+		 * </p>
+		 *
+		 * @param {Number} lineIndex the zero based index of the line.
+		 * @return {Number} the line start offset or <code>-1</code> if out of range.
+		 *
+		 * @see #getLineEnd
+		 */
+		getLineStart: function(lineIndex) {
+			if (!(0 <= lineIndex && lineIndex < this.getLineCount())) {
+				return -1;
+			}
+			return this._lineOffsets[lineIndex];
+		},
+		/**
+		 * Returns the text for the given range.
+		 * <p>
+		 * The end offset is not inclusive. This means that character at the end offset
+		 * is not included in the returned text.
+		 * </p>
+		 *
+		 * @param {Number} [start=0] the zero based start offset of text range.
+		 * @param {Number} [end=char count] the zero based end offset of text range.
+		 *
+		 * @see #setText
+		 */
+		getText: function(start, end) {
+			if (start === undefined) { start = 0; }
+			if (end === undefined) { end = this.getCharCount(); }
+			var offset = 0, chunk = 0, length;
+			while (chunk<this._text.length) {
+				length = this._text[chunk].length; 
+				if (start <= offset + length) { break; }
+				offset += length;
+				chunk++;
+			}
+			var firstOffset = offset;
+			var firstChunk = chunk;
+			while (chunk<this._text.length) {
+				length = this._text[chunk].length; 
+				if (end <= offset + length) { break; }
+				offset += length;
+				chunk++;
+			}
+			var lastOffset = offset;
+			var lastChunk = chunk;
+			if (firstChunk === lastChunk) {
+				return this._text[firstChunk].substring(start - firstOffset, end - lastOffset);
+			}
+			var beforeText = this._text[firstChunk].substring(start - firstOffset);
+			var afterText = this._text[lastChunk].substring(0, end - lastOffset);
+			return beforeText + this._text.slice(firstChunk+1, lastChunk).join("") + afterText; 
+		},
+		/**
+		 * Notifies all listeners that the text is about to change.
+		 * <p>
+		 * This notification is intended to be used only by the editor. Application clients should
+		 * use {@link eclipse.Editor#event:onModelChanging}.
+		 * </p>
+		 * <p>
+		 * NOTE: This method is not meant to called directly by application code. It is called internally by the TextModel
+		 * as part of the implementation of {@link #setText}. This method is included in the public API for documentation
+		 * purposes and to allow integration with other toolkit frameworks.
+		 * </p>
+		 *
+		 * @param {String} text the text that is about to be inserted in the model.
+		 * @param {Number} start the character offset in the model where the change will occur.
+		 * @param {Number} removedCharCount the number of characters being removed from the model.
+		 * @param {Number} addedCharCount the number of characters being added to the model.
+		 * @param {Number} removedLineCount the number of lines being removed from the model.
+		 * @param {Number} addedLineCount the number of lines being added to the model.
+		 */
+		onChanging: function(text, start, removedCharCount, addedCharCount, removedLineCount, addedLineCount) {
+			for (var i = 0; i < this._listeners.length; i++) {
+				var l = this._listeners[i]; 
+				if (l && l.onChanging) { 
+					l.onChanging(text, start, removedCharCount, addedCharCount, removedLineCount, addedLineCount);
+				}
+			}
+		},
+		/**
+		 * Notifies all listeners that the text has changed.
+		 * <p>
+		 * This notification is intended to be used only by the editor. Application clients should
+		 * use {@link eclipse.Editor#event:onModelChanged}.
+		 * </p>
+		 * <p>
+		 * NOTE: This method is not meant to called directly by application code. It is called internally by the TextModel
+		 * as part of the implementation of {@link #setText}. This method is included in the public API for documentation
+		 * purposes and to allow integration with other toolkit frameworks.
+		 * </p>
+		 *
+		 * @param {Number} start the character offset in the model where the change occurred.
+		 * @param {Number} removedCharCount the number of characters removed from the model.
+		 * @param {Number} addedCharCount the number of characters added to the model.
+		 * @param {Number} removedLineCount the number of lines removed from the model.
+		 * @param {Number} addedLineCount the number of lines added to the model.
+		 */
+		onChanged: function(start, removedCharCount, addedCharCount, removedLineCount, addedLineCount) {
+			for (var i = 0; i < this._listeners.length; i++) {
+				var l = this._listeners[i]; 
+				if (l && l.onChanged) { 
+					l.onChanged(start, removedCharCount, addedCharCount, removedLineCount, addedLineCount);
+				}
+			}
+		},
+		/**
+		 * Replaces the text in the given range with the given text.
+		 * <p>
+		 * The end offset is not inclusive. This means that the character at the 
+		 * end offset is not replaced.
+		 * </p>
+		 * <p>
+		 * The text model must notify the listeners before and after the
+		 * the text is changed by calling {@link #onChanging} and {@link #onChanged}
+		 * respectively. 
+		 * </p>
+		 *
+		 * @param {String} [text=""] the new text.
+		 * @param {Number} [start=0] the zero based start offset of text range.
+		 * @param {Number} [end=char count] the zero based end offset of text range.
+		 *
+		 * @see #getText
+		 */
+		setText: function(text, start, end) {
+			if (text === undefined) { text = ""; }
+			if (start === undefined) { start = 0; }
+			if (end === undefined) { end = this.getCharCount(); }
+			var startLine = this.getLineAtOffset(start);
+			var endLine = this.getLineAtOffset(end);
+			var eventStart = start;
+			var removedCharCount = end - start;
+			var removedLineCount = endLine - startLine;
+			var addedCharCount = text.length;
+			var addedLineCount = 0;
+			var lineCount = this.getLineCount();
+			
+			var cr = 0, lf = 0, index = 0;
+			var newLineOffsets = [];
+			while (true) {
+				if (cr !== -1 && cr <= index) { cr = text.indexOf("\r", index); }
+				if (lf !== -1 && lf <= index) { lf = text.indexOf("\n", index); }
+				if (lf === -1 && cr === -1) { break; }
+				if (cr !== -1 && lf !== -1) {
+					if (cr + 1 === lf) {
+						index = lf + 1;
+					} else {
+						index = (cr < lf ? cr : lf) + 1;
+					}
+				} else if (cr !== -1) {
+					index = cr + 1;
+				} else {
+					index = lf + 1;
+				}
+				newLineOffsets.push(start + index);
+				addedLineCount++;
+			}
+		
+			this.onChanging(text, eventStart, removedCharCount, addedCharCount, removedLineCount, addedLineCount);
+			
+			//TODO this should be done the loops below to avoid getText()
+			if (newLineOffsets.length === 0) {
+				var startLineOffset = this.getLineStart(startLine), endLineOffset;
+				if (endLine + 1 < lineCount) {
+					endLineOffset = this.getLineStart(endLine + 1);
+				} else {
+					endLineOffset = this.getCharCount();
+				}
+				if (start !== startLineOffset) {
+					text = this.getText(startLineOffset, start) + text;
+					start = startLineOffset;
+				}
+				if (end !== endLineOffset) {
+					text = text + this.getText(end, endLineOffset);
+					end = endLineOffset;
+				}
+			}
+			
+			var changeCount = addedCharCount - removedCharCount;
+			for (var j = startLine + removedLineCount + 1; j < lineCount; j++) {
+				this._lineOffsets[j] += changeCount;
+			}
+			var args = [startLine + 1, removedLineCount].concat(newLineOffsets);
+			Array.prototype.splice.apply(this._lineOffsets, args);
+			
+			var offset = 0, chunk = 0, length;
+			while (chunk<this._text.length) {
+				length = this._text[chunk].length; 
+				if (start <= offset + length) { break; }
+				offset += length;
+				chunk++;
+			}
+			var firstOffset = offset;
+			var firstChunk = chunk;
+			while (chunk<this._text.length) {
+				length = this._text[chunk].length; 
+				if (end <= offset + length) { break; }
+				offset += length;
+				chunk++;
+			}
+			var lastOffset = offset;
+			var lastChunk = chunk;
+			var firstText = this._text[firstChunk];
+			var lastText = this._text[lastChunk];
+			var beforeText = firstText.substring(0, start - firstOffset);
+			var afterText = lastText.substring(end - lastOffset);
+			var params = [firstChunk, lastChunk - firstChunk + 1];
+			if (beforeText) { params.push(beforeText); }
+			if (text) { params.push(text); }
+			if (afterText) { params.push(afterText); }
+			Array.prototype.splice.apply(this._text, params);
+			if (this._text.length === 0) { this._text = [""]; }
+			
+			this.onChanged(eventStart, removedCharCount, addedCharCount, removedLineCount, addedLineCount);
+		}
+	};
+	
+	return TextModel;
+}()); 
\ No newline at end of file
diff --git a/browser/base/content/orion/orion.min.js b/browser/base/content/orion/orion.min.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/orion/orion.min.js
@@ -0,0 +1,1 @@
+var eclipse=eclipse||{};eclipse.TextStyler=function(){function v(d,e){this.commentStart="/*",this.commentEnd="*/";var f=[];switch(e){case"java":f=b;break;case"js":f=a;break;case"css":f=c}this.whitespacesVisible=!1,this.highlightCaretLine=!0,this._scanner=new t(f,this.whitespacesVisible),e==="css"&&(this._scanner.isCSS=!0),this._whitespaceScanner=new u,this.editor=d,this.commentOffset=0,this.commentOffsets=[],this._currentBracket=undefined,this._matchingBracket=undefined,d.addEventListener("Selection",this,this._onSelection),d.addEventListener("ModelChanged",this,this._onModelChanged),d.addEventListener("Destroy",this,this._onDestroy),d.addEventListener("LineStyle",this,this._onLineStyle),d.redrawLines()}var a=["break","continue","do","for","new","this","case","default","else","function","in","return","typeof","while","comment","delete","export","if","switch","var","with","abstract","implements","protected","public","interface","static","synchronized","false","throws","final","null","transient","package","true","goto","private","catch","enum","throw","class","extends","try","const","finally","debugger","super","undefined"],b=["abstract","boolean","break","byte","case","catch","char","class","continue","default","do","double","else","extends","false","final","finally","float","for","if","implements","import","instanceof","int","interface","long","native","new","null","package","private","protected","public","return","short","static","super","switch","synchronized","this","throw","throws","transient","true","try","void","volatile","while"],c=["color","text-align","text-indent","text-decoration","font","font-style","font-family","font-weight","font-size","font-variant","line-height","background","background-color","background-image","background-position","background-repeat","background-attachment","list-style","list-style-image","list-style-position","list-style-type","outline","outline-color","outline-style","outline-width","border","border-left","border-top","border-bottom","border-right","border-color","border-width","border-style","border-bottom-color","border-bottom-style","border-bottom-width","border-left-color","border-left-style","border-left-width","border-top-color","border-top-style","border-top-width","border-right-color","border-right-style","border-right-width","padding","padding-left","padding-top","padding-bottom","padding-right","margin","margin-left","margin-top","margin-bottom","margin-right","width","height","left","top","right","bottom","min-width","max-width","min-height","max-height","display","visibility","clip","cursor","overflow","overflow-x","overflow-y","position","z-index","vertical-align","horizontal-align","float","clear"],d=1,e=2,f=3,g=4,h=5,i=6,j=7,k=document.selection&&window.ActiveXObject&&/MSIE/.test(navigator.userAgent)?document.documentMode:undefined,l={styleClass:"token_comment"},m={styleClass:"token_javadoc"},n={styleClass:"token_string"},o={styleClass:"token_keyword"},p={styleClass:"token_space"},q={styleClass:"token_tab"},r={styleClass:k<9?"token_bracket":"token_bracket_outline"},s={styleClass:"line_caret"},t=function(){function a(a,b){this.keywords=a,this.whitespacesVisible=b,this.setText("")}a.prototype={getOffset:function(){return this.offset},getStartOffset:function(){return this.startOffset},getData:function(){return this.text.substring(this.startOffset,this.offset)},getDataLength:function(){return this.offset-this.startOffset},_read:function(){if(this.offset<this.text.length)return this.text.charCodeAt(this.offset++);return-1},_unread:function(a){a!==-1&&this.offset--},nextToken:function(){this.startOffset=this.offset;for(;;){var a=this._read();switch(a){case-1:return null;case 47:a=this._read();if(a===47)for(;;){a=this._read();if(a===-1||a===10){this._unread(a);return g}}this._unread(a);return d;case 39:for(;;){a=this._read();switch(a){case 39:return f;case-1:this._unread(a);return f;case 92:a=this._read()}}break;case 34:for(;;){a=this._read();switch(a){case 34:return f;case-1:this._unread(a);return f;case 92:a=this._read()}}break;case 32:case 9:if(this.whitespacesVisible)return a===32?j:i;do a=this._read();while(a===32||a===9);this._unread(a);return h;default:var b=this.isCSS;if(97<=a&&a<=122||65<=a&&a<=90||a===95||48<=a&&a<=57||45===a&&b){var c=this.offset-1;do a=this._read();while(97<=a&&a<=122||65<=a&&a<=90||a===95||48<=a&&a<=57||45===a&&b);this._unread(a);var k=this.text.substring(c,this.offset);for(var l=0;l<this.keywords.length;l++)if(this.keywords[l]===k)return e}return d}}},setText:function(a){this.text=a,this.offset=0,this.startOffset=0}};return a}(),u=function(){function a(){t.call(this,null,!0)}a.prototype=new t(null),a.prototype.nextToken=function(){this.startOffset=this.offset;for(;;){var a=this._read();switch(a){case-1:return null;case 32:return j;case 9:return i;default:do a=this._read();while(a!==32&&a!==9&&a!==-1);this._unread(a);return d}}};return a}();v.prototype={destroy:function(){var a=this.editor;a&&(a.removeEventListener("Selection",this,this._onSelection),a.removeEventListener("ModelChanged",this,this._onModelChanged),a.removeEventListener("Destroy",this,this._onDestroy),a.removeEventListener("LineStyle",this,this._onLineStyle),this.editor=null)},setHighlightCaretLine:function(a){this.highlightCaretLine=a},setWhitespacesVisible:function(a){this.whitespacesVisible=a,this._scanner.whitespacesVisible=a},_binarySearch:function(a,b,c,d){while(d-c>2){var e=d+c>>1>>1<<1,f=a[e+1];f>b?d=e:c=e}return d},_computeComments:function(a){if(!(a<=this.commentOffset)){var b=this.editor.getModel(),c=b.getCharCount(),d=a,e=b.getText(this.commentOffset,d);this.commentOffsets.length>1&&this.commentOffsets[this.commentOffsets.length-1]===c&&this.commentOffsets.length--;var f=0;while(f<e.length){var g=(this.commentOffsets.length&1)===0,h=g?this.commentStart:this.commentEnd,i=e.indexOf(h,f);if(i!==-1)this.commentOffsets.push(this.commentOffset+(g?i:i+h.length));else break;f=i+h.length}(this.commentOffsets.length&1)===1&&this.commentOffsets.push(c),this.commentOffset=d}},_getCommentRanges:function(a,b){this._computeComments(b);var c=this.commentOffsets.length,d=this._binarySearch(this.commentOffsets,a,-1,c);if(d>=c)return[];if(this.commentOffsets[d]>b)return[];var e=Math.min(c-2,this._binarySearch(this.commentOffsets,b,d-1,c));this.commentOffsets[e]>b&&(e=Math.max(d,e-2));return this.commentOffsets.slice(d,e+2)},_getLineStyle:function(a){if(this.highlightCaretLine){var b=this.editor,c=this.editor.getModel(),d=b.getSelection();if(d.start===d.end&&c.getLineAtOffset(d.start)===a)return s}return null},_getStyles:function(a,b){var c=b+a.length,d=this.editor.getModel(),e=this._getCommentRanges(b,c),f=[],g=b;for(var h=0;h<e.length;h+=2){var i=e[h];g<i&&this._parse(a.substring(g-b,i-b),g,f);var j=l;if(e[h+1]-i>this.commentStart.length+this.commentEnd.length){var k=i+this.commentStart.length;d.getText(k,k+1)==="*"&&(j=m)}if(this.whitespacesVisible){var n=Math.max(g,i),o=Math.min(c,e[h+1]);this._parseWhitespace(a.substring(n-b,o-b),n,f,j)}else f.push({start:e[h],end:e[h+1],style:j});g=e[h+1]}g<c&&this._parse(a.substring(g-b,c-b),g,f);return f},_parse:function(a,b,c){var d=this._scanner;d.setText(a);var h;while(h=d.nextToken()){var k=d.getStartOffset()+b,m=null;if(k===this._matchingBracket)m=r;else switch(h){case e:m=o;break;case f:if(this.whitespacesVisible){this._parseWhitespace(d.getData(),k,c,n);continue}m=n;break;case g:if(this.whitespacesVisible){this._parseWhitespace(d.getData(),k,c,l);continue}m=l;break;case i:this.whitespacesVisible&&(m=q);break;case j:this.whitespacesVisible&&(m=p)}c.push({start:k,end:d.getOffset()+b,style:m})}},_parseWhitespace:function(a,b,c,d){var e=this._whitespaceScanner;e.setText(a);var f;while(f=e.nextToken()){var g=e.getStartOffset()+b,h=d;switch(f){case i:h=q;break;case j:h=p}c.push({start:g,end:e.getOffset()+b,style:h})}},_findBrackets:function(a,b,c,d,e,f){var g=[],h=this._getCommentRanges(e,f),i=e,j=this._scanner,k,l;for(var m=0;m<h.length;m+=2){var n=h[m];if(i<n){j.setText(c.substring(i-e,n-e));while(k=j.nextToken()){if(j.getDataLength()!==1)continue;l=j.getData(),l===a&&g.push(j.getStartOffset()+i-e+d),l===b&&g.push(-(j.getStartOffset()+i-e+d))}}i=h[m+1]}if(i<f){j.setText(c.substring(i-e,f-e));while(k=j.nextToken()){if(j.getDataLength()!==1)continue;l=j.getData(),l===a&&g.push(j.getStartOffset()+i-e+d),l===b&&g.push(-(j.getStartOffset()+i-e+d))}}return g},_onDestroy:function(a){this.destroy()},_onLineStyle:function(a){a.style=this._getLineStyle(a.lineIndex),a.ranges=this._getStyles(a.lineText,a.lineStart)},_onSelection:function(a){var b=a.oldValue,c=a.newValue,d=this.editor,e=d.getModel(),f;this._matchingBracket!==undefined&&(f=e.getLineAtOffset(this._matchingBracket),d.redrawLines(f,f+1),this._matchingBracket=this._currentBracket=undefined);if(this.highlightCaretLine){var g=e.getLineAtOffset(b.start);f=e.getLineAtOffset(c.start);var h=c.start===c.end,i=b.start===b.end;if(g!==f||!i||!h)i&&d.redrawLines(g,g+1),(g!==f||!i)&&h&&d.redrawLines(f,f+1)}if(c.start===c.end&&c.start!==0){var j=d.getCaretOffset();if(j===0)return;var k="{}()[]<>",l=e.getText(j-1,j),m=k.indexOf(l,0);if(m===-1)return;var n;m&1?n=k.substring(m-1,m):n=k.substring(m+1,m+2),f=e.getLineAtOffset(j);var o=e.getLine(f),p=e.getLineStart(f),q=e.getLineEnd(f);k=this._findBrackets(l,n,o,p,p,q);for(var r=0;r<k.length;r++){var s=k[r]>=0?1:-1;if(k[r]*s===j-1){var t=1;this._currentBracket=k[r]*s;if(m&1){r--;for(;r>=0;r--){s=k[r]>=0?1:-1,t+=s;if(t===0){this._matchingBracket=k[r]*s,d.redrawLines(f,f+1);return}}f-=1;while(f>=0){o=e.getLine(f),p=e.getLineStart(f),q=e.getLineEnd(f),k=this._findBrackets(l,n,o,p,p,q);for(var u=k.length-1;u>=0;u--){s=k[u]>=0?1:-1,t+=s;if(t===0){this._matchingBracket=k[u]*s,d.redrawLines(f,f+1);return}}f--}}else{r++;for(;r<k.length;r++){s=k[r]>=0?1:-1,t+=s;if(t===0){this._matchingBracket=k[r]*s,d.redrawLines(f,f+1);return}}f+=1;var v=e.getLineCount();while(f<v){o=e.getLine(f),p=e.getLineStart(f),q=e.getLineEnd(f),k=this._findBrackets(l,n,o,p,p,q);for(var w=0;w<k.length;w++){s=k[w]>=0?1:-1,t+=s;if(t===0){this._matchingBracket=k[w]*s,d.redrawLines(f,f+1);return}}f++}}break}}}},_onModelChanged:function(a){var b=a.start,c=a.removedCharCount,d=a.addedCharCount;this._matchingBracket&&b<this._matchingBracket&&(this._matchingBracket+=d+c),this._currentBracket&&b<this._currentBracket&&(this._currentBracket+=d+c);if(!(b>=this.commentOffset)){var e=this.editor.getModel(),f=this.commentOffsets.length,g=Math.max(this.commentStart.length-1,this.commentEnd.length-1);if(f===0){this.commentOffset=Math.max(0,b-g);return}var h=e.getCharCount(),i=h-d+c,j=this._binarySearch(this.commentOffsets,b,-1,f),k=b+c,l=this._binarySearch(this.commentOffsets,k,j-1,f),m;j>0?m=this.commentOffsets[--j]:(m=Math.max(0,Math.min(this.commentOffsets[j],b)-g),--j);var n,o=h;l+1<this.commentOffsets.length?(n=this.commentOffsets[++l],k>n-this.commentEnd.length&&(l+2<this.commentOffsets.length?(l+=2,n=this.commentOffsets[l],o=n+1,o>b&&(o+=d-c)):(n=Math.min(i,k+g),this.commentOffset=n))):(n=Math.min(i,k+g),this.commentOffset=n,l>0&&l===this.commentOffsets.length&&(l=this.commentOffsets.length-1)),m>b&&(m+=d-c),n>b&&(n+=d-c),this.commentOffsets.length>1&&this.commentOffsets[this.commentOffsets.length-1]===i&&this.commentOffsets.length--;var p=0,q=[],r=e.getText(m,n);this.commentOffset<n&&(this.commentOffset=n);while(p<r.length){var s=(j+1+q.length&1)===0,t=s?this.commentStart:this.commentEnd,u=r.indexOf(t,p);if(u!==-1)q.push(m+(s?u:u+t.length));else break;p=u+t.length}var v=l-j!==q.length;if(!v)for(var w=0;w<q.length;w++){p=this.commentOffsets[j+1+w],p>b&&(p+=d-c);if(p!==q[w]){v=!0;break}}var x=[j+1,l-j].concat(q);Array.prototype.splice.apply(this.commentOffsets,x);for(var y=j+1+q.length;y<this.commentOffsets.length;y++)this.commentOffsets[y]+=d-c;(this.commentOffsets.length&1)===1&&this.commentOffsets.push(h),v&&this.editor.redrawRange(b+d,o)}}};return v}();var eclipse=eclipse||{};eclipse.Ruler=function(){function a(a,b,c){this._location=a||"left",this._overview=b||"page",this._rulerStyle=c,this._editor=null}a.prototype={setEditor:function(a){this._onModelChanged&&this._editor&&this._editor.removeEventListener("ModelChanged",this,this._onModelChanged),this._editor=a,this._onModelChanged&&this._editor&&this._editor.addEventListener("ModelChanged",this,this._onModelChanged)},getLocation:function(){return this._location},getOverview:function(a){return this._overview}};return a}(),eclipse.LineNumberRuler=function(){function a(a,b,c,d){eclipse.Ruler.call(this,a,"page",b),this._oddStyle=c||{style:{backgroundColor:"white"}},this._evenStyle=d||{style:{backgroundColor:"white"}},this._numOfDigits=0}a.prototype=new eclipse.Ruler,a.prototype.getStyle=function(a){return a===undefined?this._rulerStyle:a&1?this._oddStyle:this._evenStyle},a.prototype.getHTML=function(a){if(a===-1){var b=this._editor.getModel();return b.getLineCount()}return a+1},a.prototype._onModelChanged=function(a){var b=a.start,c=this._editor.getModel(),d=c.getLineCount(),e=(d+"").length;if(this._numOfDigits!==e){this._numOfDigits=e;var f=c.getLineAtOffset(b);this._editor.redrawLines(f,d,this)}};return a}(),eclipse.AnnotationRuler=function(){function a(a,b,c){eclipse.Ruler.call(this,a,"page",b),this._defaultAnnotation=c,this._annotations=[]}a.prototype=new eclipse.Ruler,a.prototype.clearAnnotations=function(){this._annotations=[];var a=this._editor.getModel().getLineCount();this._editor.redrawLines(0,a,this),this._overviewRuler&&this._editor.redrawLines(0,a,this._overviewRuler)},a.prototype.getAnnotation=function(a){return this._annotations[a]},a.prototype.getAnnotations=function(){return this._annotations},a.prototype.getStyle=function(a){switch(a){case undefined:return this._rulerStyle;case-1:return this._defaultAnnotation?this._defaultAnnotation.style:null;default:return this._annotations[a]&&this._annotations[a].style?this._annotations[a].style:null}},a.prototype.getHTML=function(a){return a===-1?this._defaultAnnotation?this._defaultAnnotation.html:"":this._annotations[a]&&this._annotations[a].html?this._annotations[a].html:""},a.prototype.setAnnotation=function(a,b){a!==undefined&&(this._annotations[a]=b,this._editor.redrawLines(a,a+1,this),this._overviewRuler&&this._editor.redrawLines(a,a+1,this._overviewRuler))},a.prototype._onModelChanged=function(a){var b=a.start,c=a.removedLineCount,d=a.addedLineCount,e=d-c;if(e){var f=this._editor.getModel(),g=f.getLineAtOffset(b),h=[],i=this._annotations,j=!1;for(var k in i){var l=k>>>0;if(g<l&&l<g+c)j=!0;else{var m=l;l>g&&(m+=e,j=!0),h[m]=i[l]}}this._annotations=h;if(j){var n=f.getLineCount();this._editor.redrawLines(g,n,this),this._overviewRuler&&this._editor.redrawLines(0,n,this._overviewRuler)}}};return a}(),eclipse.OverviewRuler=function(){function a(a,b,c){eclipse.Ruler.call(this,a,"document",b),this._annotationRuler=c,c&&(c._overviewRuler=this)}a.prototype=new eclipse.Ruler,a.prototype.getAnnotations=function(){var a=this._annotationRuler.getAnnotations(),b=[];for(var c in a){var d=c>>>0;a[d]!==undefined&&b.push(d)}return b},a.prototype.getStyle=function(a){var b,c;if(a===undefined)b=this._rulerStyle||{},c=b.style||(b.style={}),c.lineHeight="1px",c.fontSize="1px",c.width="14px";else{if(a!==-1){var d=this._annotationRuler.getAnnotation(a);b=d.overviewStyle||{}}else b={};c=b.style||(b.style={}),c.cursor="pointer",c.width="8px",c.height="3px",c.left="2px"}return b},a.prototype.getHTML=function(a){return"&nbsp;"},a.prototype.onClick=function(a,b){a!==undefined&&this._editor.setTopIndex(a)};return a}();var eclipse=eclipse||{};eclipse.UndoStack=function(){function c(a,b){this.editor=a,this.size=b!==undefined?b:100,this.reset(),a.addEventListener("ModelChanging",this,this._onModelChanging),a.addEventListener("Destroy",this,this._onDestroy)}var a=function(){function a(a,b,c){this.offset=a,this.text=b,this.previousText=c}a.prototype={undo:function(a,b){this._doUndoRedo(this.offset,this.previousText,this.text,a,b)},redo:function(a,b){this._doUndoRedo(this.offset,this.text,this.previousText,a,b)},_doUndoRedo:function(a,b,c,d,e){d.setText(b,a,a+c.length),e&&d.setSelection(a,a+b.length)}};return a}(),b=function(){function a(a,b){this.selection=a,this.caret=b,this.changes=[]}a.prototype={add:function(a){this.changes.push(a)},undo:function(a,b){for(var c=this.changes.length-1;c>=0;c--)this.changes[c].undo(a,!1);if(b){var d=this.selection.start,e=this.selection.end;a.setSelection(this.caret?d:e,this.caret?e:d)}},redo:function(a,b){for(var c=0;c<this.changes.length;c++)this.changes[c].redo(a,!1);if(b){var d=this.selection.start,e=this.selection.end;a.setSelection(this.caret?d:e,this.caret?e:d)}}};return a}();c.prototype={add:function(a){if(this.compoundChange)this.compoundChange.add(a);else{var b=this.stack.length;this.stack.splice(this.index,b-this.index,a),this.index++,this.stack.length>this.size&&(this.stack.shift(),this.index--,this.cleanIndex--)}},markClean:function(){this.endCompoundChange(),this._commitUndo(),this.cleanIndex=this.index},isClean:function(){return this.cleanIndex===this.getSize().undo},canUndo:function(){return this.getSize().undo>0},canRedo:function(){return this.getSize().redo>0},endCompoundChange:function(){this.compoundChange=undefined},getSize:function(){var a=this.index,b=this.stack.length;this._undoStart!==undefined&&a++;return{undo:a,redo:b-a}},undo:function(){this._commitUndo();if(this.index<=0)return!1;var a=this.stack[--this.index];this._ignoreUndo=!0,a.undo(this.editor,!0),this._ignoreUndo=!1;return!0},redo:function(){this._commitUndo();if(this.index>=this.stack.length)return!1;var a=this.stack[this.index++];this._ignoreUndo=!0,a.redo(this.editor,!0),this._ignoreUndo=!1;return!0},reset:function(){this.index=this.cleanIndex=0,this.stack=[],this._undoStart=undefined,this._undoText="",this._ignoreUndo=!1,this._compoundChange=undefined},startCompoundChange:function(){var a=new b(this.editor.getSelection(),this.editor.getCaretOffset());this.add(a),this.compoundChange=a},_commitUndo:function(){this._undoStart!==undefined&&(this._undoStart<0?this.add(new a(-this._undoStart,"",this._undoText,"")):this.add(new a(this._undoStart,this._undoText,"")),this._undoStart=undefined,this._undoText="")},_onDestroy:function(){this.editor.removeEventListener("ModelChanging",this,this._onModelChanging),this.editor.removeEventListener("Destroy",this,this._onDestroy)},_onModelChanging:function(b){var c=b.text,d=b.start,e=b.removedCharCount,f=b.addedCharCount;if(!this._ignoreUndo){this._undoStart!==undefined&&(f!==1||e!==0||d!==this._undoStart+this._undoText.length)&&(f!==0||e!==1||d+1!==-this._undoStart&&d!==-this._undoStart)&&this._commitUndo();if(!this.compoundChange){if(f===1&&e===0){this._undoStart===undefined&&(this._undoStart=d),this._undoText=this._undoText+c;return}if(f===0&&e===1){var g=this._undoText.length>0&&-this._undoStart===d;this._undoStart=-d,g?this._undoText=this._undoText+this.editor.getText(d,d+e):this._undoText=this.editor.getText(d,d+e)+this._undoText;return}}this.add(new a(d,c,this.editor.getText(d,d+e)))}}};return c}();var eclipse=eclipse||{};eclipse.KeyBinding=function(){function b(a,b,c,d,e){typeof a=="string"?this.keyCode=a.toUpperCase().charCodeAt(0):this.keyCode=a,this.mod1=b!==undefined&&b!==null?b:!1,this.mod2=c!==undefined&&c!==null?c:!1,this.mod3=d!==undefined&&d!==null?d:!1,this.mod4=e!==undefined&&e!==null?e:!1}var a=navigator.platform.indexOf("Mac")!==-1;b.prototype={match:function(b){if(this.keyCode===b.keyCode){var c=a?b.metaKey:b.ctrlKey;if(this.mod1!==c)return!1;if(this.mod2!==b.shiftKey)return!1;if(this.mod3!==b.altKey)return!1;if(a&&this.mod4!==b.ctrlKey)return!1;return!0}return!1},equals:function(a){if(!a)return!1;if(this.keyCode!==a.keyCode)return!1;if(this.mod1!==a.mod1)return!1;if(this.mod2!==a.mod2)return!1;if(this.mod3!==a.mod3)return!1;if(this.mod4!==a.mod4)return!1;return!0}};return b}(),eclipse.Editor=function(){function q(a){this._init(a)}function b(a,b,c,d){typeof a.removeEventListener=="function"?a.removeEventListener(b,c,d===!0):a.detachEvent("on"+b,c)}function a(a,b,c,d){typeof a.addEventListener=="function"?a.addEventListener(b,c,d===!0):a.attachEvent("on"+b,c)}var c=document.selection&&window.ActiveXObject&&/MSIE/.test(navigator.userAgent)?document.documentMode:undefined,d=parseFloat(navigator.userAgent.split("Firefox/")[1]||navigator.userAgent.split("Minefield/")[1])||undefined,e=navigator.userAgent.indexOf("Opera")!==-1,f=navigator.userAgent.indexOf("Chrome")!==-1,g=navigator.userAgent.indexOf("Safari")!==-1,h=navigator.userAgent.indexOf("WebKit")!==-1,i=navigator.userAgent.indexOf("iPad")!==-1,j=navigator.platform.indexOf("Mac")!==-1,k=navigator.platform.indexOf("Win")!==-1,l=navigator.platform.indexOf("Linux")!==-1,m=typeof window.document.documentElement.addEventListener=="function",n=(!c||c>=9)&&typeof window.document.createRange().getBoundingClientRect=="function",o=function(){function a(a,b,c){this.start=a,this.end=b,this.caret=c}a.prototype={clone:function(){return new a(this.start,this.end,this.caret)},collapse:function(){this.caret?this.end=this.start:this.start=this.end},extend:function(a){this.caret?this.start=a:this.end=a;if(this.start>this.end){var b=this.start;this.start=this.end,this.end=b,this.caret=!this.caret}},setCaret:function(a){this.start=a,this.end=a,this.caret=!1},getCaret:function(){return this.caret?this.start:this.end},toString:function(){return"start="+this.start+" end="+this.end+(this.caret?" caret is at start":" caret is at end")},isEmpty:function(){return this.start===this.end},equals:function(a){return this.caret===a.caret&&this.start===a.start&&this.end===a.end}};return a}(),p=function(){function a(){this._listeners={}}a.prototype={addEventListener:function(a,b,c,d){this._listeners[a]||(this._listeners[a]=[]);var e={context:b,func:c,data:d};this._listeners[a].push(e)},sendEvent:function(a,b){var c=this._listeners[a];if(c)for(var d=0,e=c.length;d<e;d++){var f=c[d];f&&f.context&&f.func&&f.func.call(f.context,b,f.data)}},removeEventListener:function(a,b,c,d){var e=this._listeners[a];if(e)for(var f=0,g=e.length;f<g;f++){var h=e[f];if(h.context===b&&h.func===c&&h.data===d){e.splice(f,1);break}}}};return a}();q.prototype={addEventListener:function(a,b,c,d){this._eventTable.addEventListener(a,b,c,d)},addRuler:function(b){var d=this._frameDocument,e=d.body,f=b.getLocation(),g=f==="left"?this._leftDiv:this._rightDiv;if(!g){g=d.createElement("DIV"),g.style.overflow="hidden",g.style.MozUserSelect="none",g.style.WebkitUserSelect="none",c&&g.attachEvent("onselectstart",function(){return!1}),g.style.position="absolute",g.style.top="0px",g.style.cursor="default",e.appendChild(g),f==="left"?(this._leftDiv=g,g.className="editorLeftRuler"):(this._rightDiv=g,g.className="editorRightRuler");var h=d.createElement("TABLE");g.appendChild(h),h.cellPadding="0px",h.cellSpacing="0px",h.border="0px",h.insertRow(0);var i=this;a(g,"click",function(a){i._handleRulerEvent(a)}),a(g,"dblclick",function(a){i._handleRulerEvent(a)})}var j=d.createElement("DIV");j._ruler=b,j.rulerChanged=!0,j.style.position="relative";var k=g.firstChild.rows[0],l=k.cells.length,m=k.insertCell(l);m.vAlign="top",m.appendChild(j),b.setEditor(this),this._updatePage()},convert:function(a,b,c){var d=this._getScroll(),e=this._getEditorPadding(),f=this._frame.getBoundingClientRect(),g=this._editorDiv.getBoundingClientRect();switch(b){case"document":a.x!==undefined&&(a.x+=-d.x+g.left+e.left),a.y!==undefined&&(a.y+=-d.y+g.top+e.top);break;case"page":a.x!==undefined&&(a.x+=-f.left),a.y!==undefined&&(a.y+=-f.top)}switch(c){case"document":a.x!==undefined&&(a.x+=d.x-g.left-e.left),a.y!==undefined&&(a.y+=d.y-g.top-e.top);break;case"page":a.x!==undefined&&(a.x+=f.left),a.y!==undefined&&(a.y+=f.top)}},destroy:function(){this._setGrab(null),this._unhookEvents();var a=function(a){if(!!a){var b=a.firstChild.rows[0].cells;for(var c=0;c<b.length;c++){var d=b[c].firstChild;d._ruler.setEditor(null)}}};a(this._leftDiv),a(this._rightDiv),this._autoScrollTimerID&&(clearTimeout(this._autoScrollTimerID),this._autoScrollTimerID=null),this._updateTimer&&(clearTimeout(this._updateTimer),this._updateTimer=null);var b=this._parent,c=this._frame;b.removeChild(c),i&&(b.removeChild(this._touchDiv),this._touchDiv=null,this._selDiv1=null,this._selDiv2=null,this._selDiv3=null,this._textArea=null);var d={};this.onDestroy(d),this._parent=null,this._parentDocument=null,this._model=null,this._selection=null,this._doubleClickSelection=null,this._eventTable=null,this._frame=null,this._frameDocument=null,this._frameWindow=null,this._scrollDiv=null,this._editorDiv=null,this._clientDiv=null,this._overlayDiv=null,this._keyBindings=null,this._actions=null},focus:function(){this._updateDOMSelection(),i?this._textArea.focus():(e&&this._clientDiv.blur(),this._clientDiv.focus()),this._updateDOMSelection()},getActions:function(a){var b=[],c=this._actions;for(var d=0;d<c.length;d++){if(!a&&c[d].defaultHandler)continue;b.push(c[d].name)}return b},getBottomIndex:function(a){return this._getBottomIndex(a)},getBottomPixel:function(){return this._getScroll().y+this._getClientHeight()},getCaretOffset:function(){var a=this._getSelection();return a.getCaret()},getClientArea:function(){var a=this._getScroll();return{x:a.x,y:a.y,width:this._getClientWidth(),height:this._getClientHeight()}},getHorizontalPixel:function(){return this._getScroll().x},getKeyBindings:function(a){var b=[],c=this._keyBindings;for(var d=0;d<c.length;d++)c[d].name===a&&b.push(c[d].keyBinding);return b},getLineHeight:function(a){return this._getLineHeight()},getLinePixel:function(a){a=Math.min(Math.max(0,a),this._model.getLineCount());var b=this._getLineHeight();return b*a},getLocationAtOffset:function(a){var b=this._model;a=Math.min(Math.max(0,a),b.getCharCount());var c=b.getLineAtOffset(a),d=this._getScroll(),e=this._editorDiv.getBoundingClientRect(),f=this._getEditorPadding(),g=this._getOffsetToX(a)+d.x-e.left-f.left,h=this.getLinePixel(c);return{x:g,y:h}},getModel:function(){return this._model},getOffsetAtLocation:function(a,b){var c=this._model,d=this._getScroll(),e=this._editorDiv.getBoundingClientRect(),f=this._getEditorPadding(),g=this._getYToLine(b-d.y);a+=-d.x+e.left+f.left;var h=this._getXToOffset(g,a);return h},getSelection:function(){var a=this._getSelection();return{start:a.start,end:a.end}},getText:function(a,b){var c=this._model;return c.getText(a,b)},getTopIndex:function(a){return this._getTopIndex(a)},getTopPixel:function(){return this._getScroll().y},invokeAction:function(a,b){var c=this._actions;for(var d=0;d<c.length;d++){var e=c[d];if(e.name&&e.name===a){if(!b&&e.userHandler&&e.userHandler())return;if(e.defaultHandler)return e.defaultHandler();return!1}}return!1},onDestroy:function(a){this._eventTable.sendEvent("Destroy",a)},onLineStyle:function(a){this._eventTable.sendEvent("LineStyle",a)},onModelChanged:function(a){this._eventTable.sendEvent("ModelChanged",a)},onModelChanging:function(a){this._eventTable.sendEvent("ModelChanging",a)},onModify:function(a){this._eventTable.sendEvent("Modify",a)},onSelection:function(a){this._eventTable.sendEvent("Selection",a)},onScroll:function(a){this._eventTable.sendEvent("Scroll",a)},onVerify:function(a){this._eventTable.sendEvent("Verify",a)},onContextMenu:function(a){this._eventTable.sendEvent("ContextMenu",a)},redrawLines:function(a,b,c){a===undefined&&(a=0),b===undefined&&(b=this._model.getLineCount());if(a!==b){var d=this._clientDiv;if(c){var e=c.getLocation(),f=e==="left"?this._leftDiv:this._rightDiv,g=f.firstChild.rows[0].cells;for(var h=0;h<g.length;h++)if(g[h].firstChild._ruler===c){d=g[h].firstChild;break}}c&&(d.rulerChanged=!0);if(!c||c.getOverview()==="page"){var i=d.firstChild;while(i){var j=i.lineIndex;a<=j&&j<b&&(i.lineChanged=!0),i=i.nextSibling}}c||a<=this._maxLineIndex&&this._maxLineIndex<b&&(this._maxLineIndex=-1,this._maxLineWidth=0),this._queueUpdatePage()}},redrawRange:function(a,b){var c=this._model;a===undefined&&(a=0),b===undefined&&(b=c.getCharCount());if(a!==b){var d=c.getLineAtOffset(a),e=c.getLineAtOffset(Math.max(0,b-1))+1;this.redrawLines(d,e)}},removeEventListener:function(a,b,c,d){this._eventTable.removeEventListener(a,b,c,d)},removeRuler:function(a){a.setEditor(null);var b=a.getLocation(),c=b==="left"?this._leftDiv:this._rightDiv,d=c.firstChild.rows[0],e=d.cells;for(var f=0;f<e.length;f++){var g=e[f];if(g.firstChild._ruler===a)break}f!==e.length&&(d.cells[f]._ruler=undefined,d.deleteCell(f),this._updatePage())},setAction:function(a,b){if(!!a){var c=this._actions;for(var d=0;d<c.length;d++){var e=c[d];if(e.name===a){e.userHandler=b;return}}c.push({name:a,userHandler:b})}},setKeyBinding:function(a,b){var c=this._keyBindings;for(var d=0;d<c.length;d++){var e=c[d];if(e.keyBinding.equals(a)){if(b)e.name=b;else if(e.predefined)e.name=null;else{var f=e.name;c.splice(d,1);var g=0;while(g<c.length&&f!==c[g].name)g++;if(g===c.length){var h=this._actions;for(var i=0;i<h.length;i++)h[i].name===f&&(h[i].defaultHandler||h.splice(i,1))}}return}}b&&c.push({keyBinding:a,name:b})},setCaretOffset:function(a,b){var c=this._model.getCharCount();a=Math.max(0,Math.min(a,c));var d=new o(a,a,!1);this._setSelection(d,b===undefined||b)},setHorizontalPixel:function(a){a=Math.max(0,a),this._scrollView(a-this._getScroll().x,0)},setModel:function(a){if(!!a){this._model.removeListener(this._modelListener);var b=this._model.getLineCount(),c=this._model.getCharCount(),d=a.getLineCount(),e=a.getCharCount(),f=a.getText(),g={text:f,start:0,removedCharCount:c,addedCharCount:e,removedLineCount:b,addedLineCount:d};this.onModelChanging(g),this.redrawRange(),this._model=a,g={start:0,removedCharCount:c,addedCharCount:e,removedLineCount:b,addedLineCount:d},this.onModelChanged(g),this._model.addListener(this._modelListener),this.redrawRange()}},setSelection:function(a,b,c){var d=a>b;if(d){var e=a;a=b,b=e}var f=this._model.getCharCount();a=Math.max(0,Math.min(a,f)),b=Math.max(0,Math.min(b,f));var g=new o(a,b,d);this._setSelection(g,c===undefined||c)},setText:function(a,b,c){var e=b===undefined&&c===undefined;b===undefined&&(b=0),c===undefined&&(c=this._model.getCharCount()),this._modifyContent({text:a,start:b,end:c,_code:!0},!e);if(e){this._columnX=-1,this._setSelection(new o(0,0,!1),!0),this._showCaret();if(d>=4){var f=this._clientDiv;f.contentEditable=!1,f.contentEditable=!0,f.blur(),f.focus()}}},setTopIndex:function(a){var b=this._model;if(b.getCharCount()!==0){var c=b.getLineCount(),d=this._getLineHeight(),e=Math.max(1,Math.min(c,Math.floor(this._getClientHeight()/d)));a<0?a=0:a>c-e&&(a=c-e);var f=a*d-this._getScroll().y;this._scrollView(0,f)}},setTopPixel:function(a){var b=this._getLineHeight(),c=this._getClientHeight(),d=this._model.getLineCount();a=Math.min(Math.max(0,a),b*d-c),this._scrollView(0,a-this._getScroll().y)},showSelection:function(){return this._showCaret()},_handleBodyMouseDown:function(a){a||(a=window.event);var b=e?this._clientDiv:this._overlayDiv||this._editorDiv,c=a.target?a.target:a.srcElement;while(c){if(b===c)return;c=c.parentNode}a.preventDefault&&a.preventDefault(),a.stopPropagation&&a.stopPropagation(),m||(b.setCapture(),setTimeout(function(){b.releaseCapture()},0))},_handleBlur:function(a){a||(a=window.event),this._hasFocus=!1;if(c<9&&!this._getSelection().isEmpty()){var b=this._frameDocument,e=b.createElement("DIV"),f=b.body;f.appendChild(e),f.removeChild(e)}if(d||c)if(this._selDiv1){var g=c?"transparent":"#AFAFAF";this._selDiv1.style.background=g,this._selDiv2.style.background=g,this._selDiv3.style.background=g}},_handleContextMenu:function(a){a||(a=window.event),a.preventDefault&&a.preventDefault();return!1},_handleCopy:function(a){if(!this._ignoreCopy){a||(a=window.event);if(this._doCopy(a)){a.preventDefault&&a.preventDefault();return!1}}},_handleCut:function(a){a||(a=window.event);if(this._doCut(a)){a.preventDefault&&a.preventDefault();return!1}},_handleDataModified:function(a){this._startIME()},_handleDblclick:function(a){a||(a=window.event);var b=a.timeStamp?a.timeStamp:(new Date).getTime();this._lastMouseTime=b,this._clickCount!==2&&(this._clickCount=2,this._handleMouse(a))},_handleDragStart:function(a){a||(a=window.event),a.preventDefault&&a.preventDefault();return!1},_handleDragOver:function(a){a||(a=window.event),a.dataTransfer.dropEffect="none",a.preventDefault&&a.preventDefault();return!1},_handleDrop:function(a){a||(a=window.event),a.preventDefault&&a.preventDefault();return!1},_handleDocFocus:function(a){a||(a=window.event),this._clientDiv.focus()},_handleFocus:function(a){a||(a=window.event),this._hasFocus=!0,c&&this._updateDOMSelection();if(d||c)if(this._selDiv1){var b=this._hightlightRGB;this._selDiv1.style.background=b,this._selDiv2.style.background=b,this._selDiv3.style.background=b}},_handleKeyDown:function(a){a||(a=window.event);if(i)a.keyCode===8&&(this._doBackspace({}),a.preventDefault());else{if(a.keyCode===229){if(this.readonly){a.preventDefault&&a.preventDefault();return!1}this._startIME()}else this._commitIME();if((j||l)&&d<4||e){this._keyDownEvent=a;return!0}if(this._doAction(a)){a.preventDefault?a.preventDefault():(a.cancelBubble=!0,a.returnValue=!1,a.keyCode=0);return!1}}},_handleKeyPress:function(a){a||(a=window.event);if(j&&h)if(63232<=a.keyCode&&a.keyCode<=63487||a.keyCode===13||a.keyCode===8){a.preventDefault&&a.preventDefault();return!1}if((j||l)&&d<4||e)if(this._doAction(this._keyDownEvent)){a.preventDefault&&a.preventDefault();return!1}var b=j?a.metaKey:a.ctrlKey;if(a.charCode!==undefined&&b)switch(a.charCode){case 99:case 118:case 120:return!0}var c=!1;if(j){if(a.ctrlKey||a.metaKey)c=!0}else if(d){if(a.ctrlKey||a.altKey)c=!0}else a.ctrlKey^a.altKey&&(c=!0);if(!c){var f=e?a.which:a.charCode!==undefined?a.charCode:a.keyCode;if(f!==0){this._doContent(String.fromCharCode(f)),a.preventDefault&&a.preventDefault();return!1}}},_handleKeyUp:function(a){a||(a=window.event),a.keyCode===13&&this._commitIME()},_handleMouse:function(a){var b=this._frameWindow;c&&(b=this._clientDiv);if(this._overlayDiv){var d=this;setTimeout(function(){d.focus()},0)}this._clickCount===1?(this._setGrab(b),this._setSelectionTo(a.clientX,a.clientY,a.shiftKey)):(m&&this._setGrab(b),this._doubleClickSelection=null,this._setSelectionTo(a.clientX,a.clientY,a.shiftKey),this._doubleClickSelection=this._getSelection())},_handleMouseDown:function(a){a||(a=window.event);var b=a.which?a.button===0:a.button===1;this._commitIME();if(b){this._isMouseDown=!0;var c=Math.abs(this._lastMouseX-a.clientX),d=Math.abs(this._lastMouseY-a.clientY),f=a.timeStamp?a.timeStamp:(new Date).getTime();f-this._lastMouseTime<=this._clickTime&&c<=this._clickDist&&d<=this._clickDist?this._clickCount++:this._clickCount=1,this._lastMouseX=a.clientX,this._lastMouseY=a.clientY,this._lastMouseTime=f,this._handleMouse(a),e&&(this._hasFocus||this.focus(),a.preventDefault())}},_handleMouseMove:function(a){a||(a=window.event);if(!m){if(a.button===0){this._setGrab(null);return!0}if(!this._isMouseDown&&a.button===1&&(this._clickCount&1)!==0){this._clickCount=2;return this._handleMouse(a,this._clickCount)}}var b=a.clientX,d=a.clientY,e=this._getEditorPadding(),f=this._editorDiv.getBoundingClientRect(),g=this._getClientWidth(),h=this._getClientHeight(),i=f.left+e.left,j=f.top+e.top,k=f.left+e.left+g,l=f.top+e.top+h,n=this._model,o=n.getLineAtOffset(this._getSelection().getCaret());if(d<j&&o!==0)this._doAutoScroll("up",b,d-j);else if(d>l&&o!==n.getLineCount()-1)this._doAutoScroll("down",b,d-l);else if(b<i)this._doAutoScroll("left",b-i,d);else if(b>k)this._doAutoScroll("right",b-k,d);else{this._endAutoScroll(),this._setSelectionTo(b,d,!0);if(c){var p=this._frameDocument.body;p.getBoundingClientRect()}}},_handleMouseUp:function(a){a||(a=window.event),this._endAutoScroll();var b=a.which?a.button===0:a.button===1;b&&(this._isMouseDown=!1,m&&this._setGrab(null))},_handleMouseWheel:function(a){a||(a=window.event);var b=this._getLineHeight(),c=0,e=0;if(d){var h;if(j)h=a.detail*3;else{var i=256;h=Math.max(-i,Math.min(i,a.detail))*b}a.axis===a.HORIZONTAL_AXIS?c=h:e=h}else if(j){var k=40,l=40;f&&(a.wheelDeltaX%120!==0&&(k=1),a.wheelDeltaY%120!==0&&(l=1)),c=-a.wheelDeltaX/k,-1<c&&c<0&&(c=-1),0<c&&c<1&&(c=1),e=-a.wheelDeltaY/l,-1<e&&e<0&&(e=-1),0<e&&e<1&&(e=1)}else{c=-a.wheelDeltaX;var m=8;e=-a.wheelDeltaY/120*m*b}if(g){var n=a.target;while(n&&n.lineIndex===undefined)n=n.parentNode;this._mouseWheelLine=n}var o=this._getScroll();this._scrollView(c,e);var p=this._getScroll();g&&(this._mouseWheelLine=null);if(o.x!==p.x||o.y!==p.y){a.preventDefault&&a.preventDefault();return!1}},_handlePaste:function(a){if(!this._ignorePaste){a||(a=window.event);if(this._doPaste(a)){if(c){var b=this;setTimeout(function(){b._updateDOMSelection()},0)}a.preventDefault&&a.preventDefault();return!1}}},_handleResize:function(a){a||(a=window.event);var b=this._frameDocument.documentElement,c=b.clientWidth,d=b.clientHeight;if(this._frameWidth!==c||this._frameHeight!==d)this._frameWidth=c,this._frameHeight=d,this._updatePage()},_handleRulerEvent:function(a){a||(a=window.event);var b=a.target?a.target:a.srcElement,c=b.lineIndex,d=b;while(d&&!d._ruler)c===undefined&&d.lineIndex!==undefined&&(c=d.lineIndex),d=d.parentNode;var e=d?d._ruler:null;if(i&&c===undefined&&e&&e.getOverview()==="document"){var f=17,g=this._getClientHeight(),h=this._getLineHeight(),j=this._getEditorPadding(),k=g+j.top+j.bottom-2*f,l=this._model.getLineCount()*h;this.setTopPixel(Math.floor((a.clientY-f-h)*l/k))}if(e)switch(a.type){case"click":e.onClick&&e.onClick(c,a);break;case"dblclick":e.onDblClick&&e.onDblClick(c,a)}},_handleScroll:function(){this._doScroll(this._getScroll())},_handleSelectStart:function(a){a||(a=window.event);if(this._ignoreSelect){a&&a.preventDefault&&a.preventDefault();return!1}},_handleInput:function(a){var b=this._textArea;this._doContent(b.value),b.selectionStart=b.selectionEnd=0,b.value="",a.preventDefault()},_handleTextInput:function(a){this._doContent(a.data),a.preventDefault()},_touchConvert:function(a){var b=this._frame.getBoundingClientRect(),c=this._parentDocument.body;return{left:a.clientX-b.left-c.scrollLeft,top:a.clientY-b.top-c.scrollTop}},_handleTouchStart:function(a){var b=a.touches,c,d,e;this._touchMoved=!1,this._touchStartScroll=undefined;if(b.length===1){c=b[0];var f=c.pageX,g=c.pageY;this._touchStartX=f,this._touchStartY=g,this._touchStartTime=a.timeStamp,this._touchStartScroll=this._getScroll(),e=this._getSelection(),d=this._touchConvert(b[0]),this._touchGesture="none",e.isEmpty()||(this._hitOffset(e.end,d.left,d.top)?this._touchGesture="extendEnd":this._hitOffset(e.start,d.left,d.top)&&(this._touchGesture="extendStart"));if(this._touchGesture==="none"){var h=this._textArea;h.value="",h.style.left="-1000px",h.style.top="-1000px",h.style.width="3000px",h.style.height="3000px";var i=this,j=function(){i._touchTimeout=null,i._clickCount=1,i._setSelectionTo(d.left,d.top,!1)};this._touchTimeout=setTimeout(j,200)}}else if(b.length===2){this._touchGesture="select",this._touchTimeout&&(clearTimeout(this._touchTimeout),this._touchTimeout=null),d=this._touchConvert(b[0]);var k=this._getXToOffset(this._getYToLine(d.top),d.left);d=this._touchConvert(b[1]);var l=this._getXToOffset(this._getYToLine(d.top),d.left);e=this._getSelection(),e.setCaret(k),e.extend(l),this._setSelection(e,!0,!0)}},_handleTouchMove:function(a){this._touchMoved=!0;var b=a.touches,c,d;if(b.length===1){var e=b[0],f=e.pageX,g=e.pageY,h=this._touchStartX-f,i=this._touchStartY-g;c=this._touchConvert(e),d=this._getSelection(),this._touchTimeout&&(clearTimeout(this._touchTimeout),this._touchTimeout=null),this._touchGesture==="none"&&(a.timeStamp-this._touchStartTime<200&&(Math.abs(h)>5||Math.abs(i)>5)?this._touchGesture="scroll":this._touchGesture="caret"),this._touchGesture==="select"&&(this._hitOffset(d.end,c.left,c.top)?this._touchGesture="extendEnd":this._hitOffset(d.start,c.left,c.top)?this._touchGesture="extendStart":this._touchGesture="caret");switch(this._touchGesture){case"scroll":this._touchStartX=f,this._touchStartY=g,this._scrollView(h,i);break;case"extendStart":case"extendEnd":this._clickCount=1;var j=this._getYToLine(c.top),k=this._getXToOffset(j,c.left);d.setCaret(this._touchGesture==="extendStart"?d.end:d.start),d.extend(k),k>=d.end&&this._touchGesture==="extendStart"&&(this._touchGesture="extendEnd"),k<=d.start&&this._touchGesture==="extendEnd"&&(this._touchGesture="extendStart"),this._setSelection(d,!0,!0);break;case"caret":this._setSelectionTo(c.left,c.top,!1)}}else if(b.length===2){c=this._touchConvert(b[0]);var l=this._getXToOffset(this._getYToLine(c.top),c.left);c=this._touchConvert(b[1]);var m=this._getXToOffset(this._getYToLine(c.top),c.left);d=this._getSelection(),d.setCaret(l),d.extend(m),this._setSelection(d,!0,!0)}a.preventDefault()},_handleTouchEnd:function(a){if(!this._touchMoved&&a.touches.length===0&&a.changedTouches.length===1&&this._touchTimeout){clearTimeout(this._touchTimeout),this._touchTimeout=null;var b=a.changedTouches[0];this._clickCount=1;var c=this._touchConvert(b);this._setSelectionTo(c.left,c.top,!1)}if(a.touches.length===0){var d=this;setTimeout(function(){var a=d._getSelection(),b=d._model.getText(a.start,a.end),c=d._textArea;c.value=b,c.selectionStart=0,c.selectionEnd=b.length;if(!a.isEmpty()){var e=d._touchDiv.getBoundingClientRect(),f=d._getOffsetBounds(a.start);c.style.left=e.width/2+"px",c.style.top=(f.top>40?f.top-30:f.top+30)+"px"}},0)}a.preventDefault()},_doAction:function(a){var b=this._keyBindings;for(var c=0;c<b.length;c++){var d=b[c];if(d.keyBinding.match(a)){if(d.name){var e=this._actions;for(var f=0;f<e.length;f++){var g=e[f];if(g.name===d.name){g.userHandler?g.userHandler()||g.defaultHandler&&g.defaultHandler():g.defaultHandler&&g.defaultHandler();break}}}return!0}}return!1},_doBackspace:function(a){var b=this._getSelection();if(b.isEmpty()){var c=this._model,d=b.getCaret(),e=c.getLineAtOffset(d);d===c.getLineStart(e)?e>0&&b.extend(c.getLineEnd(e-1)):b.extend(this._getOffset(d,a.unit,-1))}this._modifyContent({text:"",start:b.start,end:b.end},!0);return!0},_doContent:function(a){var b=this._getSelection();this._modifyContent({text:a,start:b.start,end:b.end,_ignoreDOMSelection:!0},!0)},_doCopy:function(a){var b=this._getSelection();if(!b.isEmpty()){var c=this._model.getText(b.start,b.end);return this._setClipboardText(c,a)}return!0},_doCursorNext:function(a){if(!a.select&&this._clearSelection("next"))return!0;var b=this._model,c=this._getSelection(),d=c.getCaret(),e=b.getLineAtOffset(d);d===b.getLineEnd(e)?e+1<b.getLineCount()&&c.extend(b.getLineStart(e+1)):c.extend(this._getOffset(d,a.unit,1)),a.select||c.collapse(),this._setSelection(c,!0);return!0},_doCursorPrevious:function(a){if(!a.select&&this._clearSelection("previous"))return!0;var b=this._model,c=this._getSelection(),d=c.getCaret(),e=b.getLineAtOffset(d);d===b.getLineStart(e)?e>0&&c.extend(b.getLineEnd(e-1)):c.extend(this._getOffset(d,a.unit,-1)),a.select||c.collapse(),this._setSelection(c,!0);return!0},_doCut:function(a){var b=this._getSelection();if(!b.isEmpty()){var c=this._model.getText(b.start,b.end);this._doContent("");return this._setClipboardText(c,a)}return!0},_doDelete:function(a){var b=this._getSelection();if(b.isEmpty()){var c=this._model,d=b.getCaret(),e=c.getLineAtOffset(d);d===c.getLineEnd(e)?e+1<c.getLineCount()&&b.extend(c.getLineStart(e+1)):b.extend(this._getOffset(d,a.unit,1))}this._modifyContent({text:"",start:b.start,end:b.end},!0);return!0},_doEnd:function(a){var b=this._getSelection(),c=this._model;if(a.ctrl)b.extend(c.getCharCount());else{var d=c.getLineAtOffset(b.getCaret());b.extend(c.getLineEnd(d))}a.select||b.collapse(),this._setSelection(b,!0);return!0},_doEnter:function(a){var b=this._model;this._doContent(b.getLineDelimiter());return!0},_doHome:function(a){var b=this._getSelection(),c=this._model;if(a.ctrl)b.extend(0);else{var d=c.getLineAtOffset(b.getCaret());b.extend(c.getLineStart(d))}a.select||b.collapse(),this._setSelection(b,!0);return!0},_doLineDown:function(a){var b=this._model,c=this._getSelection(),d=c.getCaret(),e=b.getLineAtOffset(d);if(e+1<b.getLineCount()){var f=this._columnX;if(f===-1||a.select)f=this._getOffsetToX(d);c.extend(this._getXToOffset(e+1,f)),a.select||c.collapse(),this._setSelection(c,!0,!0),this._columnX=f}return!0},_doLineUp:function(a){var b=this._model,c=this._getSelection(),d=c.getCaret(),e=b.getLineAtOffset(d);if(e>0){var f=this._columnX;if(f===-1||a.select)f=this._getOffsetToX(d);c.extend(this._getXToOffset(e-1,f)),a.select||c.collapse(),this._setSelection(c,!0,!0),this._columnX=f}return!0},_doPageDown:function(a){var b=this._model,c=this._getSelection(),d=c.getCaret(),e=b.getLineAtOffset(d),f=b.getLineCount();if(e<f-1){var g=this._getClientHeight(),h=this._getLineHeight(),i=Math.floor(g/h),j=Math.min(f-e-1,i);j=Math.max(1,j);var k=this._columnX;if(k===-1||a.select)k=this._getOffsetToX(d);c.extend(this._getXToOffset(e+j,k)),a.select||c.collapse(),this._setSelection(c,!1,!1);var l=f*h,m=this._getScroll().y,n=m+j*h;n+g>l&&(n=l-g),n>m?this._scrollView(0,n-m):this._updateDOMSelection(),this._columnX=k}return!0},_doPageUp:function(a){var b=this._model,c=this._getSelection(),d=c.getCaret(),e=b.getLineAtOffset(d);if(e>0){var f=this._getClientHeight(),g=this._getLineHeight(),h=Math.floor(f/g),i=Math.max(1,Math.min(e,h)),j=this._columnX;if(j===-1||a.select)j=this._getOffsetToX(d);c.extend(this._getXToOffset(e-i,j)),a.select||c.collapse(),this._setSelection(c,!1,!1);var k=this._getScroll().y,l=Math.max(0,k-i*g);l<k?this._scrollView(0,l-k):this._updateDOMSelection(),this._columnX=j}return!0},_doPaste:function(a){var b=this._getClipboardText(a);b&&this._doContent(b);return b!==null},_doScroll:function(a){var b=this._hScroll,c=this._vScroll;if(b!==a.x||c!==a.y){this._hScroll=a.x,this._vScroll=a.y,this._commitIME(),this._updatePage();var d={oldValue:{x:b,y:c},newValue:a};this.onScroll(d)}},_doSelectAll:function(a){var b=this._model,c=this._getSelection();c.setCaret(0),c.extend(b.getCharCount()),this._setSelection(c,!1);return!0},_doTab:function(a){this._doContent("\t");return!0},_applyStyle:function(a,b){if(!!a){a.styleClass&&(b.className=a.styleClass);var c=a.style;if(c)for(var d in c)c.hasOwnProperty(d)&&(b.style[d]=c[d])}},_autoScroll:function(){var a=this._getSelection(),b,c=this._autoScrollX;if(this._autoScrollDir==="up"||this._autoScrollDir==="down"){var d=this._autoScrollY/this._getLineHeight();d=d<0?Math.floor(d):Math.ceil(d),b=this._model.getLineAtOffset(a.getCaret()),b=Math.max(0,Math.min(this._model.getLineCount()-1,b+d))}else if(this._autoScrollDir==="left"||this._autoScrollDir==="right")b=this._getYToLine(this._autoScrollY),c+=this._getOffsetToX(a.getCaret());a.extend(this._getXToOffset(b,c)),this._setSelection(a,!0)},_autoScrollTimer:function(){this._autoScroll();var a=this;this._autoScrollTimerID=setTimeout(function(){a._autoScrollTimer()},this._AUTO_SCROLL_RATE)},_calculateLineHeight:function(){var a=this._clientDiv,b=this._frameDocument,c=" ",d=b.createElement("DIV");d.style.position="fixed",d.style.left="-1000px";var e=b.createElement("SPAN");e.appendChild(b.createTextNode(c)),d.appendChild(e);var f=b.createElement("SPAN");f.style.fontStyle="italic",f.appendChild(b.createTextNode(c)),d.appendChild(f);var g=b.createElement("SPAN");g.style.fontWeight="bold",g.appendChild(b.createTextNode(c)),d.appendChild(g);var h=b.createElement("SPAN");h.style.fontWeight="bold",h.style.fontStyle="italic",h.appendChild(b.createTextNode(c)),d.appendChild(h),a.appendChild(d);var i=e.getBoundingClientRect(),j=f.getBoundingClientRect(),k=g.getBoundingClientRect(),l=h.getBoundingClientRect(),m=i.bottom-i.top,n=j.bottom-j.top,o=k.bottom-k.top,p=l.bottom-l.top,q=0,r=m;n>m&&(r=n,q=1),o>n&&(r=o,q=2),p>o&&(r=p,q=3),this._largestFontStyle=q,a.removeChild(d);return r},_calculatePadding:function(){var a=this._frameDocument,b=this._clientDiv,c=this._getPadding(this._editorDiv),d=a.createElement("DIV");d.style.position="fixed",d.style.left="-1000px",d.style.paddingLeft=c.left+"px",d.style.paddingTop=c.top+"px",d.style.paddingRight=c.right+"px",d.style.paddingBottom=c.bottom+"px",d.style.width="100px",d.style.height="100px";var e=a.createElement("DIV");e.style.width="100%",e.style.height="100%",d.appendChild(e),b.appendChild(d);var f=d.getBoundingClientRect(),g=e.getBoundingClientRect();b.removeChild(d),c={left:g.left-f.left,top:g.top-f.top,right:f.right-g.right,bottom:f.bottom-g.bottom};return c},_clearSelection:function(a){var b=this._getSelection();if(b.isEmpty())return!1;a==="next"?b.start=b.end:b.end=b.start,this._setSelection(b,!0);return!0},_commitIME:function(){if(this._imeOffset!==-1){this._scrollDiv.focus(),this._clientDiv.focus();var a=this._model,b=a.getLineAtOffset(this._imeOffset),c=a.getLineStart(b),d=this._getDOMText(b),e=a.getLine(b),f=this._imeOffset-c,g=f+d.length-e.length;if(f!==g){var h=d.substring(f,g);this._doContent(h)}this._imeOffset=-1}},_createActions:function(){var a=eclipse.KeyBinding,b=this._keyBindings=[];b.push({name:"lineUp",keyBinding:new a(38),predefined:!0}),b.push({name:"lineDown",keyBinding:new a(40),predefined:!0}),b.push({name:"charPrevious",keyBinding:new a(37),predefined:!0}),b.push({name:"charNext",keyBinding:new a(39),predefined:!0}),b.push({name:"pageUp",keyBinding:new a(33),predefined:!0}),b.push({name:"pageDown",keyBinding:new a(34),predefined:!0}),j?(b.push({name:"lineStart",keyBinding:new a(37,!0),predefined:!0}),b.push({name:"lineEnd",keyBinding:new a(39,!0),predefined:!0}),b.push({name:"wordPrevious",keyBinding:new a(37,null,null,!0),predefined:!0}),b.push({name:"wordNext",keyBinding:new a(39,null,null,!0),predefined:!0}),b.push({name:"textStart",keyBinding:new a(36),predefined:!0}),b.push({name:"textEnd",keyBinding:new a(35),predefined:!0}),b.push({name:"textStart",keyBinding:new a(38,!0),predefined:!0}),b.push({name:"textEnd",keyBinding:new a(40,!0),predefined:!0})):(b.push({name:"lineStart",keyBinding:new a(36),predefined:!0}),b.push({name:"lineEnd",keyBinding:new a(35),predefined:!0}),b.push({name:"wordPrevious",keyBinding:new a(37,!0),predefined:!0}),b.push({name:"wordNext",keyBinding:new a(39,!0),predefined:!0}),b.push({name:"textStart",keyBinding:new a(36,!0),predefined:!0}),b.push({name:"textEnd",keyBinding:new a(35,!0),predefined:!0})),b.push({name:"selectLineUp",keyBinding:new a(38,null,!0),predefined:!0}),b.push({name:"selectLineDown",keyBinding:new a(40,null,!0),predefined:!0}),b.push({name:"selectCharPrevious",keyBinding:new a(37,null,!0),predefined:!0}),b.push({name:"selectCharNext",keyBinding:new a(39,null,!0),predefined:!0}),b.push({name:"selectPageUp",keyBinding:new a(33,null,!0),predefined:!0}),b.push({name:"selectPageDown",keyBinding:new a(34,null,!0),predefined:!0}),j?(b.push({name:"selectLineStart",keyBinding:new a(37,!0,!0),predefined:!0}),b.push({name:"selectLineEnd",keyBinding:new a(39,!0,!0),predefined:!0}),b.push({name:"selectWordPrevious",keyBinding:new a(37,null,!0,!0),predefined:!0}),b.push({name:"selectWordNext",keyBinding:new a(39,null,!0,!0),predefined:!0}),b.push({name:"selectTextStart",keyBinding:new a(36,null,!0),predefined:!0}),b.push({name:"selectTextEnd",keyBinding:new a(35,null,!0),predefined:!0}),b.push({name:"selectTextStart",keyBinding:new a(38,!0,!0),predefined:!0}),b.push({name:"selectTextEnd",keyBinding:new a(40,!0,!0),predefined:!0})):(b.push({name:"selectLineStart",keyBinding:new a(36,null,!0),predefined:!0}),b.push({name:"selectLineEnd",keyBinding:new a(35,null,!0),predefined:!0}),b.push({name:"selectWordPrevious",keyBinding:new a(37,!0,!0),predefined:!0}),b.push({name:"selectWordNext",keyBinding:new a(39,!0,!0),predefined:!0}),b.push({name:"selectTextStart",keyBinding:new a(36,!0,!0),predefined:!0}),b.push({name:"selectTextEnd",keyBinding:new a(35,!0,!0),predefined:!0})),b.push({name:"deletePrevious",keyBinding:new a(8),predefined:!0}),b.push({name:"deletePrevious",keyBinding:new a(8,null,!0),predefined:!0}),b.push({name:"deleteNext",keyBinding:new a(46),predefined:!0}),b.push({name:"deleteWordPrevious",keyBinding:new a(8,!0),predefined:!0}),b.push({name:"deleteWordPrevious",keyBinding:new a(8,!0,!0),predefined:!0}),b.push({name:"deleteWordNext",keyBinding:new a(46,!0),predefined:!0}),b.push({name:"tab",keyBinding:new a(9),predefined:!0}),b.push({name:"enter",keyBinding:new a(13),predefined:!0}),b.push({name:"selectAll",keyBinding:new a("a",!0),predefined:!0}),j&&(b.push({name:"deleteNext",keyBinding:new a(46,null,!0),predefined:!0}),b.push({name:"deleteWordPrevious",keyBinding:new a(8,null,null,!0),predefined:!0}),b.push({name:"deleteWordNext",keyBinding:new a(46,null,null,!0),predefined:!0}));var c=j&&f;b.push({name:null,keyBinding:new a("u",!c,!1,!1,c),predefined:!0}),b.push({name:null,keyBinding:new a("i",!c,!1,!1,c),predefined:!0}),b.push({name:null,keyBinding:new a("b",!c,!1,!1,c),predefined:!0}),d&&(b.push({name:"copy",keyBinding:new a(45,!0),predefined:!0}),b.push({name:"paste",keyBinding:new a(45,null,!0),predefined:!0}),b.push({name:"cut",keyBinding:new a(46,null,!0),predefined:!0}));var e=this;this._actions=[{name:"lineUp",defaultHandler:function(){return e._doLineUp({select:!1})}},{name:"lineDown",defaultHandler:function(){return e._doLineDown({select:!1})}},{name:"lineStart",defaultHandler:function(){return e._doHome({select:!1,ctrl:!1})}},{name:"lineEnd",defaultHandler:function(){return e._doEnd({select:!1,ctrl:!1})}},{name:"charPrevious",defaultHandler:function(){return e._doCursorPrevious({select:!1,unit:"character"})}},{name:"charNext",defaultHandler:function(){return e._doCursorNext({select:!1,unit:"character"})}},{name:"pageUp",defaultHandler:function(){return e._doPageUp({select:!1})}},{name:"pageDown",defaultHandler:function(){return e._doPageDown({select:!1})}},{name:"wordPrevious",defaultHandler:function(){return e._doCursorPrevious({select:!1,unit:"word"})}},{name:"wordNext",defaultHandler:function(){return e._doCursorNext({select:!1,unit:"word"})}},{name:"textStart",defaultHandler:function(){return e._doHome({select:!1,ctrl:!0})}},{name:"textEnd",defaultHandler:function(){return e._doEnd({select:!1,ctrl:!0})}},{name:"selectLineUp",defaultHandler:function(){return e._doLineUp({select:!0})}},{name:"selectLineDown",defaultHandler:function(){return e._doLineDown({select:!0})}},{name:"selectLineStart",defaultHandler:function(){return e._doHome({select:!0,ctrl:!1})}},{name:"selectLineEnd",defaultHandler:function(){return e._doEnd({select:!0,ctrl:!1})}},{name:"selectCharPrevious",defaultHandler:function(){return e._doCursorPrevious({select:!0,unit:"character"})}},{name:"selectCharNext",defaultHandler:function(){return e._doCursorNext({select:!0,unit:"character"})}},{name:"selectPageUp",defaultHandler:function(){return e._doPageUp({select:!0})}},{name:"selectPageDown",defaultHandler:function(){return e._doPageDown({select:!0})}},{name:"selectWordPrevious",defaultHandler:function(){return e._doCursorPrevious({select:!0,unit:"word"})}},{name:"selectWordNext",defaultHandler:function(){return e._doCursorNext({select:!0,unit:"word"})}},{name:"selectTextStart",defaultHandler:function(){return e._doHome({select:!0,ctrl:!0})}},{name:"selectTextEnd",defaultHandler:function(){return e._doEnd({select:!0,ctrl:!0})}},{name:"deletePrevious",defaultHandler:function(){return e._doBackspace({unit:"character"})}},{name:"deleteNext",defaultHandler:function(){return e._doDelete({unit:"character"})}},{name:"deleteWordPrevious",defaultHandler:function(){return e._doBackspace({unit:"word"})}},{name:"deleteWordNext",defaultHandler:function(){return e._doDelete({unit:"word"})}},{name:"tab",defaultHandler:function(){return e._doTab()}},{name:"enter",defaultHandler:function(){return e._doEnter()}},{name:"selectAll",defaultHandler:function(){return e._doSelectAll()}},{name:"copy",defaultHandler:function(){return e._doCopy()}},{name:"cut",defaultHandler:function(){return e._doCut()}},{name:"paste",defaultHandler:function(){return e._doPaste()}}]},_createLine:function(a,b,f,g,i){var j=i.getLine(g),k=i.getLineStart(g),l={lineIndex:g,lineText:j,lineStart:k};this.onLineStyle(l);var m=f.createElement("DIV");m.lineIndex=g,this._applyStyle(l.style,m);if(j.length!==0){var n=0,o=this._tabSize;if(o&&o!==8){var p=j.indexOf("\t"),q=0;while(p!==-1){this._createRange(m,f,l.ranges,n,p,j,k);var r=o-(p+q)%o,s=" ";for(var t=1;t<r;t++)s+=" ";var u=f.createElement("SPAN");u.appendChild(f.createTextNode(s)),u.ignoreChars=r-1,q+=u.ignoreChars;if(l.ranges)for(var v=0;v<l.ranges.length;v++){var w=l.ranges[v],x=w.start-k,y=w.end-k;if(x>p)break;if(x<=p&&p<y){this._applyStyle(w.style,u);break}}m.appendChild(u),n=p+1,p=j.indexOf("\t",n)}}this._createRange(m,f,l.ranges,n,j.length,j,k)}var z=f.createElement("SPAN");z.ignoreChars=1,(this._largestFontStyle&1)!==0&&(z.style.fontStyle="italic"),(this._largestFontStyle&2)!==0&&(z.style.fontWeight="bold");var A=this._fullSelection,B=!A&&(d||e||c>=9),C=B?" ":h||d?"‌":"﻿";z.appendChild(f.createTextNode(C)),m.appendChild(z),a.insertBefore(m,b);return m},_createRange:function(a,b,c,d,e,f,g){if(!(d>=e)){var h;if(c)for(var i=0;i<c.length;i++){var j=c[i];if(j.end<=g+d)continue;var k=Math.max(g+d,j.start)-g;if(k>=e)break;var l=Math.min(g+e,j.end)-g;k<l&&(k=Math.max(d,k),l=Math.min(e,l),d<k&&(h=b.createElement("SPAN"),h.appendChild(b.createTextNode(f.substring(d,k))),a.appendChild(h)),h=b.createElement("SPAN"),h.appendChild(b.createTextNode(f.substring(k,l))),this._applyStyle(j.style,h),a.appendChild(h),d=l)}d<e&&(h=b.createElement("SPAN"),h.appendChild(b.createTextNode(f.substring(d,e))),a.appendChild(h))}},_doAutoScroll:function(a,b,c){this._autoScrollDir=a,this._autoScrollX=b,this._autoScrollY=c,this._autoScrollTimerID||this._autoScrollTimer()},_endAutoScroll:function(){this._autoScrollTimerID&&clearTimeout(this._autoScrollTimerID),this._autoScrollDir=undefined,this._autoScrollTimerID=undefined},_getBoundsAtOffset:function(a){var b=this._model,d=this._frameDocument,e=this._clientDiv,f=b.getLineAtOffset(a),g,h=this._getLineNode(f);h||(h=g=this._createLine(e,null,d,f,b));var i=null;if(a<b.getLineEnd(f)){var j=b.getLineStart(f),k=h.firstChild;while(k){var l=k.firstChild,m=l.length;k.ignoreChars&&(m-=k.ignoreChars);if(j+m>a){var o=a-j,p;if(n)p=d.createRange(),p.setStart(l,o),p.setEnd(l,o+1),i=p.getBoundingClientRect();else if(c)p=d.body.createTextRange(),p.moveToElementText(k),p.collapse(),p.moveEnd("character",o+1),p.moveStart("character",o),i=p.getBoundingClientRect();else{var q=l.data;k.removeChild(l),k.appendChild(d.createTextNode(q.substring(0,o)));var r=d.createElement("SPAN");r.appendChild(d.createTextNode(q.substring(o,o+1))),k.appendChild(r),k.appendChild(d.createTextNode(q.substring(o+1))),i=r.getBoundingClientRect(),k.innerHTML="",k.appendChild(l);if(!g){var s=this._getSelection();(j<=s.start&&s.start<j+m||j<=s.end&&s.end<j+m)&&this._updateDOMSelection()}}if(c){var t=window.screen.logicalXDPI,u=window.screen.deviceXDPI;i.left=i.left*t/u,i.right=i.right*t/u}break}j+=m,k=k.nextSibling}}if(!i){var v=this._getLineBoundingClientRect(h);i={left:v.right,right:v.right}}g&&e.removeChild(g);return i},_getBottomIndex:function(a){var b=this._bottomChild;if(a&&this._getClientHeight()>this._getLineHeight()){var c=b.getBoundingClientRect(),d=this._clientDiv.getBoundingClientRect();c.bottom>d.bottom&&(b=this._getLinePrevious(b)||b)}return b.lineIndex},_getFrameHeight:function(){return this._frameDocument.documentElement.clientHeight},_getFrameWidth:function(){return this._frameDocument.documentElement.clientWidth},_getClientHeight:function(){var a=this._getEditorPadding();return Math.max(0,this._editorDiv.clientHeight-a.top-a.bottom)},_getClientWidth:function(){var a=this._getEditorPadding();return Math.max(0,this._editorDiv.clientWidth-a.left-a.right)},_getClipboardText:function(a){if(this._frameWindow.clipboardData)return this._frameWindow.clipboardData.getData("Text");if(d){var b=this._frameWindow,c=this._frameDocument,e=c.createElement("PRE");e.style.position="fixed",e.style.left="-1000px",e.appendChild(c.createTextNode(" ")),this._clientDiv.appendChild(e);var f=c.createRange();f.selectNodeContents(e);var g=b.getSelection();g.rangeCount>0&&g.removeAllRanges(),g.addRange(f);var h=this,i=function(){h._updateDOMSelection(),h._clientDiv.removeChild(e)},j=this._model.getLineDelimiter(),k=function(){var a=null;g.anchorNode.nodeType!==e.TEXT_NODE&&(a=g.anchorNode.childNodes[g.anchorOffset]);var b=[],c=function(d){var f=d.firstChild;while(f!==a)f.nodeType===e.TEXT_NODE?b.push(f!==g.anchorNode?f.data:f.data.substring(0,g.anchorOffset)):f.tagName==="BR"?b.push(j):c(f),f=f.nextSibling};c(e),i();return b.join("")},l=!1;this._ignorePaste=!0;try{l=c.execCommand("paste",!1,null)}catch(m){}this._ignorePaste=!1;if(!l){if(a){setTimeout(function(){var a=k();a&&h._doContent(a)},0);return null}i();return""}return k()}if(a&&a.clipboardData)return a.clipboardData.getData("text/plain");return""},_getDOMText:function(a){var b=this._getLineNode(a),c=b.firstChild,d="";while(c){var e=c.firstChild;while(e){if(c.ignoreChars)for(var f=0;f<e.length;f++){var g=e.data.substring(f,f+1);g!==" "&&(d+=g)}else d+=e.data;e=e.nextSibling}c=c.nextSibling}return d},_getEditorPadding:function(){return this._editorPadding},_getLineBoundingClientRect:function(a){var b=a.getBoundingClientRect(),c=a.lastChild;while(c&&c.ignoreChars===c.firstChild.length)c=c.previousSibling;if(!c)return{left:b.left,top:b.top,right:b.left,bottom:b.bottom};var d=c.getBoundingClientRect();return{left:b.left,top:b.top,right:d.right,bottom:b.bottom}},_getLineHeight:function(){return this._lineHeight},_getLineNode:function(a){var b=this._clientDiv,c=b.firstChild;while(c){if(a===c.lineIndex)return c;c=c.nextSibling}return undefined},_getLineNext:function(a){var b=a?a.nextSibling:this._clientDiv.firstChild;while(b&&b.lineIndex===-1)b=b.nextSibling;return b},_getLinePrevious:function(a){var b=a?a.previousSibling:this._clientDiv.lastChild;while(b&&b.lineIndex===-1)b=b.previousSibling;return b},_getOffset:function(a,b,d){if(b==="wordend")return this._getOffset_W3C(a,b,d);return c?this._getOffset_IE(a,b,d):this._getOffset_W3C(a,b,d)},_getOffset_W3C:function(a,b,c){function e(a){return a===32||a===9}function d(a){return 33<=a&&a<=47||58<=a&&a<=64||91<=a&&a<=94||a===96||123<=a&&a<=126}if(b==="word"||b==="wordend"){var f=this._model,g=f.getLineAtOffset(a),h=f.getLine(g),i=f.getLineStart(g),j=f.getLineEnd(g),k=h.length,l=a-i,m,n,o,p,q;if(c>0){if(l===k)return j;m=h.charCodeAt(l),n=d(m),o=!n&&!e(m),l++;while(l<k){m=h.charCodeAt(l),p=d(m);if(b==="wordend"){if(!p&&n)break}else if(p&&!n)break;q=!p&&!e(m);if(b==="wordend"){if(!q&&o)break}else if(q&&!o)break;o=q,n=p,l++}}else{if(l===0)return i;l--,m=h.charCodeAt(l),n=d(m),o=!n&&!e(m);while(0<l){m=h.charCodeAt(l-1),p=d(m);if(b==="wordend"){if(p&&!n)break}else if(!p&&n)break;q=!p&&!e(m);if(b==="wordend"){if(q&&!o)break}else if(!q&&o)break;o=q,n=p,l--}}return i+l}return a+c},_getOffset_IE:function(a,b,c){var d=this._frameDocument,e=this._model,f=e.getLineAtOffset(a),g=this._clientDiv,h,i=this._getLineNode(f);i||(i=h=this._createLine(g,null,d,f,e));var j=0,k,l,m=e.getLineStart(f);if(a===e.getLineEnd(f))k=d.body.createTextRange(),k.moveToElementText(i.lastChild),l=k.text.length,k.moveEnd(b,c),j=a+k.text.length-l;else if(a===m&&c<0)j=m;else{var n=i.firstChild;while(n){var o=n.firstChild,p=o.length;n.ignoreChars&&(p-=n.ignoreChars);if(m+p>a){k=d.body.createTextRange(),a===m&&c<0?k.moveToElementText(n.previousSibling):(k.moveToElementText(n),k.collapse(),k.moveEnd("character",a-m)),l=k.text.length,k.moveEnd(b,c),j=a+k.text.length-l;break}m=p+m,n=n.nextSibling}}h&&g.removeChild(h);return j},_getOffsetToX:function(a){return this._getBoundsAtOffset(a).left},_getPadding:function(a){var b,c,d,e;if(a.currentStyle)b=a.currentStyle.paddingLeft,c=a.currentStyle.paddingTop,d=a.currentStyle.paddingRight,e=a.currentStyle.paddingBottom;else if(this._frameWindow.getComputedStyle){var f=this._frameWindow.getComputedStyle(a,null);b=f.getPropertyValue("padding-left"),c=f.getPropertyValue("padding-top"),d=f.getPropertyValue("padding-right"),e=f.getPropertyValue("padding-bottom")}return{left:parseInt(b,10),top:parseInt(c,10),right:parseInt(d,10),bottom:parseInt(e,10)}},_getScroll:function(){var a=this._editorDiv;return{x:a.scrollLeft,y:a.scrollTop}},_getSelection:function(){return this._selection.clone()},_getTopIndex:function(a){var b=this._topChild;if(a&&this._getClientHeight()>this._getLineHeight()){var c=b.getBoundingClientRect(),d=this._getEditorPadding(),e=this._editorDiv.getBoundingClientRect();c.top<e.top+d.top&&(b=this._getLineNext(b)||b)}return b.lineIndex},_getXToOffset:function(a,b){function r(a){var b,c,d,e;if(!a._rectsCache){b=a.getClientRects(),c=[b.length];for(d=0;d<b.length;d++)e=b[d],c[d]={left:e.left-l+q,top:e.top,right:e.right-l+q,bottom:e.bottom};a._rectsCache=c}b=a._rectsCache,c=[b.length];for(d=0;d<b.length;d++)e=b[d],c[d]={left:e.left-q,top:e.top,right:e.right-q,bottom:e.bottom};return c}var d=this._model,e=d.getLineStart(a),f=d.getLineEnd(a);if(e===f)return e;var g=this._frameDocument,h=this._clientDiv,i,j=this._getLineNode(a);j||(j=i=this._createLine(h,null,g,a,d));var k=this._getLineBoundingClientRect(j);b<k.left&&(b=k.left),b>k.right&&(b=k.right);var l=0,m;if(c<9){m=j.getClientRects();var o=m[0].left;for(var p=1;p<m.length;p++)o=Math.min(m[p].left,o);l=o-k.left}var q=this._getScroll().x,s=c?window.screen.logicalXDPI:1,t=c?window.screen.deviceXDPI:1,u=e,v=j.firstChild;done:while(v){var w=v.firstChild,x=w.length;v.ignoreChars&&(x-=v.ignoreChars),m=r(v);for(var y=0;y<m.length;y++){var z=m[y];if(z.left<=b&&b<z.right){var A,B,C;if(c||n){A=n?g.createRange():g.body.createTextRange();var D=x,E=-1;while(D-E>1){var F=Math.floor((D+E)/2);B=E+1,C=F===x-1&&v.ignoreChars?w.length:F+1,n?(A.setStart(w,B),A.setEnd(w,C)):(A.moveToElementText(v),A.move("character",B),A.moveEnd("character",C-B)),m=A.getClientRects();var G=!1;for(var H=0;H<m.length;H++){z=m[H];var I=z.left*s/t-l,J=z.right*s/t-l;if(I<=b&&b<J){G=!0;break}}G?D=F:E=F}u+=D,B=D,C=D===x-1&&v.ignoreChars?w.length:D+1,n?(A.setStart(w,B),A.setEnd(w,C)):(A.moveToElementText(v),A.move("character",B),A.moveEnd("character",C-B)),z=A.getClientRects()[0],b>z.left*s/t-l+(z.right-z.left)*s/t/2&&u++}else{var K=[];for(var L=0;L<x;L++)K.push("<span>"),L===x-1?K.push(w.data.substring(L)):K.push(w.data.substring(L,L+1)),K.push("</span>");v.innerHTML=K.join("");var M=v.firstChild;while(M){z=M.getBoundingClientRect();if(z.left<=b&&b<z.right){b>z.left+(z.right-z.left)/2&&u++;break}u++,M=M.nextSibling}if(!i){v.innerHTML="",v.appendChild(w);var N=this._getSelection();(u<=N.start&&N.start<u+x||u<=N.end&&N.end<u+x)&&this._updateDOMSelection()}}break done}}u+=x,v=v.nextSibling}i&&h.removeChild(i);return Math.min(f,Math.max(e,u))},_getYToLine:function(a){var b=this._getEditorPadding(),c=this._editorDiv.getBoundingClientRect();a-=c.top+b.top;var d=this._getLineHeight(),e=Math.floor((a+this._getScroll().y)/d),f=this._model.getLineCount();return Math.max(0,Math.min(f-1,e))},_getOffsetBounds:function(a){var b=this._model,c=b.getLineAtOffset(a),d=this._getLineHeight(),e=this._getScroll(),f=this._getEditorPadding(),g=this._editorDiv.getBoundingClientRect(),h=this._getBoundsAtOffset(a),i=h.left,j=h.right,k=c*d-e.y+g.top+f.top,l=k+d;return{left:i,top:k,right:j,bottom:l}},_hitOffset:function(a,b,c){var d=this._getOffsetBounds(a),e=d.left,f=d.right,g=d.top,h=d.bottom,i=20;e-=i,g-=i,f+=i,h+=i;return e<=b&&b<=f&&g<=c&&c<=h},_hookEvents:function(){var b=this;this._modelListener={onChanging:function(a,c,d,e,f,g){b._onModelChanging(a,c,d,e,f,g)},onChanged:function(a,c,d,e,f){b._onModelChanged(a,c,d,e,f)}},this._model.addListener(this._modelListener),this._mouseMoveClosure=function(a){return b._handleMouseMove(a)},this._mouseUpClosure=function(a){return b._handleMouseUp(a)};var f=this._clientDiv,g=this._editorDiv,h=this._frameDocument.body,j=this._handlers=[],l=c<9?this._frame:this._frameWindow,n=i?this._textArea:c||d?this._clientDiv:this._frameWindow;j.push({target:l,type:"resize",handler:function(a){return b._handleResize(a)}}),j.push({target:n,type:"blur",handler:function(a){return b._handleBlur(a)}}),j.push({target:n,type:"focus",handler:function(a){return b._handleFocus(a)}}),j.push({target:g,type:"scroll",handler:function(a){return b._handleScroll(a)}});if(i){var o=this._touchDiv,p=this._textArea;j.push({target:p,type:"keydown",handler:function(a){return b._handleKeyDown(a)}}),j.push({target:p,type:"input",handler:function(a){return b._handleInput(a)}}),j.push({target:p,type:"textInput",handler:function(a){return b._handleTextInput(a)}}),j.push({target:o,type:"touchstart",handler:function(a){return b._handleTouchStart(a)}}),j.push({target:o,type:"touchmove",handler:function(a){return b._handleTouchMove(a)}}),j.push({target:o,type:"touchend",handler:function(a){return b._handleTouchEnd(a)}})}else{var q=this._overlayDiv||this._clientDiv;j.push({target:f,type:"keydown",handler:function(a){return b._handleKeyDown(a)}}),j.push({target:f,type:"keypress",handler:function(a){return b._handleKeyPress(a)}}),j.push({target:f,type:"keyup",handler:function(a){return b._handleKeyUp(a)}}),j.push({target:f,type:"selectstart",handler:function(a){return b._handleSelectStart(a)}}),j.push({target:f,type:"contextmenu",handler:function(a){return b._handleContextMenu(a)}}),j.push({target:f,type:"copy",handler:function(a){return b._handleCopy(a)}}),j.push({target:f,type:"cut",handler:function(a){return b._handleCut(a)}}),j.push({target:f,type:"paste",handler:function(a){return b._handlePaste(a)}}),j.push({target:q,type:"mousedown",handler:function(a){return b._handleMouseDown(a)}}),j.push({target:h,type:"mousedown",handler:function(a){return b._handleBodyMouseDown(a)}}),j.push({target:q,type:"dragstart",handler:function(a){return b._handleDragStart(a)}}),j.push({target:q,type:"dragover",handler:function(a){return b._handleDragOver(a)}}),j.push({target:q,type:"drop",handler:function(a){return b._handleDrop(a)}}),c&&j.push({target:this._frameDocument,type:"activate",handler:function(a){return b._handleDocFocus(a)}}),d&&j.push({target:this._frameDocument,type:"focus",handler:function(a){return b._handleDocFocus(a)}});if(!c&&!e){var r=d?"DOMMouseScroll":"mousewheel";j.push({target:this._editorDiv,type:r,handler:function(a){return b._handleMouseWheel(a)}})}d&&!k&&j.push({target:this._clientDiv,type:"DOMCharacterDataModified",handler:function(a){return b._handleDataModified(a)}}),this._overlayDiv&&j.push({target:this._overlayDiv,type:"contextmenu",handler:function(a){return b._handleContextMenu(a)}}),m||j.push({target:this._clientDiv,type:"dblclick",handler:function(a){return b._handleDblclick(a)}}),j.push({target:q,type:"contextmenu",handler:function(a){return b.onContextMenu(a||window.event)}})}for(var s=0;s<j.length;s++){var t=j[s];a(t.target,t.type,t.handler,t.capture)}},_init:function(a){var b=a.parent;typeof b=="string"&&(b=window.document.getElementById(b));if(!b)throw"no parent";this._parent=b,this._model=a.model?a.model:new eclipse.TextModel,this.readonly=a.readonly===!0,this._selection=new o(0,0,!1),this._eventTable=new p,this._maxLineWidth=0,this._maxLineIndex=-1,this._ignoreSelect=!0,this._columnX=-1,this._autoScrollX=null,this._autoScrollY=null,this._autoScrollTimerID=null,this._AUTO_SCROLL_RATE=50,this._grabControl=null,this._moseMoveClosure=null,this._mouseUpClosure=null,this._lastMouseX=0,this._lastMouseY=0,this._lastMouseTime=0,this._clickCount=0,this._clickTime=250,this._clickDist=5,this._isMouseDown=!1,this._doubleClickSelection=null,this._hScroll=0,this._vScroll=0,this._imeOffset=-1;while(b.hasChildNodes())b.removeChild(b.lastChild);var f=b.document||b.ownerDocument;this._parentDocument=f;var g=f.createElement("IFRAME");this._frame=g,g.frameBorder="0px",g.style.width="100%",g.style.height="100%",g.scrolling="no",g.style.border="0px",b.appendChild(g);var k=[];k.push("<!DOCTYPE html>"),k.push("<html>"),k.push("<head>"),c<9&&k.push("<meta http-equiv='X-UA-Compatible' content='IE=EmulateIE7'/>"),k.push("<style>"),k.push(".editorContainer {font-family: monospace; font-size: 10pt;}"),k.push(".editor {padding: 1px 2px;}"),k.push(".editorContent {}"),k.push("</style>");if(a.stylesheet){var l=typeof a.stylesheet=="string"?[a.stylesheet]:a.stylesheet;for(var m=0;m<l.length;m++)try{var n=new XMLHttpRequest;n.open("GET",l[m],!1),n.send(null),k.push("<style>"),k.push(n.responseText),k.push("</style>")}catch(q){k.push("<link rel='stylesheet' type='text/css' href='"),k.push(l[m]),k.push("'></link>")}}k.push("</head>"),k.push("<body spellcheck='false'></body>"),k.push("</html>");var r=g.contentWindow;this._frameWindow=r;var s=r.document;this._frameDocument=s,s.open(),s.write(k.join("")),s.close();var t=s.body;t.className="editorContainer",t.style.margin="0px",t.style.borderWidth="0px",t.style.padding="0px";if(i){var u=f.createElement("DIV");this._touchDiv=u,u.style.position="absolute",u.style.border="0px",u.style.padding="0px",u.style.margin="0px",u.style.zIndex="2",u.style.overflow="hidden",u.style.background="transparent",u.style.WebkitUserSelect="none",b.appendChild(u);var v=f.createElement("TEXTAREA");this._textArea=v,v.style.position="absolute",v.style.whiteSpace="pre",v.style.left="-1000px",v.tabIndex=1,v.autocapitalize=!1,v.autocorrect=!1,v.className="editorContainer",v.style.background="transparent",v.style.color="transparent",v.style.border="0px",v.style.padding="0px",v.style.margin="0px",v.style.borderRadius="0px",v.style.WebkitAppearance="none",v.style.WebkitTapHighlightColor="transparent",u.appendChild(v)}var w=s.createElement("DIV");w.className="editor",this._editorDiv=w,w.id="editorDiv",w.tabIndex=-1,w.style.overflow="auto",w.style.position="absolute",w.style.top="0px",w.style.borderWidth="0px",w.style.margin="0px",w.style.MozOutline="none",w.style.outline="none",t.appendChild(w);var x=s.createElement("DIV");this._scrollDiv=x,x.id="scrollDiv",x.style.margin="0px",x.style.borderWidth="0px",x.style.padding="0px",w.appendChild(x),this._fullSelection=a.fullSelection===undefined||a.fullSelection;if(i||this._fullSelection&&!h){this._hightlightRGB="Highlight";var y=s.createElement("DIV");this._selDiv1=y,y.id="selDiv1",y.style.position="fixed",y.style.borderWidth="0px",y.style.margin="0px",y.style.padding="0px",y.style.MozOutline="none",y.style.outline="none",y.style.background=this._hightlightRGB,y.style.width="0px",y.style.height="0px",x.appendChild(y);var z=s.createElement("DIV");this._selDiv2=z,z.id="selDiv2",z.style.position="fixed",z.style.borderWidth="0px",z.style.margin="0px",z.style.padding="0px",z.style.MozOutline="none",z.style.outline="none",z.style.background=this._hightlightRGB,z.style.width="0px",z.style.height="0px",x.appendChild(z);var A=s.createElement("DIV");this._selDiv3=A,A.id="selDiv3",A.style.position="fixed",A.style.borderWidth="0px",A.style.margin="0px",A.style.padding="0px",A.style.MozOutline="none",A.style.outline="none",A.style.background=this._hightlightRGB,A.style.width="0px",A.style.height="0px",x.appendChild(A);if(d&&j){var B=r.getComputedStyle(A,null),C=B.getPropertyValue("background-color");switch(C){case"rgb(119, 141, 168)":C="rgb(199, 208, 218)";break;case"rgb(127, 127, 127)":C="rgb(198, 198, 198)";break;case"rgb(255, 193, 31)":C="rgb(250, 236, 115)";break;case"rgb(243, 70, 72)":C="rgb(255, 176, 139)";break;case"rgb(255, 138, 34)":C="rgb(255, 209, 129)";break;case"rgb(102, 197, 71)":C="rgb(194, 249, 144)";break;case"rgb(140, 78, 184)":C="rgb(232, 184, 255)";break;default:C="rgb(180, 213, 255)"}this._hightlightRGB=C,y.style.background=C,z.style.background=C,A.style.background=C;var D=s.styleSheets[0];D.insertRule("::-moz-selection {background: "+C+"; }",0)}}var E=s.createElement("DIV");E.className="editorContent",this._clientDiv=E,E.id="clientDiv",E.style.whiteSpace="pre",E.style.position="fixed",E.style.borderWidth="0px",E.style.margin="0px",E.style.padding="0px",E.style.MozOutline="none",E.style.outline="none",i&&(E.style.WebkitTapHighlightColor="transparent"),x.appendChild(E);if(d){var F=s.createElement("DIV");this._overlayDiv=F,F.id="overlayDiv",F.style.position=E.style.position,F.style.borderWidth=E.style.borderWidth,F.style.margin=E.style.margin,F.style.padding=E.style.padding,F.style.cursor="text",F.style.zIndex="1",x.appendChild(F)}i||(E.contentEditable="true"),this._lineHeight=this._calculateLineHeight(),this._editorPadding=this._calculatePadding(),c&&(t.style.lineHeight=this._lineHeight+"px"),a.tabSize&&(e?E.style.OTabSize=a.tabSize+"":d>=4?E.style.MozTabSize=a.tabSize+"":a.tabSize!==8&&(this._tabSize=a.tabSize)),this._createActions(),this._hookEvents()},_modifyContent:function(a,b){if(!this.readonly||!!a._code){this.onVerify(a);if(a.text===null||a.text===undefined)return;var c=this._model;a._ignoreDOMSelection&&(this._ignoreDOMSelection=!0),c.setText(a.text,a.start,a.end),a._ignoreDOMSelection&&(this._ignoreDOMSelection=!1);if(b){var d=this._getSelection();d.setCaret(a.start+a.text.length),this._setSelection(d,!0),this._showCaret()}this.onModify({})}},_onModelChanged:function(a,b,c,d,e){var f={start:a,removedCharCount:b,addedCharCount:c,removedLineCount:d,addedLineCount:e};this.onModelChanged(f);var g=this._getSelection();g.end>a&&(g.end>a&&g.start<a+b?g.setCaret(a+c):(g.start+=c-b,g.end+=c-b),this._setSelection(g,!1,!1));var h=this._model,i=h.getLineAtOffset(a),j=this._getLineNext();while(j){var k=j.lineIndex;i<=k&&k<=i+d&&(j.lineChanged=!0),k>i+d&&(j.lineIndex=k+e-d),j=this._getLineNext(j)}i<=this._maxLineIndex&&this._maxLineIndex<=i+d&&(this._maxLineIndex=-1,this._maxLineWidth=0),this._updatePage()},_onModelChanging:function(a,b,c,d,e,f){var g={text:a,start:b,removedCharCount:c,addedCharCount:d,removedLineCount:e,addedLineCount:f};this.onModelChanging(g)},_queueUpdatePage:function(){if(!this._updateTimer){var a=this;this._updateTimer=setTimeout(function(){a._updateTimer=null,a._updatePage()},0)}},_resizeTouchDiv:function(){var a=this._editorDiv.getBoundingClientRect(),b=this._frame.getBoundingClientRect(),c=this._frame;while(c){if(c.style&&c.style.top)break;c=c.parentNode}var d=b.top;c?d-=c.getBoundingClientRect().top:d+=this._parentDocument.body.scrollTop,c=this._frame;while(c){if(c.style&&c.style.left)break;c=c.parentNode}var e=b.left;c?e-=c.getBoundingClientRect().left:e+=this._parentDocument.body.scrollLeft;var f=this._touchDiv;f.style.left=e+a.left+"px",f.style.top=d+a.top+"px",f.style.width=a.width+"px",f.style.height=a.height+"px"},_scrollView:function(a,b){this._ensureCaretVisible=!1;var c=this._editorDiv;a&&(c.scrollLeft+=a),b&&(c.scrollTop+=b)},_setClipboardText:function(a,b){if(this._frameWindow.clipboardData)return this._frameWindow.clipboardData.setData("Text",a);if(f||d||!b){var c=this._frameWindow,e=this._frameDocument,g=e.createElement("PRE");g.style.position="fixed",g.style.left="-1000px";var h=0,i=0,j=0,k=a.length;while(j<k){h!==-1&&h<=j&&(h=a.indexOf("\r",j)),i!==-1&&i<=j&&(i=a.indexOf("\n",j));var l=j,m;if(i===-1&&h===-1){g.appendChild(e.createTextNode(a.substring(j)));break}h!==-1&&i!==-1?h+1===i?(m=h,j=i+1):(m=h<i?h:i,j=(h<i?h:i)+1):h!==-1?(m=h,j=h+1):(m=i,j=i+1),g.appendChild(e.createTextNode(a.substring(l,m))),g.appendChild(e.createElement("BR"))}g.appendChild(e.createTextNode(" ")),this._clientDiv.appendChild(g);var n=e.createRange();n.setStart(g.firstChild,0),n.setEndBefore(g.lastChild);var o=c.getSelection();o.rangeCount>0&&o.removeAllRanges(),o.addRange(n);var p=this,q=function(){p._clientDiv.removeChild(g),p._updateDOMSelection()},r=!1;this._ignoreCopy=!0;try{r=e.execCommand("copy",!1,null)}catch(s){}this._ignoreCopy=!1;if(!r&&b){setTimeout(q,0);return!1}q();return!0}if(b&&b.clipboardData)return b.clipboardData.setData("text/plain",a)},_setDOMSelection:function(a,b,c,d){var e=this._frameWindow,f=this._frameDocument,g,h,j,k,l=0,m=a.firstChild,n,o,p=this._model,q=p.getLine(a.lineIndex).length;while(m){n=m.firstChild,o=n.length,m.ignoreChars&&(o-=m.ignoreChars);if(l+o>b||l+o>=q){g=n,h=b-l,m.ignoreChars&&o>0&&h===o&&(h+=m.ignoreChars);break}l+=o,m=m.nextSibling}l=0,m=c.firstChild;var r=this._model.getLine(c.lineIndex).length;while(m){n=m.firstChild,o=n.length,m.ignoreChars&&(o-=m.ignoreChars);if(o+l>d||l+o>=r){j=n,k=d-l,m.ignoreChars&&o>0&&k===o&&(k+=m.ignoreChars);break}l+=o,m=m.nextSibling}if(this._selDiv1){var s,t;s=this._getLineBoundingClientRect(a),b===0?t=s.left:b>=q?t=s.right:(this._ignoreDOMSelection=!0,t=this._getBoundsAtOffset(p.getLineStart(a.lineIndex)+b).left,this._ignoreDOMSelection=!1);var u=this._textArea;if(u){u.selectionStart=u.selectionEnd=0;var v=this._frame.getBoundingClientRect(),w=this._touchDiv.getBoundingClientRect(),x=this._editorDiv.getBoundingClientRect();x.left<=t&&t<=x.left+x.width&&x.top<=s.top&&s.top<=x.top+x.height&&a===c&&b===d?u.style.left=t-4+v.left-w.left+"px":u.style.left="-1000px",u.style.top=s.top+v.top-w.top+"px",u.style.width="6px",u.style.height=s.bottom-s.top+"px"}var y=this._selDiv1;y.style.width="0px",y.style.height="0px",y=this._selDiv2,y.style.width="0px",y.style.height="0px",y=this._selDiv3,y.style.width="0px",y.style.height="0px";if(a!==c||b!==d){var z=i?2:0,A=z+"px blue solid",B=this._getEditorPadding(),C=this._clientDiv.getBoundingClientRect(),D=this._editorDiv.getBoundingClientRect(),E=D.left+B.left,F=C.right,G=D.top+B.top,H=C.bottom,I,J=this._getLineBoundingClientRect(c);d===0?I=J.left:d>=r?I=J.right:(this._ignoreDOMSelection=!0,I=this._getBoundsAtOffset(p.getLineStart(c.lineIndex)+d).left,this._ignoreDOMSelection=!1);var K=this._selDiv1,L=Math.min(F,Math.max(E,t)),M=Math.min(H,Math.max(G,s.top)),N=F,O=Math.min(H,Math.max(G,s.bottom));K.style.left=L+"px",K.style.top=M+"px",K.style.width=Math.max(0,N-L)+"px",K.style.height=Math.max(0,O-M)+(i?1:0)+"px",i&&(K.style.borderLeft=A,K.style.borderRight="0px");if(a===c)N=Math.min(I,F),K.style.width=Math.max(0,N-L-z*2)+"px",i&&(K.style.borderRight=A);else{var P=E,Q=Math.min(H,Math.max(G,J.top)),R=Math.min(F,Math.max(E,I)),S=Math.min(H,Math.max(G,J.bottom)),T=this._selDiv3;T.style.left=P+"px",T.style.top=Q+"px",T.style.width=Math.max(0,R-P-z)+"px",T.style.height=Math.max(0,S-Q)+"px",i&&(T.style.borderRight=A);if(Q-O>0){var U=this._selDiv2;U.style.left=E+"px",U.style.top=O+"px",U.style.width=Math.max(0,F-E)+"px",U.style.height=Math.max(0,Q-O)+(i?1:0)+"px"}}}if(i)return}var V;if(e.getSelection){V=f.createRange(),V.setStart(g,h),V.setEnd(j,k);var W=e.getSelection();this._ignoreSelect=!1,W.rangeCount>0&&W.removeAllRanges(),W.addRange(V),this._ignoreSelect=!0}else if(f.selection){var X=f.body,Y=f.createElement("DIV");X.appendChild(Y),X.removeChild(Y),V=X.createTextRange(),V.moveToElementText(g.parentNode),V.moveStart("character",h);var Z=X.createTextRange();Z.moveToElementText(j.parentNode),Z.moveStart("character",k),V.setEndPoint("EndToStart",Z),this._ignoreSelect=!1,V.select(),this._ignoreSelect=!0}},_setGrab:function(c){c!==this._grabControl&&(c?(a(c,"mousemove",this._mouseMoveClosure),a(c,"mouseup",this._mouseUpClosure),c.setCapture&&c.setCapture(),this._grabControl=c):(b(this._grabControl,"mousemove",this._mouseMoveClosure),b(this._grabControl,"mouseup",this._mouseUpClosure),this._grabControl.releaseCapture&&this._grabControl.releaseCapture(),this._grabControl=null))},_setSelection:function(a,b,c){if(a){this._columnX=-1,c===undefined&&(c=!0);var d=this._selection;if(!d.equals(a)){this._selection=a;var e={oldValue:{start:d.start,end:d.end},newValue:{start:a.start,end:a.end}};this.onSelection(e),b&&(c=!this._showCaret())}c&&this._updateDOMSelection()}},_setSelectionTo:function(a,b,c){var d=this._model,e,f=this._getSelection(),g=this._getYToLine(b);if(this._clickCount===1)e=this._getXToOffset(g,a),f.extend(e),c||f.collapse();else{var h=(this._clickCount&1)===0,i,j;if(h)e=this._getXToOffset(g,a),this._doubleClickSelection?e>=this._doubleClickSelection.start?(i=this._doubleClickSelection.start,j=this._getOffset(e,"wordend",1)):(i=this._getOffset(e,"word",-1),j=this._doubleClickSelection.end):(i=this._getOffset(e,"word",-1),j=this._getOffset(i,"wordend",1));else if(this._doubleClickSelection){var k=d.getLineAtOffset(this._doubleClickSelection.start);g>=k?(i=d.getLineStart(k),j=d.getLineEnd(g)):(i=d.getLineStart(g),j=d.getLineEnd(k))}else i=d.getLineStart(g),j=d.getLineEnd(g);f.setCaret(i),f.extend(j)}this._setSelection(f,!0,!0)},_showCaret:function(){var a=this._model,b=this._getSelection(),c=this._getScroll(),d=b.getCaret(),e=b.start,f=b.end,g=a.getLineAtOffset(e),h=a.getLineAtOffset(f),i=Math.max(Math.max(e,a.getLineStart(h)),f-1),j=this._getEditorPadding(),k=this._getClientWidth(),l=j.left,m=j.left+k,n=this._getBoundsAtOffset(d===e?e:i),o=n.left,p=n.right,q=k/4;if(!b.isEmpty()&&g===h){n=this._getBoundsAtOffset(d===f?e:i);var r=d===e?n.right-o:p-n.left;k-q>r&&(o>n.left&&(o=n.left),p<n.right&&(p=n.right))}var s=this._editorDiv.getBoundingClientRect();o-=s.left,p-=s.left;var t=0;o<l&&(t=Math.min(o-l,-q));if(p>m){var u=this._scrollDiv.scrollWidth-c.x-k;t=Math.min(u,Math.max(p-m,q))}var v=0,w=this._getTopIndex(!0),x=this._getBottomIndex(!0),y=a.getLineAtOffset(d),z=this._getClientHeight();if(!(w<=y&&y<=x)){var A=this._getLineHeight(),B=(h-g)*A;v=y*A,v-=c.y,v+A>z?(v-=z-A,d===e&&e!==f&&(v+=Math.min(z-A,B))):d===f&&(v-=Math.min(z-A,B))}if(t!==0||v!==0){this._scrollView(t,v),z!==this._getClientHeight()||k!==this._getClientWidth()?this._showCaret():this._ensureCaretVisible=!0;return!0}return!1},_startIME:function(){if(this._imeOffset===-1){var a=this._getSelection();a.isEmpty()||this._modifyContent({text:"",start:a.start,end:a.end},!0),this._imeOffset=a.start}},_unhookEvents:function(){this._model.removeListener(this._modelListener),this._modelListener=null,this._mouseMoveClosure=null,this._mouseUpClosure=null;for(var a=0;a<this._handlers.length;a++){var c=this._handlers[a];b(c.target,c.type,c.handler)}this._handlers=null},_updateDOMSelection:function(){if(!this._ignoreDOMSelection){var a=this._getSelection(),b=this._model,c=b.getLineAtOffset(a.start),d=b.getLineAtOffset(a.end),e=this._getLineNext();if(!e)return;var f=this._getLinePrevious(),g,h,i,j;c<e.lineIndex?(g=e,i=0):c>f.lineIndex?(g=f,i=0):(g=this._getLineNode(c),i=a.start-b.getLineStart(c)),d<e.lineIndex?(h=e,j=0):d>f.lineIndex?(h=f,j=0):(h=this._getLineNode(d),j=a.end-b.getLineStart(d)),this._setDOMSelection(g,i,h,j)}},_updatePage:function(){function Q(a){if(!!a){var b=r+g.top+g.bottom,c=a.firstChild.rows[0].cells;for(var d=0;d<c.length;d++){var e=c[d].firstChild,f=k;e._ruler.getOverview()==="page"&&(f+=s),e.style.top=-f+"px",e.style.height=b+f+"px",e=e.nextSibling}a.style.height=b+"px"}}this._updateTimer&&(clearTimeout(this._updateTimer),this._updateTimer=null);var a=this._frameDocument,b=this._getFrameWidth(),d=this._getFrameHeight();a.body.style.width=b+"px",a.body.style.height=d+"px";var e=this._editorDiv,f=this._clientDiv,g=this._getEditorPadding();e.style.height=Math.max(0,d-g.top-g.bottom)+"px";var j=this._model,k=this._getLineHeight(),l=this._getScroll().y,m=Math.max(0,l)/k,n=Math.floor(m),o=Math.max(0,n-1),p=Math.round((m-o)*k),q=j.getLineCount(),r=this._getClientHeight(),s=Math.round((m-n)*k),t=Math.floor((r+s)/k),u=Math.min(n+t,q-1),v=Math.min(u+1,q-1);this._partialY=s;var w,x,y=f.firstChild;while(y){w=y.lineIndex;var z=y.nextSibling;if(!(o<=w&&w<=v)||y.lineChanged||y.lineIndex===-1)this._mouseWheelLine===y?(y.style.display="none",y.lineIndex=-1):f.removeChild(y);y=z}y=this._getLineNext();var A=a.createDocumentFragment();for(w=o;w<=v;w++)!y||y.lineIndex>w?this._createLine(A,null,a,w,j):(A.firstChild&&(f.insertBefore(A,y),A=a.createDocumentFragment()),y=this._getLineNext(y));A.firstChild&&f.insertBefore(A,y),h&&(f.style.width=524287..toString()+"px"),y=this._getLineNext();while(y){x=y.lineWidth;if(x===undefined){var B=this._getLineBoundingClientRect(y);x=y.lineWidth=B.right-B.left}x>=this._maxLineWidth&&(this._maxLineWidth=x,this._maxLineIndex=y.lineIndex),y.lineIndex===n&&(this._topChild=y),y.lineIndex===u&&(this._bottomChild=y),y=this._getLineNext(y)}this._updateRuler(this._leftDiv,n,u),this._updateRuler(this._rightDiv,n,u);var C=this._leftDiv?this._leftDiv.scrollWidth:0,D=this._rightDiv?this._rightDiv.scrollWidth:0;e.style.left=C+"px",e.style.width=Math.max(0,b-C-D-g.left-g.right)+"px",this._rightDiv&&(this._rightDiv.style.left=b-D+"px");var E=this._scrollDiv,F=q*k;E.style.height=F+"px";var G=this._getClientWidth(),H=Math.max(this._maxLineWidth,G),I=H;if(!c||c>=9)H+=g.right;E.style.width=H+"px";var J=this._getScroll(),K=J.x,L=K,M=p,N=K+G,O=p+r;L===0&&(L-=g.left),M===0&&(M-=g.top),N===I&&(N+=g.right),J.y+r===F&&(O+=g.bottom),f.style.clip="rect("+M+"px,"+N+"px,"+O+"px,"+L+"px)",f.style.left=-K+C+g.left+"px",f.style.top=-p+g.top+"px",f.style.width=(h?I:G+K)+"px",f.style.height=r+p+"px";var P=this._overlayDiv;P&&(P.style.clip=f.style.clip,P.style.left=f.style.left,P.style.top=f.style.top,P.style.width=f.style.width,P.style.height=f.style.height),Q(this._leftDiv),Q(this._rightDiv);if(i){var R=this;setTimeout(function(){R._resizeTouchDiv()},0)}this._updateDOMSelection();var S=this._ensureCaretVisible;this._ensureCaretVisible=!1,r!==this._getClientHeight()&&(this._updatePage(),S&&this._showCaret())},_updateRuler:function(a,b,c){if(!!a){var d=a.firstChild.rows[0].cells,e=this._getLineHeight(),f=this._frameDocument,g=this._getEditorPadding();for(var h=0;h<d.length;h++){var i=d[h].firstChild,j=i._ruler,k;i.rulerChanged&&this._applyStyle(j.getStyle(),i);var l,m=i.firstChild;m?(l=m,m=m.nextSibling):(l=f.createElement("DIV"),l.style.visibility="hidden",i.appendChild(l));var n;i.rulerChanged&&l&&(n=-1,this._applyStyle(j.getStyle(n),l),l.innerHTML=j.getHTML(n),l.lineIndex=n,l.style.height=e+g.top+"px");var o=j.getOverview(),p,q;if(o==="page"){while(m){n=m.lineIndex;var r=m.nextSibling;(!(b<=n&&n<=c)||m.lineChanged)&&i.removeChild(m),m=r}m=i.firstChild.nextSibling,q=document.createDocumentFragment();for(n=b;n<=c;n++)!m||m.lineIndex>n?(p=f.createElement("DIV"),this._applyStyle(j.getStyle(n),p),p.innerHTML=j.getHTML(n),p.lineIndex=n,p.style.height=e+"px",q.appendChild(p)):(q.firstChild&&(i.insertBefore(q,m),q=document.createDocumentFragment()),m&&(m=m.nextSibling));q.firstChild&&i.insertBefore(q,m)}else{var s=17,t=this._getClientHeight(),u=t+g.top+g.bottom-2*s,v=this._model.getLineCount(),w=u/v;if(i.rulerChanged){var x=i.childNodes.length;while(x>1)i.removeChild(i.lastChild),x--;var y=j.getAnnotations();q=document.createDocumentFragment();for(var z=0;z<y.length;z++)n=y[z],p=f.createElement("DIV"),this._applyStyle(j.getStyle(n),p),p.style.position="absolute",p.style.top=s+e+Math.floor(n*w)+"px",p.innerHTML=j.getHTML(n),p.lineIndex=n,q.appendChild(p);i.appendChild(q)}else if(i._oldTrackHeight!==u){p=i.firstChild?i.firstChild.nextSibling:null;while(p)p.style.top=s+e+Math.floor(p.lineIndex*w)+"px",p=p.nextSibling}i._oldTrackHeight=u}i.rulerChanged=!1,i=i.nextSibling}}}};return q}();var eclipse=eclipse||{};eclipse.TextModel=function(){function b(b,c){this._listeners=[],this._lineDelimiter=c?c:a?"\r\n":"\n",this._lastLineIndex=-1,this._text=[""],this._lineOffsets=[0],this.setText(b)}var a=navigator.platform.indexOf("Win")!==-1;b.prototype={addListener:function(a){this._listeners.push(a)},removeListener:function(a){for(var b=0;b<this._listeners.length;b++)if(this._listeners[b]===a){this._listeners.splice(b,1);return}},getCharCount:function(){var a=0;for(var b=0;b<this._text.length;b++)a+=this._text[b].length;return a},getLine:function(a,b){var c=this.getLineCount();if(!(0<=a&&a<c))return null;var d=this._lineOffsets[a];if(a+1<c){var e=this.getText(d,this._lineOffsets[a+1]);if(b)return e;var f=e.length,g;while((g=e.charCodeAt(f-1))===10||g===13)f--;return e.substring(0,f)}return this.getText(d)},getLineAtOffset:function(a){if(!(0<=a&&a<=this.getCharCount()))return-1;var b=this.getLineCount(),c=this.getCharCount();if(a===c)return b-1;var d,e,f=this._lastLineIndex;if(0<=f&&f<b){d=this._lineOffsets[f],e=f+1<b?this._lineOffsets[f+1]:c;if(d<=a&&a<e)return f}var g=b,h=-1;while(g-h>1){f=Math.floor((g+h)/2),d=this._lineOffsets[f],e=f+1<b?this._lineOffsets[f+1]:c;if(a<=d)g=f;else{if(a<e){g=f;break}h=f}}this._lastLineIndex=g;return g},getLineCount:function(){return this._lineOffsets.length},getLineDelimiter:function(){return this._lineDelimiter},getLineEnd:function(a,b){var c=this.getLineCount();if(!(0<=a&&a<c))return-1;if(a+1<c){var d=this._lineOffsets[a+1];if(b)return d;var e=this.getText(Math.max(this._lineOffsets[a],d-2),d),f=e.length,g;while((g=e.charCodeAt(f-1))===10||g===13)f--;return d-(e.length-f)}return this.getCharCount()},getLineStart:function(a){if(!(0<=a&&a<this.getLineCount()))return-1;return this._lineOffsets[a]},getText:function(a,b){a===undefined&&(a=0),b===undefined&&(b=this.getCharCount());var c=0,d=0,e;while(d<this._text.length){e=this._text[d].length;if(a<=c+e)break;c+=e,d++}var f=c,g=d;while(d<this._text.length){e=this._text[d].length;if(b<=c+e)break;c+=e,d++}var h=c,i=d;if(g===i)return this._text[g].substring(a-f,b-h);var j=this._text[g].substring(a-f),k=this._text[i].substring(0,b-h);return j+this._text.slice(g+1,i).join("")+k},onChanging:function(a,b,c,d,e,f){for(var g=0;g<this._listeners.length;g++){var h=this._listeners[g];h&&h.onChanging&&h.onChanging(a,b,c,d,e,f)}},onChanged:function(a,b,c,d,e){for(var f=0;f<this._listeners.length;f++){var g=this._listeners[f];g&&g.onChanged&&g.onChanged(a,b,c,d,e)}},setText:function(a,b,c){a===undefined&&(a=""),b===undefined&&(b=0),c===undefined&&(c=this.getCharCount());var d=this.getLineAtOffset(b),e=this.getLineAtOffset(c),f=b,g=c-b,h=e-d,i=a.length,j=0,k=this.getLineCount(),l=0,m=0,n=0,o=[];for(;;){l!==-1&&l<=n&&(l=a.indexOf("\r",n)),m!==-1&&m<=n&&(m=a.indexOf("\n",n));if(m===-1&&l===-1)break;l!==-1&&m!==-1?l+1===m?n=m+1:n=(l<m?l:m)+1:l!==-1?n=l+1:n=m+1,o.push(b+n),j++}this.onChanging(a,f,g,i,h,j);if(o.length===0){var p=this.getLineStart(d),q;e+1<k?q=this.getLineStart(e+1):q=this.getCharCount(),b!==p&&(a=this.getText(p,b)+a,b=p),c!==q&&(a=a+this.getText(c,q),c=q)}var r=i-g;for(var s=d+h+1;s<k;s++)this._lineOffsets[s]+=r;var t=[d+1,h].concat(o);Array.prototype.splice.apply(this._lineOffsets,t);var u=0,v=0,w;while(v<this._text.length){w=this._text[v].length;if(b<=u+w)break;u+=w,v++}var x=u,y=v;while(v<this._text.length){w=this._text[v].length;if(c<=u+w)break;u+=w,v++}var z=u,A=v,B=this._text[y],C=this._text[A],D=B.substring(0,b-x),E=C.substring(c-z),F=[y,A-y+1];D&&F.push(D),a&&F.push(a),E&&F.push(E),Array.prototype.splice.apply(this._text,F),this._text.length===0&&(this._text=[""]),this.onChanged(f,g,i,h,j)}};return b}()
\ No newline at end of file
diff --git a/browser/base/content/source-editor.jsm b/browser/base/content/source-editor.jsm
new file mode 100644
--- /dev/null
+++ b/browser/base/content/source-editor.jsm
@@ -0,0 +1,228 @@
+/* vim:set ts=2 sw=2 sts=2 et tw=80:
+ * ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is the Source Editor component.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Mihai Sucan <mihai.sucan@gmail.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK *****/
+
+const Cu = Components.utils;
+
+Cu.import("resource:///modules/Services.jsm");
+
+const ORION_SCRIPT = "chrome://browser/content/orion.js";
+const ORION_IFRAME = "data:text/html;charset=utf8,<!DOCTYPE html>" +
+  "<html style='height:100%'>" +
+  "<body style='height:100%;margin:0;overflow:hidden'>" +
+  "<div id='editor' style='height:100%'></div>" +
+  "</body></html>";
+
+const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+var EXPORTED_SYMBOLS = ["SourceEditor"];
+
+function SourceEditor() { }
+
+SourceEditor.MODES = {
+  JAVASCRIPT: "js",
+  CSS: "css",
+  TEXT: "text",
+  HTML: "html",
+  XML: "xml",
+};
+
+SourceEditor.THEMES = {
+  TEXTMATE: "chrome://browser/content/orion.css",
+};
+
+SourceEditor.DEFAULTS = {
+  MODE: SourceEditor.MODES.JAVASCRIPT,
+  THEME: SourceEditor.THEMES.TEXTMATE,
+  UNDO_LIMIT: 200,
+  TAB_SIZE: 4,
+};
+
+SourceEditor.prototype = {
+  _orion: null,
+  _iframe: null,
+  _undoStack: null,
+  inputElement: null,
+
+  init: function SE_init(aElement, aConfig, aCallback)
+  {
+    if (this._iframe) {
+      throw new Error("SourceEditor is already initialized!");
+      return;
+    }
+
+    let doc = aElement.ownerDocument;
+
+    this._iframe = doc.createElementNS(XUL_NS, "iframe");
+    this._iframe.flex = 1;
+
+    let self = this;
+    this._iframe.addEventListener("load", function SE_init_onLoad() {
+      self._iframe.removeEventListener("load", SE_init_onLoad, true);
+
+      Services.scriptloader.loadSubScript(ORION_SCRIPT,
+        self._iframe.contentWindow.wrappedJSObject, "utf8");
+
+      self._onLoad(aConfig, aCallback);
+    }, true);
+
+    this._iframe.setAttribute("src", ORION_IFRAME);
+
+    aElement.setAttribute("hidden", true);
+    aElement.parentNode.insertBefore(this._iframe, aElement);
+
+    this.inputElement = aElement;
+  },
+
+  _onLoad: function SE__onLoad(aConfig, aCallback)
+  {
+    let eclipse = this._iframe.contentWindow.wrappedJSObject.eclipse;
+
+    this._orion = new eclipse.Editor({
+      parent: "editor",
+      stylesheet: aConfig.theme || SourceEditor.DEFAULTS.THEME,
+      tabSize: aConfig.tabSize || SourceEditor.DEFAULTS.TAB_SIZE,
+      readonly: aConfig.readOnly,
+    });
+
+    if (aConfig.showLineNumbers) {
+      let lines = new eclipse.LineNumberRuler("left",
+        {styleClass: "ruler_lines"}, {styleClass: "ruler_lines_odd"},
+        {styleClass: "ruler_lines_even"});
+
+      this._orion.addRuler(lines);
+    }
+
+    let styler = new eclipse.TextStyler(this._orion,
+      aConfig.mode || SourceEditor.DEFAULTS.MODE);
+
+    this._orion.setText(this.inputElement.value ||
+                        this.inputElement.textContent);
+
+    if (!aConfig.readOnly) {
+      this._undoStack = new eclipse.UndoStack(this._orion,
+        aConfig.undoLimit || SourceEditor.DEFAULTS.UNDO_LIMIT);
+    }
+
+    let keys = aConfig.keys || {};
+    for (let name in keys) {
+      let key = keys[name];
+      let binding = new eclipse.KeyBinding(key.code, key.accel, key.shift,
+                                           key.alt);
+
+      this._orion.setKeyBinding(binding, name);
+
+      if (this._undoStack && (name == "undo" || name == "redo")) {
+        this._orion.setAction(name, (function(aName) {
+          this._undoStack[aName]();
+          return true;
+        }).bind(this, name));
+      } else if (key.callback) {
+        this._orion.setAction(name, key.callback);
+      }
+    }
+
+    if (aCallback) {
+      aCallback(this);
+    }
+  },
+
+  addEventListener: function SE_addEventListener(aEvent, aCallback, aContext, aData)
+  {
+    return this._orion.addEventListener(aEvent, aContext, aCallback, aData);
+  },
+
+  removeEventListener: function SE_removeEventListener(aEvent, aCallback, aContext, aData)
+  {
+    return this._orion.removeEventListener(aEvent, aContext, aCallback, aData);
+  },
+
+  undo: function SE_undo()
+  {
+    this._undoStack.undo();
+  },
+
+  redo: function SE_redo()
+  {
+    this._undoStack.redo();
+  },
+
+  canUndo: function SE_canUndo()
+  {
+    return this._undoStack.canUndo();
+  },
+
+  canRedo: function SE_canRedo()
+  {
+    return this._undoStack.canRedo();
+  },
+
+  getText: function SE_getText()
+  {
+    return this._orion.getText();
+  },
+
+  getSelectedText: function SE_getSelectedText()
+  {
+    let selection = this._orion.getSelection();
+    return this._orion.getText(selection.start, selection.end);
+  },
+
+  setText: function SE_setText(aText)
+  {
+    this._orion.setText(aText);
+  },
+
+  dropSelection: function SE_dropSelection()
+  {
+    let caret = this._orion.getCaretOffset();
+    this._orion.setSelection(caret, caret, true);
+  },
+
+  setSelection: function SE_setSelection(aStart, aEnd)
+  {
+    this._orion.setSelection(aStart, aEnd, true);
+  },
+
+  getSelection: function SE_getSelection()
+  {
+    return this._orion.getSelection();
+  },
+
+  // TODO: add destroy()
+};
+
diff --git a/browser/base/jar.mn b/browser/base/jar.mn
--- a/browser/base/jar.mn
+++ b/browser/base/jar.mn
@@ -26,16 +26,18 @@ browser.jar:
 *       content/browser/browser.css                   (content/browser.css)
 *       content/browser/browser.js                    (content/browser.js)
 *       content/browser/browser.xul                   (content/browser.xul)
 *       content/browser/browser-tabPreviews.xml       (content/browser-tabPreviews.xml)
 *       content/browser/fullscreen-video.xhtml        (content/fullscreen-video.xhtml)
 *       content/browser/inspector.html                (content/inspector.html)
 *       content/browser/scratchpad.xul                (content/scratchpad.xul)
 *       content/browser/scratchpad.js                 (content/scratchpad.js)
+        content/browser/orion.js                      (content/orion/orion.min.js)
+        content/browser/orion.css                     (content/orion/orion.css)
 *       content/browser/pageinfo/pageInfo.xul         (content/pageinfo/pageInfo.xul)
 *       content/browser/pageinfo/pageInfo.js          (content/pageinfo/pageInfo.js)
 *       content/browser/pageinfo/pageInfo.css         (content/pageinfo/pageInfo.css)
 *       content/browser/pageinfo/pageInfo.xml         (content/pageinfo/pageInfo.xml)
 *       content/browser/pageinfo/feeds.js             (content/pageinfo/feeds.js)
 *       content/browser/pageinfo/feeds.xml            (content/pageinfo/feeds.xml)
 *       content/browser/pageinfo/permissions.js       (content/pageinfo/permissions.js)
 *       content/browser/pageinfo/security.js          (content/pageinfo/security.js)
