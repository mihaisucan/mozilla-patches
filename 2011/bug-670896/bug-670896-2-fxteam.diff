# HG changeset patch
# Parent 5e826059eb7d34314bc994cbc974e43845521384
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1311413673 -10800

Bug 670896 - Add inner window ID and timestamp to nsIScriptError2

diff --git a/content/base/public/nsContentUtils.h b/content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h
+++ b/content/base/public/nsContentUtils.h
@@ -737,16 +737,18 @@ public:
    *   @param aSourceLine The text of the line that contains the error (may be
               empty).
    *   @param aLineNumber Line number within resource containing error.
    *   @param aColumnNumber Column number within resource containing error.
    *   @param aErrorFlags See nsIScriptError.
    *   @param aCategory Name of module reporting error.
    *   @param [aWindowId=0] (Optional) The window ID of the outer window the
    *          message originates from.
+   *   @param [aInnerWindowId=0] (Optional) The window ID of the inner window
+   *          the message originates from.
    */
   enum PropertiesFile {
     eCSS_PROPERTIES,
     eXBL_PROPERTIES,
     eXUL_PROPERTIES,
     eLAYOUT_PROPERTIES,
     eFORMS_PROPERTIES,
     ePRINTING_PROPERTIES,
@@ -761,17 +763,18 @@ public:
                                   const PRUnichar **aParams,
                                   PRUint32 aParamsLength,
                                   nsIURI* aURI,
                                   const nsAFlatString& aSourceLine,
                                   PRUint32 aLineNumber,
                                   PRUint32 aColumnNumber,
                                   PRUint32 aErrorFlags,
                                   const char *aCategory,
-                                  PRUint64 aWindowId = 0);
+                                  PRUint64 aWindowId = 0,
+                                  PRUint64 aInnerWindowId = 0);
 
   /**
    * Report a localized error message to the error console.
    *   @param aFile Properties file containing localized message.
    *   @param aMessageName Name of localized message.
    *   @param aParams Parameters to be substituted into localized message.
    *   @param aParamsLength Length of aParams.
    *   @param aURI URI of resource containing error (may be null).
diff --git a/content/base/public/nsIDocument.h b/content/base/public/nsIDocument.h
--- a/content/base/public/nsIDocument.h
+++ b/content/base/public/nsIDocument.h
@@ -709,16 +709,25 @@ public:
    */
   PRUint64 OuterWindowID() const
   {
     nsPIDOMWindow *window = GetWindow();
     return window ? window->WindowID() : 0;
   }
 
   /**
+   * Return the inner window ID.
+   */
+  PRUint64 InnerWindowID()
+  {
+    nsPIDOMWindow *window = GetInnerWindow();
+    return window ? window->WindowID() : 0;
+  }
+
+  /**
    * Get the script loader for this document
    */ 
   virtual nsScriptLoader* ScriptLoader() = 0;
 
   /**
    * Add/Remove an element to the document's id and name hashes
    */
   virtual void AddToIdTable(Element* aElement, nsIAtom* aId) = 0;
diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -2738,17 +2738,18 @@ nsContentUtils::ReportToConsole(Properti
                                 const PRUnichar **aParams,
                                 PRUint32 aParamsLength,
                                 nsIURI* aURI,
                                 const nsAFlatString& aSourceLine,
                                 PRUint32 aLineNumber,
                                 PRUint32 aColumnNumber,
                                 PRUint32 aErrorFlags,
                                 const char *aCategory,
-                                PRUint64 aWindowId)
+                                PRUint64 aWindowId,
+                                PRUint64 aInnerWindowId)
 {
   NS_ASSERTION((aParams && aParamsLength) || (!aParams && !aParamsLength),
                "Supply either both parameters and their number or no"
                "parameters and 0.");
 
   nsresult rv;
   if (!sConsoleService) { // only need to bother null-checking here
     rv = CallGetService(NS_CONSOLESERVICE_CONTRACTID, &sConsoleService);
@@ -2772,17 +2773,18 @@ nsContentUtils::ReportToConsole(Properti
   nsCOMPtr<nsIScriptError2> errorObject =
       do_CreateInstance(NS_SCRIPTERROR_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = errorObject->InitWithWindowID(errorText.get(),
                                      NS_ConvertUTF8toUTF16(spec).get(), // file name
                                      aSourceLine.get(),
                                      aLineNumber, aColumnNumber,
-                                     aErrorFlags, aCategory, aWindowId);
+                                     aErrorFlags, aCategory,
+                                     aWindowId, aInnerWindowId);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIScriptError> logError = do_QueryInterface(errorObject);
   return sConsoleService->LogMessage(logError);
 }
 
 /* static */ nsresult
 nsContentUtils::ReportToConsole(PropertiesFile aFile,
@@ -2794,26 +2796,28 @@ nsContentUtils::ReportToConsole(Properti
                                 PRUint32 aLineNumber,
                                 PRUint32 aColumnNumber,
                                 PRUint32 aErrorFlags,
                                 const char *aCategory,
                                 nsIDocument* aDocument)
 {
   nsIURI* uri = aURI;
   PRUint64 windowID = 0;
+  PRUint64 innerWindowID = 0;
   if (aDocument) {
     if (!uri) {
       uri = aDocument->GetDocumentURI();
     }
     windowID = aDocument->OuterWindowID();
+    innerWindowID = aDocument->InnerWindowID();
   }
 
   return ReportToConsole(aFile, aMessageName, aParams, aParamsLength, uri,
                          aSourceLine, aLineNumber, aColumnNumber, aErrorFlags,
-                         aCategory, windowID);
+                         aCategory, windowID, innerWindowID);
 }
 
 PRBool
 nsContentUtils::IsChromeDoc(nsIDocument *aDocument)
 {
   if (!aDocument) {
     return PR_FALSE;
   }
diff --git a/content/base/src/nsEventSource.cpp b/content/base/src/nsEventSource.cpp
--- a/content/base/src/nsEventSource.cpp
+++ b/content/base/src/nsEventSource.cpp
@@ -79,17 +79,18 @@ using namespace mozilla;
 nsEventSource::nsEventSource() :
   mStatus(PARSE_STATE_OFF),
   mFrozen(PR_FALSE),
   mErrorLoadOnRedirect(PR_FALSE),
   mGoingToDispatchAllMessages(PR_FALSE),
   mLastConvertionResult(NS_OK),
   mReadyState(nsIEventSource::CONNECTING),
   mScriptLine(0),
-  mWindowID(0)
+  mWindowID(0),
+  mInnerWindowID(0)
 {
 }
 
 nsEventSource::~nsEventSource()
 {
   Close();
 
   if (mListenerManager) {
@@ -248,16 +249,17 @@ nsEventSource::Init(nsIPrincipal* aPrinc
   JSContext* cx = nsnull;
   if (stack && NS_SUCCEEDED(stack->Peek(&cx)) && cx) {
     const char *filename;
     if (nsJSUtils::GetCallingLocation(cx, &filename, &mScriptLine)) {
       mScriptFile.AssignASCII(filename);
     }
 
     mWindowID = nsJSUtils::GetCurrentlyRunningCodeWindowID(cx);
+    mInnerWindowID = nsJSUtils::GetCurrentlyRunningCodeInnerWindowID(cx);
   }
 
   // Get the load group for the page. When requesting we'll add ourselves to it.
   // This way any pending requests will be automatically aborted if the user
   // leaves the page.
   if (mScriptContext) {
     nsCOMPtr<nsIDocument> doc =
       nsContentUtils::GetDocumentFromScriptContext(mScriptContext);
@@ -1066,17 +1068,17 @@ nsEventSource::PrintErrorOnConsole(const
   }
   NS_ENSURE_SUCCESS(rv, rv);
 
   errObj->InitWithWindowID(message.get(),
                            mScriptFile.get(),
                            nsnull,
                            mScriptLine, 0,
                            nsIScriptError::errorFlag,
-                           "Event Source", mWindowID);
+                           "Event Source", mWindowID, mInnerWindowID);
 
   // print the error message directly to the JS console
   nsCOMPtr<nsIScriptError> logError = do_QueryInterface(errObj);
   rv = console->LogMessage(logError);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
diff --git a/content/base/src/nsEventSource.h b/content/base/src/nsEventSource.h
--- a/content/base/src/nsEventSource.h
+++ b/content/base/src/nsEventSource.h
@@ -247,21 +247,22 @@ protected:
 
   PRUint32 mRedirectFlags;
   nsCOMPtr<nsIAsyncVerifyRedirectCallback> mRedirectCallback;
   nsCOMPtr<nsIChannel> mNewRedirectChannel;
 
   // Event Source owner information:
   // - the script file name
   // - source code line number where the Event Source object was constructed.
-  // - the window ID of the outer window where the script lives. Note that this
-  // may not be the same as the Event Source owner window.
+  // - the IDs of the outer and inner windows where the script lives. Note that
+  //   this may not be the same as the Event Source owner window.
   // These attributes are used for error reporting.
   nsString mScriptFile;
   PRUint32 mScriptLine;
   PRUint64 mWindowID;
+  PRUint64 mInnerWindowID;
 
 private:
   nsEventSource(const nsEventSource& x);   // prevent bad usage
   nsEventSource& operator=(const nsEventSource& x);
 };
 
 #endif // nsEventSource_h__
diff --git a/content/base/src/nsWebSocket.cpp b/content/base/src/nsWebSocket.cpp
--- a/content/base/src/nsWebSocket.cpp
+++ b/content/base/src/nsWebSocket.cpp
@@ -346,17 +346,17 @@ nsWebSocketEstablishedConnection::PrintE
   }
   NS_ENSURE_SUCCESS(rv, rv);
 
   errorObject->InitWithWindowID
     (message.get(),
      NS_ConvertUTF8toUTF16(mOwner->GetScriptFile()).get(),
      nsnull,
      mOwner->GetScriptLine(), 0, nsIScriptError::errorFlag,
-     "Web Socket", mOwner->WindowID()
+     "Web Socket", mOwner->WindowID(), mOwner->InnerWindowID()
      );
   
   // print the error message directly to the JS console
   nsCOMPtr<nsIScriptError> logError(do_QueryInterface(errorObject));
   rv = console->LogMessage(logError);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
@@ -608,17 +608,18 @@ nsWebSocketEstablishedConnection::GetInt
 ////////////////////////////////////////////////////////////////////////////////
 
 nsWebSocket::nsWebSocket() : mKeepingAlive(PR_FALSE),
                              mCheckMustKeepAlive(PR_TRUE),
                              mTriggeredCloseEvent(PR_FALSE),
                              mReadyState(nsIWebSocket::CONNECTING),
                              mOutgoingBufferedAmount(0),
                              mScriptLine(0),
-                             mWindowID(0)
+                             mWindowID(0),
+                             mInnerWindowID(0)
 {
   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
 }
 
 nsWebSocket::~nsWebSocket()
 {
   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
   if (mConnection) {
@@ -1340,16 +1341,17 @@ nsWebSocket::Init(nsIPrincipal* aPrincip
 
       jsbytecode *pc = JS_GetFramePC(cx, fp);
       if (script && pc) {
         mScriptLine = JS_PCToLineNumber(cx, script, pc);
       }
     }
 
     mWindowID = nsJSUtils::GetCurrentlyRunningCodeWindowID(cx);
+    mInnerWindowID = nsJSUtils::GetCurrentlyRunningCodeInnerWindowID(cx);
   }
 
   // parses the url
   rv = ParseURL(PromiseFlatString(aURL));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Don't allow https:// to open ws://
   if (!mSecure && 
diff --git a/content/base/src/nsWebSocket.h b/content/base/src/nsWebSocket.h
--- a/content/base/src/nsWebSocket.h
+++ b/content/base/src/nsWebSocket.h
@@ -94,16 +94,17 @@ public:
   NS_IMETHOD RemoveEventListener(const nsAString& aType,
                                  nsIDOMEventListener* aListener,
                                  PRBool aUseCapture);
 
   // Determine if preferences allow WebSocket
   static PRBool PrefEnabled();
 
   const PRUint64 WindowID() const { return mWindowID; }
+  const PRUint64 InnerWindowID() const { return mInnerWindowID; }
   const nsCString& GetScriptFile() const { return mScriptFile; }
   const PRUint32 GetScriptLine() const { return mScriptLine; }
 
 protected:
   nsresult ParseURL(const nsString& aURL);
   nsresult SetProtocol(const nsString& aProtocol);
   nsresult EstablishConnection();
 
@@ -151,21 +152,22 @@ protected:
   nsRefPtr<nsWebSocketEstablishedConnection> mConnection;
   PRUint32 mOutgoingBufferedAmount; // actually, we get this value from
                                     // mConnection when we are connected,
                                     // but we need this one after disconnecting.
 
   // Web Socket owner information:
   // - the script file name, UTF8 encoded.
   // - source code line number where the Web Socket object was constructed.
-  // - the window ID of the outer window where the script lives. Note that this 
-  // may not be the same as the Web Socket owner window.
+  // - the IDs of the outer and inner windows where the script lives. Note that
+  //   this may not be the same as the Web Socket owner window.
   // These attributes are used for error reporting.
   nsCString mScriptFile;
   PRUint32 mScriptLine;
   PRUint64 mWindowID;
+  PRUint64 mInnerWindowID;
 
 private:
   nsWebSocket(const nsWebSocket& x);   // prevent bad usage
   nsWebSocket& operator=(const nsWebSocket& x);
 };
 
 #endif
diff --git a/content/xml/document/src/nsXMLDocument.cpp b/content/xml/document/src/nsXMLDocument.cpp
--- a/content/xml/document/src/nsXMLDocument.cpp
+++ b/content/xml/document/src/nsXMLDocument.cpp
@@ -380,17 +380,20 @@ nsXMLDocument::Load(const nsAString& aUr
           do_CreateInstance(NS_SCRIPTERROR_CONTRACTID, &rv);
       NS_ENSURE_SUCCESS(rv, rv);
 
       rv = errorObject->InitWithWindowID(error.get(), NS_ConvertUTF8toUTF16(spec).get(),
                                          nsnull, 0, 0, nsIScriptError::warningFlag,
                                          "DOM",
                                          callingDoc ?
                                            callingDoc->OuterWindowID() :
-                                           this->OuterWindowID());
+                                           this->OuterWindowID(),
+                                         callingDoc ?
+                                           callingDoc->InnerWindowID() :
+                                           this->InnerWindowID());
 
       NS_ENSURE_SUCCESS(rv, rv);
 
       nsCOMPtr<nsIConsoleService> consoleService =
         do_GetService(NS_CONSOLESERVICE_CONTRACTID);
       nsCOMPtr<nsIScriptError> logError = do_QueryInterface(errorObject);
       if (consoleService && logError) {
         consoleService->LogMessage(logError);
diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -1785,17 +1785,18 @@ PrintWarningOnConsole(JSContext *cx, con
 
   nsresult rv = scriptError->InitWithWindowID(msg.get(),
                                               sourcefile.get(),
                                               EmptyString().get(),
                                               lineno,
                                               0, // column for error is not available
                                               nsIScriptError::warningFlag,
                                               "DOM:HTML",
-                                              nsJSUtils::GetCurrentlyRunningCodeWindowID(cx));
+                                              nsJSUtils::GetCurrentlyRunningCodeWindowID(cx),
+                                              nsJSUtils::GetCurrentlyRunningCodeInnerWindowID(cx));
 
   if (NS_SUCCEEDED(rv)){
     nsCOMPtr<nsIScriptError> logError = do_QueryInterface(scriptError);
     consoleService->LogMessage(logError);
   }
 }
 
 static inline JSString *
diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -272,21 +272,22 @@ class ScriptErrorEvent : public nsRunnab
 {
 public:
   ScriptErrorEvent(nsIScriptGlobalObject* aScriptGlobal,
                    PRUint32 aLineNr, PRUint32 aColumn, PRUint32 aFlags,
                    const nsAString& aErrorMsg,
                    const nsAString& aFileName,
                    const nsAString& aSourceLine,
                    PRBool aDispatchEvent,
-                   PRUint64 aWindowID)
+                   PRUint64 aWindowID,
+                   PRUint64 aInnerWindowID)
   : mScriptGlobal(aScriptGlobal), mLineNr(aLineNr), mColumn(aColumn),
     mFlags(aFlags), mErrorMsg(aErrorMsg), mFileName(aFileName),
     mSourceLine(aSourceLine), mDispatchEvent(aDispatchEvent),
-    mWindowID(aWindowID)
+    mWindowID(aWindowID), mInnerWindowID(aInnerWindowID)
   {}
 
   NS_IMETHOD Run()
   {
     nsEventStatus status = nsEventStatus_eIgnore;
     // First, notify the DOM that we have a script error.
     if (mDispatchEvent) {
       nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
@@ -369,17 +370,17 @@ public:
           ? "chrome javascript"
           : "content javascript";
 
         nsCOMPtr<nsIScriptError2> error2(do_QueryInterface(errorObject));
         if (error2) {
           rv = error2->InitWithWindowID(mErrorMsg.get(), mFileName.get(),
                                         mSourceLine.get(),
                                         mLineNr, mColumn, mFlags,
-                                        category, mWindowID);
+                                        category, mWindowID, mInnerWindowID);
         } else {
           rv = errorObject->Init(mErrorMsg.get(), mFileName.get(),
                                  mSourceLine.get(),
                                  mLineNr, mColumn, mFlags,
                                  category);
         }
 
         if (NS_SUCCEEDED(rv)) {
@@ -399,16 +400,17 @@ public:
   PRUint32                        mLineNr;
   PRUint32                        mColumn;
   PRUint32                        mFlags;
   nsString                        mErrorMsg;
   nsString                        mFileName;
   nsString                        mSourceLine;
   PRBool                          mDispatchEvent;
   PRUint64                        mWindowID;
+  PRUint64                        mInnerWindowID;
 
   static PRBool sHandlingScriptError;
 };
 
 PRBool ScriptErrorEvent::sHandlingScriptError = PR_FALSE;
 
 // NOTE: This function could be refactored to use the above.  The only reason
 // it has not been done is that the code below only fills the error event
@@ -479,23 +481,31 @@ NS_ScriptErrorReporter(JSContext *cx,
        * event because the dom event handler would encounter
        * an OOM exception trying to process the event, and
        * then we'd need to generate a new OOM event for that
        * new OOM instance -- this isn't pretty.
        */
       nsAutoString sourceLine;
       sourceLine.Assign(reinterpret_cast<const PRUnichar*>(report->uclinebuf));
       nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(globalObject);
-      PRUint64 windowID = win ? win->WindowID() : 0;
+      PRUint64 windowID = 0;
+      PRUint64 innerWindowID = 0;
+      if (win) {
+        windowID = win->WindowID();
+        nsCOMPtr<nsPIDOMWindow> innerWin = win->GetCurrentInnerWindow();
+        if (innerWin) {
+          innerWindowID = innerWin->WindowID();
+        }
+      }
       nsContentUtils::AddScriptRunner(
         new ScriptErrorEvent(globalObject, report->lineno,
                              report->uctokenptr - report->uclinebuf,
                              report->flags, msg, fileName, sourceLine,
                              report->errorNumber != JSMSG_OUT_OF_MEMORY,
-                             windowID));
+                             windowID, innerWindowID));
     }
   }
 
 #ifdef DEBUG
   // Print it to stderr as well, for the benefit of those invoking
   // mozilla with -console.
   nsCAutoString error;
   error.Assign("JavaScript ");
diff --git a/dom/base/nsJSUtils.cpp b/dom/base/nsJSUtils.cpp
--- a/dom/base/nsJSUtils.cpp
+++ b/dom/base/nsJSUtils.cpp
@@ -179,8 +179,33 @@ nsJSUtils::GetCurrentlyRunningCodeWindow
       if (win)
         windowID = win->GetOuterWindow()->WindowID();
     }
   }
 
   return windowID;
 }
 
+PRUint64
+nsJSUtils::GetCurrentlyRunningCodeInnerWindowID(JSContext *aContext)
+{
+  if (!aContext)
+    return 0;
+
+  PRUint64 innerWindowID = 0;
+
+  JSObject *jsGlobal = JS_GetGlobalForScopeChain(aContext);
+  if (jsGlobal) {
+    nsIScriptGlobalObject *scriptGlobal = GetStaticScriptGlobal(aContext,
+                                                                jsGlobal);
+    if (scriptGlobal) {
+      nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(scriptGlobal);
+      if (win) {
+        nsCOMPtr<nsPIDOMWindow> innerWin = win->GetCurrentInnerWindow();
+        if (innerWin)
+          innerWindowID = innerWin->WindowID();
+      }
+    }
+  }
+
+  return innerWindowID;
+}
+
diff --git a/dom/base/nsJSUtils.h b/dom/base/nsJSUtils.h
--- a/dom/base/nsJSUtils.h
+++ b/dom/base/nsJSUtils.h
@@ -74,16 +74,26 @@ public:
    * Retrieve the outer window ID based on the given JSContext.
    *
    * @param JSContext aContext
    *        The JSContext from which you want to find the outer window ID.
    *
    * @returns PRUint64 the outer window ID.
    */
   static PRUint64 GetCurrentlyRunningCodeWindowID(JSContext *aContext);
+
+  /**
+   * Retrieve the inner window ID based on the given JSContext.
+   *
+   * @param JSContext aContext
+   *        The JSContext from which you want to find the inner window ID.
+   *
+   * @returns PRUint64 the inner window ID.
+   */
+  static PRUint64 GetCurrentlyRunningCodeInnerWindowID(JSContext *aContext);
 };
 
 
 class nsDependentJSString : public nsDependentString
 {
 public:
   /**
    * In the case of string ids, getting the string's chars is infallible, so
diff --git a/dom/src/threads/nsDOMThreadService.cpp b/dom/src/threads/nsDOMThreadService.cpp
--- a/dom/src/threads/nsDOMThreadService.cpp
+++ b/dom/src/threads/nsDOMThreadService.cpp
@@ -662,17 +662,18 @@ DOMWorkerErrorReporter(JSContext* aCx,
 
   if (message.IsEmpty()) {
     message.AssignWithConversion(aMessage);
   }
 
   rv = scriptError2->InitWithWindowID(message.get(), filename.get(), line.get(),
                                       lineNumber, columnNumber, flags,
                                       "DOM Worker javascript",
-                                      worker->Pool()->WindowID());
+                                      worker->Pool()->WindowID(),
+                                      worker->Pool()->InnerWindowID());
 
   if (NS_FAILED(rv)) {
     return;
   }
 
   // Don't call the error handler if we're out of stack space.
   if (errorNumber != JSMSG_OVER_RECURSED) {
     // Try the onerror handler for the worker's scope.
diff --git a/dom/src/threads/nsDOMWorkerPool.cpp b/dom/src/threads/nsDOMWorkerPool.cpp
--- a/dom/src/threads/nsDOMWorkerPool.cpp
+++ b/dom/src/threads/nsDOMWorkerPool.cpp
@@ -65,17 +65,18 @@ using namespace mozilla;
 
 nsDOMWorkerPool::nsDOMWorkerPool(nsIScriptGlobalObject* aGlobalObject,
                                  nsIDocument* aDocument)
 : mParentGlobal(aGlobalObject),
   mParentDocument(aDocument),
   mReentrantMonitor("nsDOMWorkerPool.mReentrantMonitor"),
   mCanceled(PR_FALSE),
   mSuspended(PR_FALSE),
-  mWindowID(aDocument ? aDocument->OuterWindowID() : 0)
+  mWindowID(aDocument ? aDocument->OuterWindowID() : 0),
+  mInnerWindowID(aDocument ? aDocument->InnerWindowID() : 0)
 {
 }
 
 nsDOMWorkerPool::~nsDOMWorkerPool()
 {
   nsCOMPtr<nsIThread> mainThread;
   NS_GetMainThread(getter_AddRefs(mainThread));
 
diff --git a/dom/src/threads/nsDOMWorkerPool.h b/dom/src/threads/nsDOMWorkerPool.h
--- a/dom/src/threads/nsDOMWorkerPool.h
+++ b/dom/src/threads/nsDOMWorkerPool.h
@@ -84,16 +84,20 @@ public:
   ReentrantMonitor& GetReentrantMonitor() {
     return mReentrantMonitor;
   }
 
   const PRUint64 WindowID() const {
     return mWindowID;
   }
 
+  const PRUint64 InnerWindowID() const {
+    return mInnerWindowID;
+  }
+
 private:
   virtual ~nsDOMWorkerPool();
 
   void GetWorkers(nsTArray<nsDOMWorker*>& aArray);
 
   nsAutoRefCnt mRefCnt;
 
   // Reference to the window that created and owns this pool.
@@ -108,11 +112,12 @@ private:
 
   // ReentrantMonitor for suspending and resuming workers.
   ReentrantMonitor mReentrantMonitor;
 
   PRPackedBool mCanceled;
   PRPackedBool mSuspended;
 
   const PRUint64 mWindowID;
+  const PRUint64 mInnerWindowID;
 };
 
 #endif /* __NSDOMWORKERPOOL_H__ */
diff --git a/js/src/xpconnect/idl/nsIScriptError.idl b/js/src/xpconnect/idl/nsIScriptError.idl
--- a/js/src/xpconnect/idl/nsIScriptError.idl
+++ b/js/src/xpconnect/idl/nsIScriptError.idl
@@ -91,33 +91,42 @@ interface nsIScriptError : nsIConsoleMes
 
     AUTF8String toString();
 };
 
 /**
  * An interface that nsIScriptError objects can implement to allow
  * them to be initialized with a window id.
  */
-[scriptable, uuid(35cd0f6a-f5bb-497a-ba83-9c8d089b52cd)]
+[scriptable, uuid(4472646b-c928-4d76-9e7c-6b91da7f24cc)]
 interface nsIScriptError2 : nsISupports {
     /* Get the window id this was initialized with.  Zero will be
        returned if init() was used instead of initWithWindowId(). */
     readonly attribute unsigned long long outerWindowID;
 
+    /* Elapsed time, in milliseconds, from a platform-specific zero time to the
+       time the message was created. */
+    readonly attribute PRUint64 timeStamp;
+
+    /* Get the inner window id this was initialized with.  Zero will be
+       returned if init() was used instead of initWithWindowId(). */
+    readonly attribute unsigned long long innerWindowID;
+
     /* This should be called instead of nsIScriptError.init to
        initialize with a window id.  The window id should be for the
        outer window associated with this error. */
     void initWithWindowID(in wstring message,
                           in wstring sourceName,
                           in wstring sourceLine,
                           in PRUint32 lineNumber,
                           in PRUint32 columnNumber,
                           in PRUint32 flags,
                           in string category,
-                          in unsigned long long windowID);
+                          in unsigned long long windowID,
+                          in unsigned long long innerWindowID);
 };
 
 %{ C++
 #define NS_SCRIPTERROR_CLASSNAME "Script Error"
 
 #define NS_SCRIPTERROR_CID \
 { 0xe38e53b9, 0x5bb0, 0x456a, { 0xb5, 0x53, 0x57, 0x93, 0x70, 0xcb, 0x15, 0x67 }}
 
diff --git a/js/src/xpconnect/src/nsScriptError.cpp b/js/src/xpconnect/src/nsScriptError.cpp
--- a/js/src/xpconnect/src/nsScriptError.cpp
+++ b/js/src/xpconnect/src/nsScriptError.cpp
@@ -50,17 +50,19 @@ NS_IMPL_THREADSAFE_ISUPPORTS3(nsScriptEr
 nsScriptError::nsScriptError()
     :  mMessage(),
        mSourceName(),
        mLineNumber(0),
        mSourceLine(),
        mColumnNumber(0),
        mFlags(0),
        mCategory(),
-       mWindowID(0)
+       mWindowID(0),
+       mTimeStamp(0),
+       mInnerWindowID(0)
 {
 }
 
 nsScriptError::~nsScriptError() {}
 
 // nsIConsoleMessage methods
 NS_IMETHODIMP
 nsScriptError::GetMessageMoz(PRUnichar **result) {
@@ -126,37 +128,40 @@ nsScriptError::Init(const PRUnichar *mes
                     const PRUnichar *sourceName,
                     const PRUnichar *sourceLine,
                     PRUint32 lineNumber,
                     PRUint32 columnNumber,
                     PRUint32 flags,
                     const char *category)
 {
     return InitWithWindowID(message, sourceName, sourceLine, lineNumber,
-                            columnNumber, flags, category, 0);
+                            columnNumber, flags, category, 0, 0);
 }
 
 NS_IMETHODIMP
 nsScriptError::InitWithWindowID(const PRUnichar *message,
                                 const PRUnichar *sourceName,
                                 const PRUnichar *sourceLine,
                                 PRUint32 lineNumber,
                                 PRUint32 columnNumber,
                                 PRUint32 flags,
                                 const char *category,
-                                PRUint64 aWindowID)
+                                PRUint64 aWindowID,
+                                PRUint64 aInnerWindowID)
 {
     mMessage.Assign(message);
     mSourceName.Assign(sourceName);
     mLineNumber = lineNumber;
     mSourceLine.Assign(sourceLine);
     mColumnNumber = columnNumber;
     mFlags = flags;
     mCategory.Assign(category);
     mWindowID = aWindowID;
+    mTimeStamp = PR_Now();
+    mInnerWindowID = aInnerWindowID;
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsScriptError::ToString(nsACString& /*UTF8*/ aResult)
 {
     static const char format0[] =
@@ -218,8 +223,22 @@ nsScriptError::ToString(nsACString& /*UT
 }
 
 NS_IMETHODIMP
 nsScriptError::GetOuterWindowID(PRUint64 *aWindowID)
 {
     *aWindowID = mWindowID;
     return NS_OK;
 }
+
+NS_IMETHODIMP
+nsScriptError::GetTimeStamp(PRUint64 *aTimeStamp)
+{
+    *aTimeStamp = mTimeStamp;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsScriptError::GetInnerWindowID(PRUint64 *aInnerWindowID)
+{
+    *aInnerWindowID = mInnerWindowID;
+    return NS_OK;
+}
diff --git a/js/src/xpconnect/src/xpccomponents.cpp b/js/src/xpconnect/src/xpccomponents.cpp
--- a/js/src/xpconnect/src/xpccomponents.cpp
+++ b/js/src/xpconnect/src/xpccomponents.cpp
@@ -2863,16 +2863,17 @@ nsXPCComponents_Utils::ReportError()
         return NS_ERROR_XPC_NOT_ENOUGH_ARGS;
 
     jsval* argv;
     rv = cc->GetArgvPtr(&argv);
     if(NS_FAILED(rv) || !argv)
         return NS_OK;
 
     const PRUint64 windowID = nsJSUtils::GetCurrentlyRunningCodeWindowID(cx);
+    const PRUint64 innerWindowID = nsJSUtils::GetCurrentlyRunningCodeInnerWindowID(cx);
 
     JSErrorReport* err = JS_ErrorFromException(cx, argv[0]);
     if(err)
     {
         // It's a proper JS Error
         nsAutoString fileUni;
         CopyUTF8toUTF16(err->filename, fileUni);
 
@@ -2881,17 +2882,18 @@ nsXPCComponents_Utils::ReportError()
         rv = scripterr->InitWithWindowID(reinterpret_cast<const PRUnichar*>
                                                        (err->ucmessage),
                                          fileUni.get(),
                                          reinterpret_cast<const PRUnichar*>
                                                          (err->uclinebuf),
                                          err->lineno,
                                          column,
                                          err->flags,
-                                         "XPConnect JavaScript", windowID);
+                                         "XPConnect JavaScript",
+                                         windowID, innerWindowID);
         if(NS_FAILED(rv))
             return NS_OK;
 
         nsCOMPtr<nsIScriptError> logError = do_QueryInterface(scripterr);
         console->LogMessage(logError);
         return NS_OK;
     }
 
@@ -2918,17 +2920,18 @@ nsXPCComponents_Utils::ReportError()
         const jschar *msgchars = JS_GetStringCharsZ(cx, msgstr);
         if (!msgchars)
             return NS_OK;
 
         rv = scripterr->InitWithWindowID(reinterpret_cast<const PRUnichar *>(msgchars),
                                          NS_ConvertUTF8toUTF16(fileName).get(),
                                          nsnull,
                                          lineNo, 0,
-                                         0, "XPConnect JavaScript", windowID);
+                                         0, "XPConnect JavaScript",
+                                         windowID, innerWindowID);
         if(NS_SUCCEEDED(rv))
         {
             nsCOMPtr<nsIScriptError> logError = do_QueryInterface(scripterr);
             console->LogMessage(logError);
         }
     }
 
     return NS_OK;
diff --git a/js/src/xpconnect/src/xpcconvert.cpp b/js/src/xpconnect/src/xpcconvert.cpp
--- a/js/src/xpconnect/src/xpcconvert.cpp
+++ b/js/src/xpconnect/src/xpcconvert.cpp
@@ -1820,17 +1820,18 @@ XPCConvert::JSErrorToXPCException(XPCCal
             return NS_ERROR_OUT_OF_MEMORY;
 
 
         data->InitWithWindowID(bestMessage.get(),
                                NS_ConvertASCIItoUTF16(report->filename).get(),
                                (const PRUnichar *)report->uclinebuf, report->lineno,
                                report->uctokenptr - report->uclinebuf, report->flags,
                                "XPConnect JavaScript",
-                               nsJSUtils::GetCurrentlyRunningCodeWindowID(ccx.GetJSContext()));
+                               nsJSUtils::GetCurrentlyRunningCodeWindowID(ccx.GetJSContext()),
+                               nsJSUtils::GetCurrentlyRunningCodeInnerWindowID(ccx.GetJSContext()));
     }
 
     if(data)
     {
         nsCAutoString formattedMsg;
         data->ToString(formattedMsg);
 
         rv = ConstructException(NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS,
diff --git a/js/src/xpconnect/src/xpcprivate.h b/js/src/xpconnect/src/xpcprivate.h
--- a/js/src/xpconnect/src/xpcprivate.h
+++ b/js/src/xpconnect/src/xpcprivate.h
@@ -3904,16 +3904,18 @@ private:
     nsString mMessage;
     nsString mSourceName;
     PRUint32 mLineNumber;
     nsString mSourceLine;
     PRUint32 mColumnNumber;
     PRUint32 mFlags;
     nsCString mCategory;
     PRUint64 mWindowID;
+    PRUint64 mTimeStamp;
+    PRUint64 mInnerWindowID;
 };
 
 /***************************************************************************/
 
 class NS_STACK_CLASS AutoJSErrorAndExceptionEater
 {
 public:
     AutoJSErrorAndExceptionEater(JSContext* aCX
diff --git a/js/src/xpconnect/src/xpcwrappedjsclass.cpp b/js/src/xpconnect/src/xpcwrappedjsclass.cpp
--- a/js/src/xpconnect/src/xpcwrappedjsclass.cpp
+++ b/js/src/xpconnect/src/xpcwrappedjsclass.cpp
@@ -1213,17 +1213,18 @@ nsXPCWrappedJSClass::CheckForException(X
 
                                 nsCOMPtr<nsIScriptError2> scriptError2 =
                                     do_QueryInterface(scriptError);
                                 rv = scriptError2->InitWithWindowID(newMessage.get(),
                                                                     NS_ConvertASCIItoUTF16(sourceName).get(),
                                                                     nsnull,
                                                                     lineNumber, 0, 0,
                                                                     "XPConnect JavaScript",
-                                                                    nsJSUtils::GetCurrentlyRunningCodeWindowID(cx));
+                                                                    nsJSUtils::GetCurrentlyRunningCodeWindowID(cx),
+                                                                    nsJSUtils::GetCurrentlyRunningCodeInnerWindowID(cx));
                                 if(NS_FAILED(rv))
                                     scriptError = nsnull;
                             }
                         }
                     }
                     if(nsnull != scriptError)
                         consoleService->LogMessage(scriptError);
                 }
diff --git a/layout/style/nsCSSScanner.cpp b/layout/style/nsCSSScanner.cpp
--- a/layout/style/nsCSSScanner.cpp
+++ b/layout/style/nsCSSScanner.cpp
@@ -56,16 +56,17 @@
 #include "nsIConsoleService.h"
 #include "nsIScriptError.h"
 #include "nsIStringBundle.h"
 #include "nsIDocument.h"
 #include "mozilla/Services.h"
 #include "mozilla/css/Loader.h"
 #include "nsCSSStyleSheet.h"
 #include "mozilla/Preferences.h"
+#include "nsPIDOMWindow.h"
 
 using namespace mozilla;
 
 #ifdef CSS_REPORT_PARSE_ERRORS
 static PRBool gReportErrors = PR_TRUE;
 static nsIConsoleService *gConsoleService;
 static nsIFactory *gScriptErrorFactory;
 static nsIStringBundle *gStringBundle;
@@ -281,16 +282,17 @@ nsCSSToken::AppendToString(nsString& aBu
 nsCSSScanner::nsCSSScanner()
   : mInputStream(nsnull)
   , mReadPointer(nsnull)
   , mLowLevelError(NS_OK)
   , mSVGMode(PR_FALSE)
 #ifdef CSS_REPORT_PARSE_ERRORS
   , mError(mErrorBuf, NS_ARRAY_LENGTH(mErrorBuf), 0)
   , mWindowID(0)
+  , mInnerWindowID(0)
   , mWindowIDCached(PR_FALSE)
   , mSheet(nsnull)
   , mLoader(nsnull)
 #endif
 {
   MOZ_COUNT_CTOR(nsCSSScanner);
   mPushback = mLocalPushback;
   mPushbackSize = NS_ARRAY_LENGTH(mLocalPushback);
@@ -444,39 +446,48 @@ nsCSSScanner::OutputError()
 {
   if (mError.IsEmpty()) return;
  
   // Log it to the Error console
 
   if (InitGlobals() && gReportErrors) {
     if (!mWindowIDCached) {
       if (mSheet) {
-        mWindowID = mSheet->FindOwningWindowID();
+        nsCOMPtr<nsPIDOMWindow> window = mSheet->FindOwningWindow();
+        if (window) {
+          mWindowID = window->WindowID();
+          nsCOMPtr<nsPIDOMWindow> innerWindow = window->GetCurrentInnerWindow();
+          if (innerWindow) {
+            mInnerWindowID = innerWindow->WindowID();
+          }
+        }
       }
       if (mWindowID == 0 && mLoader) {
         nsIDocument* doc = mLoader->GetDocument();
         if (doc) {
           mWindowID = doc->OuterWindowID();
+          mInnerWindowID = doc->InnerWindowID();
         }
       }
       mWindowIDCached = PR_TRUE;
     }
 
     nsresult rv;
     nsCOMPtr<nsIScriptError2> errorObject =
       do_CreateInstance(gScriptErrorFactory, &rv);
 
     if (NS_SUCCEEDED(rv)) {
       rv = errorObject->InitWithWindowID(mError.get(),
                                          NS_ConvertUTF8toUTF16(mFileName).get(),
                                          EmptyString().get(),
                                          mErrorLineNumber,
                                          mErrorColNumber,
                                          nsIScriptError::warningFlag,
-                                         "CSS Parser", mWindowID);
+                                         "CSS Parser",
+                                         mWindowID, mInnerWindowID);
       if (NS_SUCCEEDED(rv)) {
         nsCOMPtr<nsIScriptError> logError = do_QueryInterface(errorObject);
         gConsoleService->LogMessage(logError);
       }
     }
   }
   ClearError();
 }
@@ -618,16 +629,17 @@ nsCSSScanner::Close()
   mReadPointer = nsnull;
 
   // Clean things up so we don't hold on to memory if our parser gets recycled.
 #ifdef CSS_REPORT_PARSE_ERRORS
   mFileName.Truncate();
   mURI = nsnull;
   mError.Truncate();
   mWindowID = 0;
+  mInnerWindowID = 0;
   mWindowIDCached = PR_FALSE;
   mSheet = nsnull;
   mLoader = nsnull;
 #endif
   if (mPushback != mLocalPushback) {
     delete [] mPushback;
     mPushback = mLocalPushback;
     mPushbackSize = NS_ARRAY_LENGTH(mLocalPushback);
diff --git a/layout/style/nsCSSScanner.h b/layout/style/nsCSSScanner.h
--- a/layout/style/nsCSSScanner.h
+++ b/layout/style/nsCSSScanner.h
@@ -244,15 +244,16 @@ protected:
   PRPackedBool mSVGMode;
 #ifdef CSS_REPORT_PARSE_ERRORS
   nsXPIDLCString mFileName;
   nsCOMPtr<nsIURI> mURI;  // Cached so we know to not refetch mFileName
   PRUint32 mErrorLineNumber, mColNumber, mErrorColNumber;
   nsFixedString mError;
   PRUnichar mErrorBuf[200];
   PRUint64 mWindowID;
+  PRUint64 mInnerWindowID;
   PRBool mWindowIDCached;
   nsCSSStyleSheet* mSheet;
   mozilla::css::Loader* mLoader;
 #endif
 };
 
 #endif /* nsCSSScanner_h___ */
diff --git a/layout/style/nsCSSStyleSheet.cpp b/layout/style/nsCSSStyleSheet.cpp
--- a/layout/style/nsCSSStyleSheet.cpp
+++ b/layout/style/nsCSSStyleSheet.cpp
@@ -67,16 +67,17 @@
 #include "nsXMLNameSpaceMap.h"
 #include "nsCOMPtr.h"
 #include "nsContentUtils.h"
 #include "nsIScriptSecurityManager.h"
 #include "mozAutoDocUpdate.h"
 #include "mozilla/css/Declaration.h"
 #include "nsRuleNode.h"
 #include "nsMediaFeatures.h"
+#include "nsPIDOMWindow.h"
 
 namespace css = mozilla::css;
 
 // -------------------------------
 // Style Rule List for the DOM
 //
 class CSSRuleListImpl : public nsICSSRuleList
 {
@@ -1247,49 +1248,49 @@ nsCSSStyleSheet::SetOwningDocument(nsIDo
   for (nsCSSStyleSheet* child = mInner->mFirstChild;
        child; child = child->mNext) {
     if (child->mParent == this) {
       child->SetOwningDocument(aDocument);
     }
   }
 }
 
-/* virtual */ PRUint64
-nsCSSStyleSheet::FindOwningWindowID() const
+nsPIDOMWindow*
+nsCSSStyleSheet::FindOwningWindow() const
 {
-  PRUint64 windowID = 0;
+  nsCOMPtr<nsPIDOMWindow> window;
   if (mDocument) {
-    windowID = mDocument->OuterWindowID();
+    window = mDocument->GetWindow();
   }
 
-  if (windowID == 0 && mOwningNode) {
+  if (!window && mOwningNode) {
     nsCOMPtr<nsIContent> node = do_QueryInterface(mOwningNode);
     if (node) {
       nsIDocument* doc = node->GetOwnerDoc();
       if (doc) {
-        windowID = doc->OuterWindowID();
+        window = doc->GetWindow();
       }
     }
   }
 
-  if (windowID == 0 && mOwnerRule) {
+  if (!window && mOwnerRule) {
     nsCOMPtr<nsIStyleSheet> sheet = static_cast<css::Rule*>(mOwnerRule)->GetStyleSheet();
     if (sheet) {
       nsRefPtr<nsCSSStyleSheet> cssSheet = do_QueryObject(sheet);
       if (cssSheet) {
-        windowID = cssSheet->FindOwningWindowID();
+        window = cssSheet->FindOwningWindow();
       }
     }
   }
 
-  if (windowID == 0 && mParent) {
-    windowID = mParent->FindOwningWindowID();
+  if (window && mParent) {
+    window = mParent->FindOwningWindow();
   }
 
-  return windowID;
+  return window;
 }
 
 void
 nsCSSStyleSheet::AppendStyleSheet(nsCSSStyleSheet* aSheet)
 {
   NS_PRECONDITION(nsnull != aSheet, "null arg");
 
   if (NS_SUCCEEDED(WillDirty())) {
diff --git a/layout/style/nsCSSStyleSheet.h b/layout/style/nsCSSStyleSheet.h
--- a/layout/style/nsCSSStyleSheet.h
+++ b/layout/style/nsCSSStyleSheet.h
@@ -56,16 +56,17 @@ class nsXMLNameSpaceMap;
 class nsCSSRuleProcessor;
 class nsMediaList;
 class nsIPrincipal;
 class nsIURI;
 class nsMediaList;
 class nsMediaQueryResultCacheKey;
 class nsCSSStyleSheet;
 class nsPresContext;
+class nsPIDOMWindow;
 template<class E, class A> class nsTArray;
 
 namespace mozilla {
 namespace css {
 class Rule;
 class GroupRule;
 class ImportRule;
 }
@@ -150,18 +151,18 @@ public:
   virtual PRBool IsApplicable() const;
   virtual void SetEnabled(PRBool aEnabled);
   virtual PRBool IsComplete() const;
   virtual void SetComplete();
   virtual nsIStyleSheet* GetParentSheet() const;  // may be null
   virtual nsIDocument* GetOwningDocument() const;  // may be null
   virtual void SetOwningDocument(nsIDocument* aDocument);
 
-  // Find the ID of the owner outer window.
-  virtual PRUint64 FindOwningWindowID() const;
+  // Find the owner outer window.
+  nsPIDOMWindow* FindOwningWindow() const; // may be null
 #ifdef DEBUG
   virtual void List(FILE* out = stdout, PRInt32 aIndent = 0) const;
 #endif
 
   void AppendStyleSheet(nsCSSStyleSheet* aSheet);
   void InsertStyleSheetAt(nsCSSStyleSheet* aSheet, PRInt32 aIndex);
 
   // XXX do these belong here or are they generic?
diff --git a/layout/style/nsFontFaceLoader.cpp b/layout/style/nsFontFaceLoader.cpp
--- a/layout/style/nsFontFaceLoader.cpp
+++ b/layout/style/nsFontFaceLoader.cpp
@@ -793,23 +793,24 @@ nsUserFontSet::LogMessage(gfxProxyFontEn
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsCOMPtr<nsIScriptError2> scriptError =
     do_CreateInstance(NS_SCRIPTERROR_CONTRACTID, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   PRUint64 windowID = GetPresContext()->Document()->OuterWindowID();
+  PRUint64 innerWindowID = GetPresContext()->Document()->InnerWindowID();
   rv = scriptError->InitWithWindowID(NS_ConvertUTF8toUTF16(msg).get(),
                                      href.get(),   // file
                                      text.get(),   // src line
                                      0, 0,         // line & column number
                                      aFlags,       // flags
                                      "CSS Loader", // category (make separate?)
-                                     windowID);
+                                     windowID, innerWindowID);
   if (NS_SUCCEEDED(rv)){
     nsCOMPtr<nsIScriptError> logError = do_QueryInterface(scriptError);
     if (logError) {
       console->LogMessage(logError);
     }
   }
 
   return NS_OK;
diff --git a/modules/libpr0n/src/Decoder.cpp b/modules/libpr0n/src/Decoder.cpp
--- a/modules/libpr0n/src/Decoder.cpp
+++ b/modules/libpr0n/src/Decoder.cpp
@@ -128,17 +128,17 @@ Decoder::Finish()
       nsAutoString msg(NS_LITERAL_STRING("Image corrupt or truncated: ") +
                        NS_ConvertASCIItoUTF16(mImage->GetURIString()));
 
       errorObject->InitWithWindowID
         (msg.get(),
          NS_ConvertUTF8toUTF16(mImage->GetURIString()).get(),
          nsnull,
          0, 0, nsIScriptError::errorFlag,
-         "Image", mImage->WindowID()
+         "Image", mImage->WindowID(), mImage->InnerWindowID()
          );
   
       nsCOMPtr<nsIScriptError> error = do_QueryInterface(errorObject);
       consoleService->LogMessage(error);
     }
 
     // If we only have a data error, see if things are worth salvaging
     bool salvage = !HasDecoderError() && mImage->GetNumFrames();
diff --git a/modules/libpr0n/src/Image.cpp b/modules/libpr0n/src/Image.cpp
--- a/modules/libpr0n/src/Image.cpp
+++ b/modules/libpr0n/src/Image.cpp
@@ -38,16 +38,17 @@
 #include "Image.h"
 
 namespace mozilla {
 namespace imagelib {
 
 // Constructor
 Image::Image(imgStatusTracker* aStatusTracker) :
   mWindowId(0),
+  mInnerWindowId(0),
   mAnimationConsumers(0),
   mAnimationMode(kNormalAnimMode),
   mInitialized(PR_FALSE),
   mAnimating(PR_FALSE),
   mError(PR_FALSE)
 {
   if (aStatusTracker) {
     mStatusTracker = aStatusTracker;
diff --git a/modules/libpr0n/src/Image.h b/modules/libpr0n/src/Image.h
--- a/modules/libpr0n/src/Image.h
+++ b/modules/libpr0n/src/Image.h
@@ -122,32 +122,37 @@ public:
 #ifdef DEBUG
   PRUint32 GetAnimationConsumers() { return mAnimationConsumers; }
 #endif
 
   void SetWindowID(PRUint64 aWindowId) {
     mWindowId = aWindowId;
   }
   PRUint64 WindowID() const { return mWindowId; }
+  void SetInnerWindowID(PRUint64 aInnerWindowId) {
+    mInnerWindowId = aInnerWindowId;
+  }
+  PRUint64 InnerWindowID() const { return mInnerWindowId; }
 
   PRBool HasError() { return mError; }
 
 protected:
   Image(imgStatusTracker* aStatusTracker);
 
   /**
    * Decides whether animation should or should not be happening,
    * and makes sure the right thing is being done.
    */
   virtual void EvaluateAnimation();
 
   virtual nsresult StartAnimation() = 0;
   virtual nsresult StopAnimation() = 0;
 
   PRUint64 mWindowId;
+  PRUint64 mInnerWindowId;
 
   // Member data shared by all implementations of this abstract class
   nsAutoPtr<imgStatusTracker> mStatusTracker;
   PRUint32                    mAnimationConsumers;
   PRUint16                    mAnimationMode;   // Enum values in imgIContainer
   PRPackedBool                mInitialized:1;   // Have we been initalized?
   PRPackedBool                mAnimating:1;     // Are we currently animating?
   PRPackedBool                mError:1;         // Error handling
diff --git a/modules/libpr0n/src/imgLoader.cpp b/modules/libpr0n/src/imgLoader.cpp
--- a/modules/libpr0n/src/imgLoader.cpp
+++ b/modules/libpr0n/src/imgLoader.cpp
@@ -1668,20 +1668,21 @@ NS_IMETHODIMP imgLoader::LoadImage(nsIUR
     nsCOMPtr<nsILoadGroup> loadGroup =
         do_CreateInstance(NS_LOADGROUP_CONTRACTID);
     newChannel->SetLoadGroup(loadGroup);
 
     void *cacheId = NS_GetCurrentThread();
     request->Init(aURI, aURI, loadGroup, newChannel, entry, cacheId, aCX,
                   aLoadingPrincipal, corsmode);
 
-    // Pass the windowID of the loading document, if possible.
+    // Pass the outer and inner window IDs of the loading document, if possible.
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(aCX);
     if (doc) {
       request->SetWindowID(doc->OuterWindowID());
+      request->SetInnerWindowID(doc->InnerWindowID());
     }
 
     // create the proxy listener
     nsCOMPtr<nsIStreamListener> pl = new ProxyListener(request.get());
 
     // See if we need to insert a CORS proxy between the proxy listener and the
     // request.
     nsCOMPtr<nsIStreamListener> listener = pl;
diff --git a/modules/libpr0n/src/imgRequest.cpp b/modules/libpr0n/src/imgRequest.cpp
--- a/modules/libpr0n/src/imgRequest.cpp
+++ b/modules/libpr0n/src/imgRequest.cpp
@@ -180,18 +180,19 @@ NS_IMPL_ISUPPORTS8(imgRequest,
                    nsIStreamListener, nsIRequestObserver,
                    nsISupportsWeakReference,
                    nsIChannelEventSink,
                    nsIInterfaceRequestor,
                    nsIAsyncVerifyRedirectCallback)
 
 imgRequest::imgRequest() : 
   mCacheId(0), mValidator(nsnull), mImageSniffers("image-sniffing-services"),
-  mWindowId(0), mCORSMode(imgIRequest::CORS_NONE), mDecodeRequested(PR_FALSE),
-  mIsMultiPartChannel(PR_FALSE), mGotData(PR_FALSE), mIsInCache(PR_FALSE)
+  mWindowId(0), mInnerWindowId(0), mCORSMode(imgIRequest::CORS_NONE),
+  mDecodeRequested(PR_FALSE), mIsMultiPartChannel(PR_FALSE), mGotData(PR_FALSE),
+  mIsInCache(PR_FALSE)
 {}
 
 imgRequest::~imgRequest()
 {
   if (mURI) {
     nsCAutoString spec;
     mURI->GetSpec(spec);
     LOG_FUNC_WITH_PARAM(gImgLog, "imgRequest::~imgRequest()", "keyuri", spec.get());
@@ -1032,16 +1033,17 @@ NS_IMETHODIMP imgRequest::OnDataAvailabl
 
     /* now we have mimetype, so we can infer the image type that we want */
     if (mContentType.EqualsLiteral(SVG_MIMETYPE)) {
       mImage = new VectorImage(mStatusTracker.forget());
     } else {
       mImage = new RasterImage(mStatusTracker.forget());
     }
     mImage->SetWindowID(mWindowId);
+    mImage->SetInnerWindowID(mInnerWindowId);
     imageType = mImage->GetType();
 
     // Notify any imgRequestProxys that are observing us that we have an Image.
     nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
     while (iter.HasMore()) {
       iter.GetNext()->SetImage(mImage);
     }
 
diff --git a/modules/libpr0n/src/imgRequest.h b/modules/libpr0n/src/imgRequest.h
--- a/modules/libpr0n/src/imgRequest.h
+++ b/modules/libpr0n/src/imgRequest.h
@@ -126,16 +126,24 @@ public:
   inline void SetWindowID(PRUint64 aWindowId) {
     mWindowId = aWindowId;
   }
 
   inline PRUint64 WindowID() const {
     return mWindowId;
   }
 
+  inline void SetInnerWindowID(PRUint64 aInnerWindowId) {
+    mInnerWindowId = aInnerWindowId;
+  }
+
+  inline PRUint64 InnerWindowID() const {
+    return mInnerWindowId;
+  }
+
   // Set the cache validation information (expiry time, whether we must
   // validate, etc) on the cache entry based on the request information.
   // If this function is called multiple times, the information set earliest
   // wins.
   static void SetCacheValidation(imgCacheEntry* aEntry, nsIRequest* aRequest);
 
   // The CORS mode for which we loaded this image.
   PRInt32 GetCORSMode() const { return mCORSMode; }
@@ -254,18 +262,19 @@ private:
   void *mLoadId;
   PRTime mLoadTime;
 
   imgCacheValidator *mValidator;
   nsCategoryCache<nsIContentSniffer> mImageSniffers;
   nsCOMPtr<nsIAsyncVerifyRedirectCallback> mRedirectCallback;
   nsCOMPtr<nsIChannel> mNewRedirectChannel;
 
-  // Originating outer window ID. Used for error reporting.
+  // Originating outer and inner window IDs. Both are used for error reporting.
   PRUint64 mWindowId;
+  PRUint64 mInnerWindowId;
 
   // The CORS mode (defined in imgIRequest) this image was loaded with. By
   // default, imgIRequest::CORS_NONE.
   PRInt32 mCORSMode;
 
   // Sometimes consumers want to do things before the image is ready. Let them,
   // and apply the action when the image becomes available.
   PRPackedBool mDecodeRequested : 1;
diff --git a/parser/htmlparser/src/nsExpatDriver.cpp b/parser/htmlparser/src/nsExpatDriver.cpp
--- a/parser/htmlparser/src/nsExpatDriver.cpp
+++ b/parser/htmlparser/src/nsExpatDriver.cpp
@@ -371,17 +371,18 @@ nsExpatDriver::nsExpatDriver()
     mInCData(PR_FALSE),
     mInInternalSubset(PR_FALSE),
     mInExternalDTD(PR_FALSE),
     mMadeFinalCallToExpat(PR_FALSE),
     mIsFinalChunk(PR_FALSE),
     mInternalState(NS_OK),
     mExpatBuffered(0),
     mCatalogData(nsnull),
-    mWindowID(0)
+    mWindowID(0),
+    mInnerWindowID(0)
 {
 }
 
 nsExpatDriver::~nsExpatDriver()
 {
   if (mExpatParser) {
     XML_ParserFree(mExpatParser);
   }
@@ -948,17 +949,17 @@ nsExpatDriver::HandleError()
   nsresult rv = NS_ERROR_FAILURE;
   if (serr) {
     nsCOMPtr<nsIScriptError2> serr2(do_QueryInterface(serr));
     rv = serr2->InitWithWindowID(description.get(),
                                  mURISpec.get(),
                                  mLastLine.get(),
                                  lineNumber, colNumber,
                                  nsIScriptError::errorFlag, "malformed-xml",
-                                 mWindowID);
+                                 mWindowID, mInnerWindowID);
   }
 
   // If it didn't initialize, we can't do any logging.
   PRBool shouldReportError = NS_SUCCEEDED(rv);
 
   if (mSink && shouldReportError) {
     rv = mSink->ReportError(errorText.get(), 
                             sourceText.get(), 
@@ -1247,16 +1248,20 @@ nsExpatDriver::WillBuildModel(const CPar
       nsIScriptGlobalObject *global =
         doc->GetScriptHandlingObject(aHasHadScriptHandlingObject);
       if (global) {
         win = do_QueryInterface(global);
       }
     }
     if (win) {
       mWindowID = win->GetOuterWindow()->WindowID();
+      nsCOMPtr<nsPIDOMWindow> innerWin = win->GetOuterWindow()->GetCurrentInnerWindow();
+      if (innerWin) {
+        mInnerWindowID = innerWin->WindowID();
+      }
     }
   }
 
   // Set up the callbacks
   XML_SetXmlDeclHandler(mExpatParser, Driver_HandleXMLDeclaration); 
   XML_SetElementHandler(mExpatParser, Driver_HandleStartElement,
                         Driver_HandleEndElement);
   XML_SetCharacterDataHandler(mExpatParser, Driver_HandleCharacterData);
diff --git a/parser/htmlparser/src/nsExpatDriver.h b/parser/htmlparser/src/nsExpatDriver.h
--- a/parser/htmlparser/src/nsExpatDriver.h
+++ b/parser/htmlparser/src/nsExpatDriver.h
@@ -165,11 +165,12 @@ private:
   nsCOMPtr<nsIExpatSink> mSink;
   nsCOMPtr<nsIExtendedExpatSink> mExtendedSink;
 
   const nsCatalogData* mCatalogData; // weak
   nsString         mURISpec;
 
   // Used for error reporting.
   PRUint64         mWindowID;
+  PRUint64         mInnerWindowID;
 };
 
 #endif
