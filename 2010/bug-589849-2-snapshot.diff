diff --git a/browser/base/Makefile.in b/browser/base/Makefile.in
--- a/browser/base/Makefile.in
+++ b/browser/base/Makefile.in
@@ -52,17 +52,16 @@ CHROME_DEPS += $(abs_srcdir)/content/ove
 ifdef ENABLE_TESTS
 DIRS += content/test
 endif
 
 EXTRA_JS_MODULES = \
 	content/openLocationLastURL.jsm \
 	content/NetworkPrioritizer.jsm \
 	content/domplate.jsm \
-	content/stylePanel.jsm \
 	$(NULL)
 
 include $(topsrcdir)/config/rules.mk
 
 PRE_RELEASE_SUFFIX := $(shell $(PYTHON) $(topsrcdir)/config/printprereleasesuffix.py \
                         $(shell cat $(srcdir)/../config/version.txt))
 
 DEFINES += \
diff --git a/browser/base/content/csshtmltree.js b/browser/base/content/csshtmltree.js
--- a/browser/base/content/csshtmltree.js
+++ b/browser/base/content/csshtmltree.js
@@ -521,95 +521,84 @@ PropertyView.prototype = {
    * the number of unmatched rules will be limited to the number given by 
    * {PropertyView.UNMATCHED_RULE_COUNT}.
    * @return {void}
    */
   _populateTemplate: function PropertyView_populateTemplate(showAll)
   {
     let self = this;
 
-    let cssInfo = this.tree.cssLogic.getCssInfo(this.name);
+    let propertyInfo = this.tree.cssLogic.getPropertyInfo(this.name);
 
     let rules = [];
 
     // TODO: We need a 'RuleView' to contain the view functionality from the
     // rule template. The implementation of this has been started, but it is
     // currently incomplete. We need this for the UI improvements that Limi has
     // suggested. See bug 590649.
-    cssInfo.rules.forEach(function(cssrule) {
+    /*cssInfo.rules.forEach(function(cssrule) {
       rules.push(new RuleView(this.tree, cssrule));
-    }, this);
+    }, this);*/
 
     let unmatchedRulesShown = 0;
 
     let data = {
       rules: rules, 
 
-      statusText: function(aStatus) {
-        return RuleView.STATUS_NAMES[aStatus];
+      statusText: function(aSelectorInfo) {
+        return RuleView.STATUS_NAMES[aSelectorInfo.status];
       },
 
-      selectorText: function(aSelector) {
-        let result = aSelector;
-        if (aSelector == "@element.style") {
+      selectorText: function(aSelectorInfo) {
+        let result = aSelectorInfo.selector.text;
+        if (result == "@element.style") {
           result = CssHtmlTree.l10n("style.elementSelector");
         }
         return result;
       },
 
-      specificityTitle: function(aRule) {
-        let specificity = aRule.specificity;
+      specificityTitle: function(aSelectorInfo) {
+        let specificity = aSelectorInfo.specificity;
 
         let important = "";
-        if (specificity.important) {
+        if (aSelectorInfo.important) {
           important += CssHtmlTree.l10n("style.property.important");
         }
 
         let result = "";
-        if (specificity.inline) {
+        if (aSelectorInfo.elementStyle) {
           result = important;
         } else {
           let ids = CssHtmlTree.l10n("style.rule.specificity.ids");
           let classes = CssHtmlTree.l10n("style.rule.specificity.classes");
           let tags = CssHtmlTree.l10n("style.rule.specificity.tags");
 
-          ids = PluralForm.get(specificity.ids, ids).replace("#1",
-            specificity.ids);
-          classes = PluralForm.get(specificity.classes, classes).replace("#1",
-            specificity.classes);
-          tags = PluralForm.get(specificity.tags, tags).replace("#1",
-            specificity.tags);
+          ids = PluralForm.get(specificity.ids, ids).
+            replace("#1", specificity.ids);
+          classes = PluralForm.get(specificity.classes, classes).
+            replace("#1", specificity.classes);
+          tags = PluralForm.get(specificity.tags, tags).
+            replace("#1", specificity.tags);
 
           result = CssHtmlTree._strings.
             formatStringFromName("style.rule.specificity",
               [[important, ids, classes, tags].join(" ")], 1);
         }
 
         return result;
       },
 
-      shouldShowRule: function(aRule) {
-        let result = true;
-        if (!aRule.sheetAllowed) {
-          result = false;
-        }
-
-        if (result && !showAll && aRule.status == CssLogic.STATUS.UNMATCHED) {
-          unmatchedRulesShown++;
-          result = unmatchedRulesShown <= PropertyView.UNMATCHED_RULE_COUNT;
-        }
-
-        return result;
-      },
-
       str: {}
     };
 
-    data.rules = cssInfo.rules;
+    data.selectors = cssInfo.matchedSelectors;
+    data.showMoreUnmatchedSelectors = false;
 
+
+    /*
     if (showAll || cssInfo.filteredUnmatchedRuleCount <=
       PropertyView.UNMATCHED_RULE_COUNT) {
       data.showMoreUnmatchedRules = false;
 
     } else {
       data.showMoreUnmatchedRules = true;
 
       let n = cssInfo.filteredUnmatchedRuleCount -
@@ -618,60 +607,83 @@ PropertyView.prototype = {
       let str = CssHtmlTree.l10n("style.rule.showMoreUnmatchedRules");
       data.str.showMoreUnmatchedRules = PluralForm.get(n, str).replace("#1", n);
 
       data.showMoreUnmatchedRulesClick =
         function showMoreUnmatchedRulesClick(aEvent) {
           aEvent.preventDefault();
           self._populateTemplate(true);
         };
-    }
+    }*/
 
     this.tree._template(this.tree.templateRules, this.element, data);
     this.populated = true;
   },
 
   /**
    * Get the computed style for the current property.
    *
    * @return {string} the computed style for the current property of the
    * currently highlighted element.
    */
   get value()
   {
-    return this.tree.cssLogic.getCssInfo(this.name).value;
+    return this.tree.cssLogic.getPropertyInfo(this.name).value;
   },
 
   /**
    * Compute the title of the property view. The title includes the number of
    * rules that hold the current property.
    *
    * @param {nsIDOMElement} aElement reference to the DOM element where the rule
    * title needs to be displayed.
    * @return {string} "" empty string. The rule title is computed
    * asynchronously.
    */
   ruleTitle: function PropertyView_ruleTitle(aElement)
   {
+    InspectorUI._log("ruleTitle 1 " + aElement);
+
+    let result = "";
+
+    InspectorUI._log("ruleTitle 2 " + aElement);
+
+    let ruleCount = this.tree.cssLogic.getPropertyInfo(this.name).
+      matchedRuleCount;
+
+    InspectorUI._log("ruleTitle 3 " + aElement);
+
+    if (ruleCount > 0) {
+      aElement.classList.add("rule-count");
+
+      let str = CssHtmlTree.l10n("style.property.numberOfRules");
+      result = PluralForm.get(ruleCount, str).replace("#1", ruleCount);
+    }
+
+    InspectorUI._log("ruleTitle 4 " + aElement);
+
+    return result;
+
+    /*
     Scheduler.addJob(function() {
       if (!InspectorUI.isStylePanelOpen) {
         return;
       }
 
       let ruleCount = this.tree.cssLogic.getCssInfo(this.name).
         filteredRuleCount;
       if (ruleCount > 0) {
         let str = CssHtmlTree.l10n("style.property.numberOfRules");
         aElement.textContent = PluralForm.get(ruleCount, str).
           replace("#1", ruleCount);
         aElement.classList.add("rule-count");
       }
     }, this);
 
-    return "";
+    return "";*/
   },
 
   /**
    * Close the property view.
    */
   close: function PropertyView_close()
   {
     if (this.element) {
diff --git a/browser/base/content/csshtmltree.xhtml b/browser/base/content/csshtmltree.xhtml
--- a/browser/base/content/csshtmltree.xhtml
+++ b/browser/base/content/csshtmltree.xhtml
@@ -127,31 +127,32 @@ To visually debug the templates without 
         title to use for the given rule.
     showMoreUnmatchedRules: true / false, // show a "more unmatched rules" link
     showMoreUnmatchedRulesClick: function() {}, // click event handler for the 
         "show more unmatched rules"
   }
   The table element is only there so the DOM doesn't muck with the tr
   -->
   <table id="templateRules">
-    <tr foreach="rule in ${rules}" if="${shouldShowRule(rule)}">
-      <td width="100%" class="rule-text status${rule.status}">
-        ${selectorText(rule.selector)} &#x2192; ${rule.value}
+    <tr foreach="selectors in ${selectors}">
+      <td width="100%" class="rule-text status${selector.status}">
+        ${selectorText(selector)} &#x2192; ${selector.value}
       </td>
-      <td class="rule-link"><a target="_blank" href="view-source:${rule.href}"
-          class="link" title="${rule.href}">${rule.source}</a></td>
+      <td class="rule-link"><a target="_blank"
+          href="view-source:${selector.href}"
+          class="link" title="${selector.href}">${selector.source}</a></td>
       <td class="rule-score">
-        <span title="${specificityTitle(rule)}">
-          ${statusText(rule.status)}:${rule.specificity}
+        <span title="${specificityTitle(selector)}">
+          ${statusText(selector)}:${selector.specificityScore}
         </span>
       </td>
     </tr>
-    <tr if="${showMoreUnmatchedRules}" class="showMoreUnmatchedRules">
+    <tr if="${showMoreUnmatchedSelectors}" class="showMoreUnmatchedRules">
       <td colspan="4">
-        <a href="#" onclick="${showMoreUnmatchedRulesClick}"
-          class="link">${str.showMoreUnmatchedRules}</a>
+        <a href="#" onclick="${showMoreUnmatchedSelectorsClick}"
+          class="link">${str.showMoreUnmatchedSelectors}</a>
       </td>
     </tr>
   </table>
 </div>
 
 </body>
 </html>
diff --git a/browser/base/content/csslogic.js b/browser/base/content/csslogic.js
--- a/browser/base/content/csslogic.js
+++ b/browser/base/content/csslogic.js
@@ -44,47 +44,46 @@
  * many questions about why the users styles did not work, specifically because
  * it only looks at the things that did. This approach takes into account all
  * the available styles, and shows why each rule is not applicable.
  *
  * <p>This approach can be considerably more costly while a page's stylesheets
  * are examined, so this class tries to be smart about the information that it
  * caches.
  *
- * <p>These functions could probably be merged into stylePanel.jsm.
- *
  * @constructor
- * @param {object} aStylePanel a reference to the stylePanel object instance
- * from the stylePanel.jsm file.
  */
-function CssLogic(aStylePanel)
+function CssLogic()
 {
-  // Instance of stylePanel.jsm.
-  this.stylePanel = aStylePanel;
-
   // Both setup by highlight().
   this.viewedElement = null;
   this.viewedDocument = null;
 
   // The cache of the known sheets.
-  this.sheets = [];
-  // Part of the specificity of a rule is its order in the sheet.
+  this._sheets = null;
+  // The total number of rules, in all stylesheets.
   this._ruleCount = 0;
 
   // The cache of examined CSS properties.
-  this._cssInfos = {};
+  this._propertyViews = {};
   // The computed styles for the viewedElement.
   this._computedStyle = null;
 
   // Source filter. Only display properties coming from the given source (web
   // address). Special values:
   // - "all": will show properties from all style sheets.
   // - "ua": will show properties from all style sheets, including the browser
   // styles (user agent ones).
   this._sourceFilter = "all";
+
+  // Used for tracking unique domRules, in a run of processMatchedSelectors.
+  this._matchId = 0;
+
+  this.domUtils = Cc["@mozilla.org/inspector/dom-utils;1"].
+    getService(Ci["inIDOMUtils"]);
 };
 
 /**
  * Each rule has a status, the bigger the number, the better placed it is to
  * provide styling information.
  *
  * These statuses are localized inside the inspector.properties string bundle.
  * @see csshtmltree.js RuleView._cacheStatusNames()
@@ -105,69 +104,39 @@ CssLogic.prototype = {
    * in the Inspector.
    */
   highlight: function CssLogic_highlight(aViewedElement)
   {
     if (!aViewedElement) {
       this.viewedElement = null;
       this.viewedDocument = null;
 
-      this.sheets = [];
+      this._sheets = null;
+      this._propertyInfos = {};
       this._ruleCount = 0;
-      this._cssInfos = {};
+      this._matchedRuleCount = 0;
 
       this._computedStyle = null;
+      this._matchedSelectors = null;
       return;
     }
 
     this.viewedElement = aViewedElement;
 
     let doc = this.viewedElement.ownerDocument;
     if (doc != this.viewedDocument) {
       // New document: clear/rebuild the cache.
       this.viewedDocument = doc;
 
-      this.sheets = [];
-      this._ruleCount = 0;
-      this._cssInfos = {};
-
       // Hunt down top level stylesheets, and cache them.
-      let domSheets = this.viewedDocument.styleSheets;
-      let domSheet;
-      for (let s = 0, n = domSheets.length; s < n; s++) {
-        domSheet = domSheets[s];
-        if (domSheet.disabled) {
-          continue;
-        }
-
-        // Only show stylesheets for media=screen.
-        if (domSheet.media.length > 0) {
-          let foundAllOrScreen = false;
-          let media = null;
-          for (m = 0; m < domSheet.media.length; m++) {
-            media = domSheet.media.item(m).toLowerCase();
-            if (media == "screen" || media == "all") {
-              foundAllOrScreen = true;
-              break;
-            }
-          }
-          if (!foundAllOrScreen) {
-            continue;
-          }
-        }
-
-        this._cacheSheet(domSheets[s]);
-      }
-    } else {
-      // Same document, new element: clear the match data for this element.
-      for (let property in this._cssInfos) {
-        this._cssInfos[property].unmarkMatches();
-      }
+      this._cacheSheets();
     }
 
+    this._matchedSelectors = null;
+    this._matchedRuleCount = 0;
     let win = this.viewedDocument.defaultView;
     this._computedStyle = win.getComputedStyle(this.viewedElement, "");
   },
 
   /**
    * Get the source filter.
    * @returns {string} The source filter being used.
    */
@@ -180,79 +149,241 @@ CssLogic.prototype = {
    * address). Special values:
    *  - "all": will show properties from all style sheets.
    *  - "ua": will show properties from all style sheets, including the browser
    *  styles (user agent ones).
    */
   set sourceFilter(aValue) {
     this._sourceFilter = aValue;
 
-    // Update the CssInfo objects.
-    for (let property in this._cssInfos) {
-      let cssInfo = this._cssInfos[property];
-      if (cssInfo._rules) {
-        cssInfo._findRules();
-        cssInfo._findElementRules();
-        if (!cssInfo._uaRules && this.sourceFilter == "ua") {
-          cssInfo._findUARules();
-        }
-      }
-      if (cssInfo._matched) {
-        cssInfo._markMatches();
+    // Update the CssPropertyInfo objects.
+    for (let property in this._propertyInfos) {
+      let propertyInfo = this._propertyInfos[property];
+      if (propertyInfo._matchedSelectors) {
+        propertyInfo._findMatchedSelectors();
       }
     }
   },
 
   /**
    * Return a CssInfo data structure for the currently viewed element and
    * the specified CSS property. If there is no currently viewed element we
    * return an empty object.
    * 
    * @param {string} aProperty The CSS property to look for.
    * @return a CssInfo structure for the given property
    */
-  getCssInfo: function CssLogic_getCssInfo(aProperty)
+  getPropertyInfo: function CssLogic_getPropertyInfo(aProperty)
   {
     if (!this.viewedElement) {
       return {};
     }
 
-    let cssInfo = this._cssInfos[aProperty];
-    if (!cssInfo) {
-      cssInfo = new CssInfo(this, aProperty);
-      this._cssInfos[aProperty] = cssInfo;
+    let info = this._propertyInfos[aProperty];
+    if (!info) {
+      info = new CssPropertyInfo(this, aProperty);
+      this._propertyInfos[aProperty] = info;
     }
 
-    return cssInfo;
+    return info;
   },
 
-  /**
-   * Cache stylesheets, including at-imported ones.
-   *
-   * @param {CSSStyleSheet} aDomSheet reference to a DOM CSSStyleSheet object.
-   */
-  _cacheSheet: function CssLogic_cacheSheet(aDomSheet)
+  _cacheSheets: function CssLogic_cacheSheets()
   {
-    // The rules in a '@import'ed sheet have a document order before the rules
-    // in the sheet itself. It's a bit like function hoisting in JavaScript.
-    // So we first look for @import rules.
-    for (let r = 0, n = aDomSheet.cssRules.length; r < n; r++) {
-      try {
-        let domRule = aDomSheet.cssRules[r];
+    this._sheets = {};
+    this._ruleCount = 0;
+    this._propertyInfos = {};
+    this._matchedSelectors = null;
+    this._matchedRuleCount = 0;
+    this._ruleCount = 0;
 
-        if (domRule.type === CSSRule.IMPORT_RULE) {
-          this._cacheSheet(domRule.styleSheet);
+    let domSheets = this.viewedDocument.styleSheets;
+    let domSheet;
+    for (let s = 0, n = domSheets.length; s < n; s++) {
+      domSheet = domSheets[s];
+      if (domSheet.disabled) {
+        continue;
+      }
+
+      // Only show stylesheets for media=screen.
+      if (domSheet.media.length > 0) {
+        let foundAllOrScreen = false;
+        let media = null;
+        for (m = 0; m < domSheet.media.length; m++) {
+          media = domSheet.media.item(m).toLowerCase();
+          if (media == "screen" || media == "all") {
+            foundAllOrScreen = true;
+            break;
+          }
         }
-      } catch (ex) {
-        Services.console.logStringMessage("Error in cacheSheet for domRule " +
-          r + ": " + ex);
+        if (!foundAllOrScreen) {
+          continue;
+        }
+      }
+
+      // Cache the sheet.
+      this.getCachedSheet(domSheet, false, s);
+    }
+  },
+
+  get sheets()
+  {
+    if (!this._sheets) {
+      this._cacheSheets();
+    }
+
+    let sheets = [];
+    for (let cacheId in this._sheets) {
+      sheets.push.apply(sheets, this._sheets[cacheId]);
+    }
+
+    return sheets;
+  },
+
+  getCachedSheet: function CssLogic_getCachedSheet(aDomSheet, aSystemSheet, aIndex)
+  {
+    let cacheId = aSystemSheet ? "1" : "0";
+
+    if (aDomSheet.href) {
+      cacheId += aDomSheet.href;
+    } else if (aDomSheet.ownerNode && aDomSheet.ownerNode.ownerDocument) {
+      cacheId += aDomSheet.ownerNode.ownerDocument.location;
+    }
+
+    let sheet = null;
+    let sheetFound = false;
+
+    if (cacheId in this._sheets) {
+      for (let i = 0, n = this._sheets[cacheId].length; i < n; i++) {
+        sheet = this._sheets[cacheId][i];
+        if (sheet._domSheet == aDomSheet) {
+          sheetFound = true;
+          break;
+        }
       }
     }
 
-    this.sheets.push(new CssSheet(aDomSheet));
+    if (!sheetFound) {
+      if (!(cacheId in this._sheets)) {
+        this._sheets[cacheId] = [];
+      }
+
+      sheet = new CssSheet(this, aDomSheet, aSystemSheet, aIndex);
+      sheet._cacheId = cacheId;
+      this._ruleCount += sheet.ruleCount;
+
+      this._sheets[cacheId].push(sheet);
+    }
+
+    return sheet;
+  },
+
+  get ruleCount()
+  {
+    if (!this._sheets) {
+      this._cacheSheets();
+    }
+
+    return this._ruleCount;
+  },
+
+  get matchedSelectorCount()
+  {
+    if (!this._sheets) {
+      this._cacheSheets();
+    }
+    if (!this._matchedSelectors) {
+      this.processMatchedSelectors();
+    }
+
+    return this._matchedSelectors.length;
+  },
+
+  get matchedRuleCount()
+  {
+    if (!this._sheets) {
+      this._cacheSheets();
+    }
+    if (!this._matchedSelectors) {
+      this.processMatchedSelectors();
+    }
+
+    return this._matchedRuleCount;
+  },
+
+  processMatchedSelectors: function CssLogic_processMatchedSelectors(aCallback, aScope)
+  {
+    if (this._matchedSelectors) {
+      if (aCallback) {
+        this._matchedSelectors.forEach(aCallback, aScope);
+      }
+      return;
+    }
+
+    this._matchedSelectors = [];
+    this._matchedRuleCount = 0;
+    this._matchId++;
+
+    let element = this.viewedElement;
+    let filter = this.sourceFilter;
+    let sheetIndex = 0;
+    let domRules = null;
+    do {
+      try {
+        domRules = this.domUtils.getCSSStyleRules(element);
+      } catch (ex) {
+        Services.console.
+          logStringMessage("CssLogic_processMatchedSelectors exception: " + ex);
+        continue;
+      }
+
+      for (let i = 0, n = domRules.Count(); i < n; i++) {
+        let domRule = domRules.GetElementAt(i);
+        if (domRule.type != CSSRule.STYLE_RULE) {
+          continue;
+        }
+
+        let domSheet = domRule.parentStyleSheet;
+        let systemSheet = CssLogic.isSystemStyleSheet(domSheet);
+        if (filter != "ua" && systemSheet) {
+          continue;
+        }
+
+        let sheet = this.getCachedSheet(domSheet, systemSheet, sheetIndex);
+        let rule = sheet.getCachedRule(domRule);
+
+        let status = this.viewedElement == element ?
+          CssLogic.STATUS.MATCHED : CssLogic.STATUS.PARENT_MATCH;
+
+        // Count the number of uniquely matched rules.
+        if (rule._matchId != this._matchId) {
+          this._matchedRuleCount++;
+        }
+        if (sheet._matchId != this._matchId) {
+          sheetIndex++;
+        }
+
+        let selectors = rule.selectors;
+
+        let tuple = [];
+        for (let s = 0, sn = selectors.length; s < sn; s++) {
+          if (element.mozMatchesSelector(selectors[s])) {
+            tuple = [selectors[s], status];
+            this._matchedSelectors.push(tuple);
+            if (aCallback) {
+              aCallback.call(aScope, tuple);
+            }
+          }
+        }
+
+        rule._matchId = this._matchId;
+        sheet._matchId = this._matchId;
+      }
+    } while ((element = element.parentNode) &&
+      element.nodeType == Node.ELEMENT_NODE);
   },
 };
 
 /**
  * If the element has an id, return '#id'. Otherwise return 'tagname[n]' where
  * n is the index of this element in its siblings.
  * <p>A technically more 'correct' output from the no-id case might be:
  * 'tagname:nth-of-type(n)' however this is unlikely to be more understood
@@ -321,90 +452,78 @@ CssLogic.l10n = function CssLogic_l10n(a
   if (!CssLogic._strings) {
     CssLogic._strings = Services.strings.createBundle(
         "chrome://browser/locale/inspector.properties");
   }
   return CssLogic._strings.GetStringFromName(aName);
 };
 
 /**
- * Split a rule.selectorText into an array of simpler selectors, taking into
- * consideration any nested selectors inside parentheses.
+ * Is the given property sheet a system (user agent) stylesheet?
  *
- * @param {string} selector The rule.selectorText you want split.
- * @return {array} the array of simpler selectors found in rule.selectorText.
+ * @param {CSSStyleSheet} aSheet a stylesheet
+ * @return {boolean} true if the given stylesheet is a system stylesheet or 
+ * false otherwise.
  */
-CssLogic.selectorTextSplit = function CssLogic_selectorTextSplit(selector) {
-  if (!selector) {
-    return [];
-  }
+CssLogic.isSystemStyleSheet = function CssLogic_isSystemStyleSheet(aSheet)
+{
+  if (!aSheet)
+    return true;
 
-  selector = selector.trim();
-  if (!selector) {
-    return [];
-  }
+  let url = aSheet.href;
 
-  let nesting = 0;
-  let result = [];
-  let currentSelector = [];
+  if (!url)
+    return false;
+  if (url.length == 0)
+    return true;
+  if (url[0] == 'h') 
+    return false;
+  if (url.substr(0, 9) == "resource:")
+    return true;
+  if (url.substr(0, 7) == "chrome:")
+    return true;
+  if (url  == "XPCSafeJSObjectWrapper.cpp")
+    return true;
+  if (url.substr(0, 6) == "about:")
+    return true;
 
-  for (let c, i = 0, n = selector.length; i < n; i++) {
-    c = selector.charAt(i);
-    switch (c) {
-      case ",":
-        if (nesting == 0 && currentSelector.length > 0) {
-          let newSelector = currentSelector.join("").trim();
-          if (newSelector) {
-            result.push(newSelector);
-          }
-          currentSelector = [];
-        } else {
-          currentSelector.push(c);
-        }
-        break;
-      case "(":
-        nesting++;
-        currentSelector.push(c);
-        break;
-      case ")":
-        nesting--;
-        currentSelector.push(c);
-        break;
-      default:
-        currentSelector.push(c);
-    }
-  }
-
-  // Add the last selector.
-  if (nesting == 0 && currentSelector.length > 0) {
-    let newSelector = currentSelector.join("").trim();
-    if (newSelector) {
-      result.push(newSelector);
-    }
-  }
-
-  return result;
+  return false;
 };
 
 /**
  * A safe each to access cache of bits of information about a stylesheet.
  *
  * @constructor
  * @param {CSSStyleSheet} aDomSheet reference to a DOM CSSStyleSheet object.
  * @param {boolean} aSystemSheet tells if the stylesheet is system-provided.
  */
-function CssSheet(aDomSheet, aSystemSheet)
+function CssSheet(aCssLogic, aDomSheet, aSystemSheet, aIndex)
 {
+  this._cssLogic = aCssLogic;
   this.domSheet = aDomSheet;
   this.systemSheet = aSystemSheet;
+  this.index = this.systemSheet ? -100 * aIndex : aIndex;
 
   // Cache of the sheets href. Cached by the getter.
   this._href = null;
   // Short version of href for use in select boxes etc. Cached by getter.
   this._shortSource = null;
+
+  let filter = this._cssLogic.sourceFilter;
+  if (filter == "ua" || filter == "all" || filter == this.href) {
+    this.sheetAllowed = true;
+  } else {
+    this.sheetAllowed = false;
+  }
+
+  // CssSheet objects are not cached initially.
+  this._cacheId = null;
+
+  // Cached CssRules from the given stylesheet.
+  this._rules = {};
 };
 
 CssSheet.prototype = {
   /**
    * Get a source for a stylesheet, taking into account embedded stylesheets
    * for which we need to use document.defaultView.location.href rather than
    * sheet.href
    *
@@ -444,553 +563,507 @@ CssSheet.prototype = {
       if (queryPos > 0) {
         this._shortSource = this._shortSource.substr(0, queryPos);
       }
     }
 
     return this._shortSource;
   },
 
-  toString: function CssSheet_toString()
-  {
-    return "CssSheet[" + this.shortSource + "]";
-  },
-};
-
-/**
- * A cache of information about the rules and values attached to a CSS property.
- *
- * @constructor
- * @param {CssLogic} aCssLogic reference to the CssLogic instance we are working
- * with.
- * @param {string} aProperty the CSS property name we are gathering information
- * for.
- */
-function CssInfo(aCssLogic, aProperty)
-{
-  this.property = aProperty;
-  if (aCssLogic._computedStyle) {
-    try {
-      this.value = aCssLogic._computedStyle.getPropertyValue(aProperty);
-    } catch (ex) {
-      Services.console.logStringMessage('Error reading computed style for ' + aProperty);
-      Services.console.logStringMessage(ex.toString());
-      this.value = "";
-    }
-  } else {
-    this.value = "";
-  }
-
-  this._matched = false;
-  this._localRules = false;
-  this._cssLogic = aCssLogic;
-  this._filteredRuleCount = 0;
-  this._unmatchedRuleCount = 0;
-  this._filteredUnmatchedRuleCount = 0;
-};
-
-CssInfo.prototype = {
-  /**
-   * ruleCount could be accessed through this.rules.length, however that means
-   * we need to have sorted them into the correct order, which could take time
-   * hence we have a separate accessor for the times when you just want to know
-   * how rules there are without getting access to the rule ordering.
-   *
-   * @return {number} the number of rules.
-   */
   get ruleCount()
   {
-    if (!this._rules) {
-      this._findRules();
-    }
-    if (!this._localRules) {
-      this._findElementRules();
-    }
-    if (!this._uaRules && this._cssLogic.sourceFilter == "ua") {
-      this._findUARules();
-    }
-
-    return this._rules.length;
+    return this.domSheet.cssRules.length;
   },
 
-  /**
-   * Retrieve the number of filtered rules.
-   *
-   * ruleCount could be accessed through this.rules.length, however that means
-   * we need to have sorted them into the correct order, which could take time
-   * hence we have a separate accessor for the times when you just want to know
-   * how rules there are without getting access to the rule ordering.
-   *
-   * @return {number} the number of filtered rules.
-   */
-  get filteredRuleCount()
+  getCachedRule: function CssSheet_getCachedRule(aDomRule)
   {
-    this.ruleCount; // Force an update.
-    return this._filteredRuleCount;
-  },
+    let cacheId = aDomRule.type + aDomRule.selectorText;
 
-  /**
-   * Retrieve the number of unmatched rules.
-   * @return {number} the number of unmatched rules.
-   */
-  get unmatchedRuleCount()
-  {
-    this.ruleCount; // Force an update.
-    if (!this._matched) {
-      this._markMatches();
-    }
+    let rule = null;
+    let ruleFound = false;
 
-    return this._unmatchedRuleCount;
-  },
-
-  /**
-   * Retrieve the number of unmatched rules, after filtering.
-   * @return {number} the number of unmatched rules, after filtering.
-   */
-  get filteredUnmatchedRuleCount()
-  {
-    this.unmatchedRuleCount; // Force an update.
-
-    return this._filteredUnmatchedRuleCount;
-  },
-
-  /**
-   * Accessor for a list of rules sorted by their applicability to the current
-   * element.
-   *
-   * @return {array}
-   */
-  get rules()
-  {
-    if (!this._rules) {
-      this._findRules();
-    }
-    if (!this._localRules) {
-      this._findElementRules();
-    }
-    if (!this._uaRules && this._cssLogic.sourceFilter == "ua") {
-      this._findUARules();
-    }
-
-    if (!this._matched) {
-      this._markMatches();
-    }
-
-    return this._rules;
-  },
-
-  /**
-   * Dig through all the sheets looking for matches for <tt>property</tt> and
-   * adding the results to <tt>rules</tt>.
-   */
-  _findRules: function CssInfo_findRules()
-  {
-    this._rules = [];
-    this._filteredRuleCount = 0;
-
-    let filter = this._cssLogic.sourceFilter;
-
-    // Loop over all of the filtered stylesheets, rules, and properties.
-    for (let s = 0; s < this._cssLogic.sheets.length; s++) {
-      let sheet = this._cssLogic.sheets[s];
-      let sheetAllowed = false;
-      if (filter == "all" || filter == "ua" || filter == sheet.href) {
-        sheetAllowed = true;
-      }
-
-      let domRules = sheet.domSheet.cssRules;
-      for (let r = 0; r < domRules.length; r++) {
-        let domRule = domRules[r];
-        if (domRule.style) {
-          for (let t = 0; t < domRule.style.length; t++) {
-            if (domRule.style[t] == this.property) {
-              if (!domRule.selectorText) {
-                // See https://bugzilla.mozilla.org/show_bug.cgi?id=591349
-                Services.console.logStringMessage('Found a domRule with no selectorText. ' + this.property + ' from ' + sheet.href);
-                // jlog('no selectorText in', domRule);
-              } else {
-                let selectors = CssLogic.selectorTextSplit(domRule.selectorText);
-                selectors.forEach(function(aSelector) {
-                  let rule = new CssRule(this._cssLogic, domRule, this.property,
-                      sheet, aSelector.trim());
-                  rule.sheetAllowed = sheetAllowed;
-                  this._rules.push(rule);
-                  if (sheetAllowed) {
-                    this._filteredRuleCount++;
-                  }
-                }, this);
-              }
-            }
-          }
-        }
-      }
-    }
-  },
-
-  /**
-   * Find the element.style rules.
-   */
-  _findElementRules: function CssInfo_findElementRules()
-  {
-    let element = this._cssLogic.viewedElement;
-    if (element.style && element.style.getPropertyValue(this.property) != "") {
-      let rule = new CssRule(this._cssLogic, {style: element.style},
-        this.property, null, "@element.style");
-      this._rules.push(rule);
-      this._filteredRuleCount++;
-    }
-    this._localRules = true;
-  },
-
-  /**
-   * Find the user-agent rules (Gecko-provided rules).
-   */
-  _findUARules: function CssInfo_findUARules()
-  {
-    let cssLogic = this._cssLogic;
-    let doc = this._cssLogic.viewedDocument;
-    let element = this._cssLogic.viewedElement;
-    let stylePanel = this._cssLogic.stylePanel;
-    let sheets = [];
-    let sheetsMap = {};
-
-    // Find the system sheets for the highlighted element.
-    let matchedRules = stylePanel.domUtils.getCSSStyleRules(element);
-    for (let i = 0, n = matchedRules.Count(); i < n; i++) {
-      let domRule = matchedRules.GetElementAt(i);
-      let domSheet = domRule.parentStyleSheet;
-      let href = domSheet.href;
-      if (!(href in sheetsMap) && domRule.style &&
-        stylePanel.isSystemStyleSheet(domSheet)) {
-        sheets.push(new CssSheet(domSheet, true));
-        sheetsMap[href] = true;
-      }
-    }
-
-    // Find all the rules in each system sheet.
-    for (let i = 0, n = sheets.length; i < n; i++) {
-      let sheet = sheets[i];
-      for (let r = 0, rn = sheet.domSheet.cssRules.length; r < rn; r++) {
-        let domRule = sheet.domSheet.cssRules[r];
-        if (!domRule.style) {
-          continue;
-        }
-        for (let t = 0, tn = domRule.style.length; t < tn; t++) {
-          if (!domRule.selectorText || domRule.style[t] != this.property) {
-            continue;
-          }
-
-          let selectors = CssLogic.selectorTextSplit(domRule.selectorText);
-          selectors.forEach(function(aSelector) {
-            let rule = new CssRule(this._cssLogic, domRule, this.property,
-              sheet, aSelector.trim(), true);
-            this._rules.push(rule);
-            this._filteredRuleCount++;
-          }, this);
+    if (cacheId in this._rules) {
+      for (let i = 0, n = this._rules[cacheId].length; i < n; i++) {
+        rule = this._rules[cacheId][i];
+        if (rule._domRule == aDomRule) {
+          ruleFound = true;
+          break;
         }
       }
     }
 
-    this._uaRules = true;
+    if (!ruleFound) {
+      if (!(cacheId in this._rules)) {
+        this._rules[cacheId] = [];
+      }
+
+      rule = new CssRule(this, aDomRule);
+      rule._cacheId = cacheId;
+
+      this._rules[cacheId].push(rule);
+    }
+
+    return rule;
   },
 
-  /**
-   * Go through the <tt>rules</tt> member of <tt>cssInfo</tt> and work out
-   * if each rule applies to <tt>viewedElement</tt>.
-   */
-  _markMatches: function CssInfo_markMatches()
+  toString: function CssSheet_toString()
   {
-    let parents = [];
-    let element = this._cssLogic.viewedElement;
-
-    while ((element = element.parentNode) &&
-      element.nodeType == Node.ELEMENT_NODE) {
-      parents.push(element);
-    }
-
-    this._unmatchedRuleCount = 0;
-    this._filteredUnmatchedRuleCount = 0;
-
-    for (let rule, r = 0, n = this._rules.length; r < n; r++) {
-      rule = this._rules[r];
-
-      // Do we have a selector match?
-      if (rule.selector == "@element.style" ||
-        this._cssLogic.viewedElement.mozMatchesSelector(rule.selector)) {
-        rule.status = CssLogic.STATUS.MATCHED;
-      } else {
-        // Do we have a parent match?
-        for (let p = 0, pn = parents.length; p < pn; p++) {
-          if (parents[p].mozMatchesSelector(rule.selector)) {
-            rule.status = CssLogic.STATUS.PARENT_MATCH;
-            break;
-          }
-        }
-
-        if (rule.status == CssLogic.STATUS.UNKNOWN) {
-          rule.status = CssLogic.STATUS.UNMATCHED;
-          this._unmatchedRuleCount++;
-          if (rule.sheetAllowed) {
-            this._filteredUnmatchedRuleCount++;
-          }
-        }
-      }
-    }
-
-    // Sort the arrays by how well they match the given element.
-    this._rules.sort(function(aRule1, aRule2) {
-      if (aRule1.status > aRule2.status) {
-        return -1;
-      } else if (aRule2.status > aRule1.status) {
-        return 1;
-      } else {
-        return aRule1.specificity.compareTo(aRule2.specificity);
-      }
-    });
-
-    // Now we know which of the matches is best, we can mark it BEST_MATCH.
-    if (this._rules.length > 0) {
-      if (this._rules[0].status > CssLogic.STATUS.UNMATCHED) {
-        this._rules[0].status = CssLogic.STATUS.BEST;
-      }
-    }
-
-    this._matched = true;
-  },
-
-  /**
-   * Undoes the changes made by _markMatches().
-   * For use when <tt>viewedElement</tt> changes (e.g. in highlight())
-   */
-  unmarkMatches: function CssInfo_unmarkMatches()
-  {
-    if (this._rules) {
-      let removeRules = [];
-
-      this._rules.forEach(function(aRule, aIndex) {
-        aRule.status = CssLogic.STATUS.UNKNOWN;
-        if (aRule.selector == "@element.style" || aRule.systemSheet) {
-          removeRules.push(aIndex);
-        }
-      }, this);
-
-      removeRules.forEach(function (aIndex) {
-        this._rules.splice(aIndex, 1);
-      }, this);
-
-      this._unmatchedRuleCount = 0;
-      this._filteredUnmatchedRuleCount = 0;
-    }
-
-    this._matched = false;
-    this._localRules = false;
-    this._uaRules = false;
-  },
-
-  toString: function CssInfo_toString()
-  {
-    return "CssInfo[" + this.property + "]";
+    return "CssSheet[" + this.shortSource + "]";
   },
 };
 
 /**
  * Information about a single CSS rule, with a simple selector (i.e. no commas)
  * and a single CSS property to which the rule applies.
  *
  * @constructor
- * @param {CssLogic} aCssLogic reference to the CssLogic instance we are working
- * with.
  * @param {DOMCSSRule|object} aDomRule the DOM CSSRule from which we have the
  * selector and the property. If the rule comes from element.style, then provide
  * an object like this {style: element.style}.
- * @param {string} aProperty the CSS property name we are gathering information
- * for.
- * @param {CSSStyleSheet|null} aSheet reference to the stylesheet where the
- * property and rule were found. Use null if the rule comes from element.style.
- * @param {string} aSelector the simple selector rule. If the rule comes from
- * element.style use "@element.style".
- * @param {boolean} aSystemSheet tells if the DOMCSSRule comes from a
- * system-provided stylesheet.
  */
-function CssRule(aCssLogic, aDomRule, aProperty, aSheet, aSelector, aSystemSheet)
+function CssRule(aCssSheet, aDomRule)
 {
-  this.property = aProperty;
-  this.selector = aSelector;
-  this.value = aDomRule.style.getPropertyValue(aProperty);
-  let pri = aDomRule.style.getPropertyPriority(aProperty);
-
-  let ruleCount;
-  if (this.selector == "@element.style") {
-    ruleCount = 0;
-  } else {
-    ruleCount = aCssLogic._ruleCount++;
-  }
-
-  this.systemSheet = aSystemSheet;
-  this.specificity = new CssSpecificity(this.selector, ruleCount, pri,
-    this.systemSheet);
+  this._cssSheet = aCssSheet;
+  this._domRule = aDomRule;
+  this._cacheId = null;
 
   // domUtils.getRuleLine fails for @import rules. See bug 591303.
   this.line = -1;
-  if (aCssLogic.stylePanel && this.selector != "@element.style") {
-    try {
-      this.line = aCssLogic.stylePanel.domUtils.getRuleLine(aDomRule);
-    } catch (ex) {
-      Services.console.logStringMessage("domUtils.getRuleLine failed for " +
-        aDomRule.cssText);
-    }
+  try {
+    this.line = this._cssSheet._cssLogic.domUtils.getRuleLine(this._domRule);
+  } catch (ex) {
+    Services.console.logStringMessage("domUtils.getRuleLine failed for " +
+      this._domRule.cssText);
   }
 
-  if (this.selector == "@element.style") {
-    this.source = CssLogic.l10n("style.rule.sourceElement");
-    this.href = "#";
-  } else {
-    this.source = (this.line == -1) ?
-        aSheet.shortSource :
-        aSheet.shortSource + ":" + this.line;
-    this.href = aSheet.href;
-  }
-
-  this.status = CssLogic.STATUS.UNKNOWN;
-  this.sheetAllowed = true;
-};
+  this._selectors = null;
+}
 
 CssRule.prototype = {
-  toString: function CssInfo_toString()
+  get source()
   {
-    return "CssRule[" + this.selector + "->" + this.value + "]";
+    return (this.line == -1) ? this._cssSheet.shortSource :
+        this._cssSheet.shortSource + ":" + this.line;
+  },
+
+  get systemRule()
+  {
+    return this._cssSheet.systemSheet;
+  },
+
+  get sheetAllowed()
+  {
+    return this._cssSheet.sheetAllowed;
+  },
+
+  get sheetIndex()
+  {
+    return this._cssSheet.index;
+  },
+
+  getPropertyValue: function(aProperty)
+  {
+    return this._domRule.style.getPropertyValue(aProperty);
+  },
+
+  getPropertyPriority: function(aProperty)
+  {
+    return this._domRule.style.getPropertyPriority(aProperty);
+  },
+
+  get selectors()
+  {
+    if (!this._selectors) {
+      this._selectorTextParser();
+    }
+
+    return this._selectors;
+  },
+
+  _selectorTextParser: function CssRule_selectorTextParser()
+  {
+    this._selectors = [];
+
+    if (!this._domRule.selectorText) {
+      return;
+    }
+
+    let selector = this._domRule.selectorText.trim();
+    if (!selector) {
+      return;
+    }
+
+    let nesting = 0;
+    let currentSelector = [];
+
+    for (let c, i = 0, n = selector.length; i < n; i++) {
+      c = selector.charAt(i);
+      switch (c) {
+        case ",":
+          if (nesting == 0 && currentSelector.length > 0) {
+            this._addSelector(currentSelector.join(""));
+            currentSelector = [];
+          } else {
+            currentSelector.push(c);
+          }
+        break;
+        case "(":
+          nesting++;
+        currentSelector.push(c);
+        break;
+        case ")":
+          nesting--;
+        currentSelector.push(c);
+        break;
+        default:
+        currentSelector.push(c);
+      }
+    }
+
+    // Add the last selector.
+    if (nesting == 0 && currentSelector.length > 0) {
+      this._addSelector(currentSelector.join(""));
+    }
+
+    this._selectors = result;
+  },
+
+  _addSelector: function CssRule_addSelector(aSelector)
+  {
+    aSelector = aSelector.trim();
+    if (aSelector) {
+      this._selectors.push(new CssSelector(this, aSelector));
+    }
   },
 };
 
 /**
- * The CSS specificity class allows us to document the ranking of various CSS
+ * The CSS selector class allows us to document the ranking of various CSS
  * rules.
  *
  * @constructor
  * @param {string} aSelector The selector that we wish to investigate
  * @param {number} aIndex The index of the rule in the HTML document. Later
  * rules have higher precedence (i.e. they are 'more specific')
  * See http://www.w3.org/TR/CSS2/cascade.html#cascade for details.
  * @param {string} aPriority CSS allows only one priority: 'important'
  * @param {boolean} aSystemSheet tells if the DOMCSSRule comes from a
  * system-provided stylesheet.
  * @see http://www.w3.org/TR/css3-selectors/#specificity
  * @see http://www.w3.org/TR/CSS2/selector.html
  */
-function CssSpecificity(aSelector, aIndex, aPriority, aSystemSheet)
+function CssSelector(aCssRule, aSelector)
 {
-  this.ids = 0;
-  this.classes = 0;
-  this.tags = 0;
-  this.index = aIndex;
-  this.important = (aPriority == "important");
-  this.system = aSystemSheet;
+  this._cssRule = aCssRule;
+  this.text = aSelector;
+  this.elementStyle = this.text == "@element.style";
+  this._specificity = null;
+}
 
-  // Split on CSS combinators (section 5.2).
-  if (aSelector != "@element.style") {
-    this.inline = false;
+CssSelector.prototype = {
+  get systemRule()
+  {
+    return this._cssRule.systemRule;
+  },
 
-    aSelector.split(/[ >+]/).forEach(function(aSimple) {
-      // The regex leaves empty nodes combinators like ' > '
-      if (!aSimple) {
-        return;
-      }
-      // See http://www.w3.org/TR/css3-selectors/#specificity
-      // We can count the IDs by counting the '#' marks.
-      this.ids += (aSimple.match(/#/g) || []).length;
-      // Similar with class names and attribute matchers
-      this.classes += (aSimple.match(/\./g) || []).length;
-      this.classes += (aSimple.match(/\[/g) || []).length;
-      // Pseudo elements count as elements.
-      this.tags += (aSimple.match(/:/g) || []).length;
-      // If we have anything of substance before we get into ids/classes/etc
-      // then it must be a tag if it isn't '*'.
-      let tag = aSimple.split(/[#.[:]/)[0];
-      if (tag && tag != "*") {
-        this.tags++;
-      }
-    }, this);
+  get sheetAllowed()
+  {
+    return this._cssRule.sheetAllowed;
+  },
+
+  get sheetIndex()
+  {
+    return this._cssRule.sheetIndex;
+  },
+
+  get ruleLine()
+  {
+    return this._cssRule.line;
+  },
+
+  get specificity()
+  {
+    if (this._specificity) {
+      return this._specificity;
+    }
+
+    let specificity = {};
+
+    specificity.ids = 0;
+    specificity.classes = 0;
+    specificity.tags = 0;
+
+    let selector = this._selector.toString();
+    // Split on CSS combinators (section 5.2).
+    // TODO: We need to properly parse the selector. See bug 590090.
+    if (!this.elementStyle) {
+      this.text.split(/[ >+]/).forEach(function(aSimple) {
+        // The regex leaves empty nodes combinators like ' > '
+        if (!aSimple) {
+          return;
+        }
+        // See http://www.w3.org/TR/css3-selectors/#specificity
+        // We can count the IDs by counting the '#' marks.
+        specificity.ids += (aSimple.match(/#/g) || []).length;
+        // Similar with class names and attribute matchers
+        specificity.classes += (aSimple.match(/\./g) || []).length;
+        specificity.classes += (aSimple.match(/\[/g) || []).length;
+        // Pseudo elements count as elements.
+        specificity.tags += (aSimple.match(/:/g) || []).length;
+        // If we have anything of substance before we get into ids/classes/etc
+        // then it must be a tag if it isn't '*'.
+        let tag = aSimple.split(/[#.[:]/)[0];
+        if (tag && tag != "*") {
+          specificity.tags++;
+        }
+      }, this);
+    }
+
+    this._specificity = specificity;
+
+    return this._specificity;
+  },
+
+  /**
+   * Displayable version of the specificity.
+   * @return {string}
+   */
+  toString: function CssSelector_toString()
+  {
+    return this.text;
+  },
+};
+
+/**
+ * A cache of information about the rules and values attached to a CSS property.
+ *
+ * @constructor
+ * @param {CssLogic} aCssLogic reference to the CssLogic instance we are working
+ * with.
+ * @param {string} aProperty the CSS property name we are gathering information
+ * for.
+ */
+function CssPropertyInfo(aCssLogic, aProperty)
+{
+  this._cssLogic = aCssLogic;
+  this.property = aProperty;
+  if (this._cssLogic._computedStyle) {
+    try {
+      this.value = this._cssLogic._computedStyle.getPropertyValue(aProperty);
+    } catch (ex) {
+      Services.console.logStringMessage('Error reading computed style for ' + aProperty);
+      Services.console.logStringMessage(ex.toString());
+      this.value = "";
+    }
   } else {
-    this.inline = true;
+    this.value = "";
   }
 
-  this.score = 0;
+  // The number of matched rules holding the this.property style property. Only
+  // rules that hold the this.property property are counted. Additionally, only
+  // rules that come from allowed stylesheets are counted.
+  this._matchedRuleCount = 0;
+
+  // An array holding CssSelectorInfo objects for each of the matched selector
+  // that is inside a CSS rule. Only rules that hold the this.property are
+  // counted. Additionally, only rules that come from allowed stylesheets
+  // are counted (this depends on CssLogic.sourceFilter).
+  this._matchedSelectors = null;
+}
+
+CssPropertyInfo.prototype = {
+  get matchedRuleCount()
+  {
+    if (!this._matchedSelectors) {
+      this._findMatchedSelectors();
+    }
+
+    return this._matchedRuleCount;
+  },
+
+  get matchedSelectors()
+  {
+    if (!this._matchedSelectors) {
+      this._findMatchedSelectors();
+    }
+
+    return this._matchedSelectors;
+  },
+
+  get unmatchedRuleCount()
+  {
+    return this._cssLogic.ruleCount - this.matchedRuleCount;
+  },
+
+  _findMatchedSelectors: function CssPropertyInfo_findMatchedSelectors()
+  {
+    this._matchedSelectors = [];
+    this._matchedRuleCount = 0;
+
+    this._cssLogic.processMatchedSelectors(this._processMatchedSelector, this);
+
+    // Sort the arrays by how well they match the given element.
+    this._matchedSelectors.sort(function(aSelectorInfo1, aSelectorInfo2) {
+      if (aSelectorInfo1.status > aSelectorInfo2.status) {
+        return -1;
+      } else if (aSelectorInfo2.status > aSelectorInfo1.status) {
+        return 1;
+      } else {
+        return aSelectorInfo1.compareTo(aSelectorInfo2);
+      }
+    });
+
+    // Now we know which of the matches is best, we can mark it BEST_MATCH.
+    if (this._matchedSelectors.length > 0 &&
+        this._matchedSelectors[0].status > CssLogic.STATUS.UNMATCHED) {
+      this._matchedSelectors[0].status = CssLogic.STATUS.BEST;
+    }
+  },
+
+  _processMatchedSelector: function CssPropertyInfo_processMatchedSelector(aParams)
+  {
+    let selector = aParams[0];
+    let status = aParams[1];
+
+    if (selector.sheetAllowed) {
+      let cssRule = selector._cssRule;
+      let value = cssRule.getPropertyValue(this.property);
+      if (value) {
+        let selectorInfo = new CssSelectorInfo(selector, this.property, value,
+          status);
+        this._matchedSelectors.push(selectorInfo);
+        if (this._cssLogic._matchId != cssRule._matchId) {
+          this._matchedRuleCount++;
+        }
+      }
+    }
+  },
+
+  toString: function CssPropertyInfo_toString()
+  {
+    return "CssPropertyInfo[" + this.property + "]";
+  },
+};
+
+function CssSelectorInfo(aSelector, aProperty, aValue, aStatus)
+{
+  this.selector = aSelector;
+  this.property = aProperty;
+  this.value = aValue;
+  this.status = aStatus;
+
+  let priority = this.selector._cssRule.getPropertyPriority(this.property);
+  this.important = priority == "important";
 
   /* Score prefix:
   0 UA normal property
   1 UA important property
   2 normal property
-  3 inline
+  3 inline (element.style)
   4 important
   5 inline important
   */
-  let scorePrefix = this.system ? 0 : 2;
-  if (this.inline) {
+  let scorePrefix = this.systemRule ? 0 : 2;
+  if (this.elementStyle) {
     scorePrefix++;
   }
   if (this.important) {
-    scorePrefix += this.system ? 1 : 2;
+    scorePrefix += this.systemRule ? 1 : 2;
   }
 
-  this.score = "" + scorePrefix + this.ids + this.classes + this.tags;
-};
+  this.specificityScore = "" + scorePrefix + this.specificity.ids +
+    this.specificity.classes + this.specificity.tags;
+}
 
-CssSpecificity.prototype = {
+CssSelectorInfo.prototype = {
+  get source()
+  {
+    let result = "";
+
+    if (this.selector.text == "@element.style") {
+      result = CssLogic.l10n("style.rule.sourceElement");
+    } else {
+      result = this.selector._cssRule.source;
+    }
+
+    return result;
+  },
+
+  get href()
+  {
+    return this.selector._cssRule._cssSheet ?
+      this.selector._cssRule._cssSheet.href : "#";
+  },
+
+  get elementStyle()
+  {
+    return this.selector.elementStyle;
+  },
+
+  get specificity()
+  {
+    return this.selector.specificity;
+  },
+
+  get sheetIndex()
+  {
+    return this.selector.sheetIndex;
+  },
+
+  get ruleLine()
+  {
+    return this.selector.ruleLine;
+  },
+
+  get systemRule()
+  {
+    return this.selector.systemRule;
+  },
+
   /**
-   * Compare the current CssSpecificity instance to another instance.
+   * Compare the current CssSelectorInfo instance to another instance.
    *
-   * @param {CssSpecificity} aThat The CssSpecificity instance to compare
+   * @param {CssSelectorInfo} aThat The CssSelector instance to compare
    * ourselves against.
    * @return number -1, 0, 1 depending on how aThat compares with this.
    */
-  compareTo: function CssSpecificity_compareTo(aThat)
+  compareTo: function CssSelectorInfo_compareTo(aThat)
   {
-    if (this.system && !aThat.system) return 1;
-    if (!this.system && aThat.system) return -1;
+    if (this.systemRule && !aThat.systemRule) return 1;
+    if (!this.systemRule && aThat.systemRule) return -1;
 
-    if (this.inline && !aThat.inline) {
+    if (this.elementStyle && !aThat.elementStyle) {
       if (!this.important && aThat.important) return 1;
       else return -1;
     }
 
-    if (!this.inline && aThat.inline) {
+    if (!this.elementStyle && aThat.elementStyle) {
       if (this.important && !aThat.important) return -1;
       else return 1;
     }
 
     if (this.important && !aThat.important) return -1;
     if (aThat.important && !this.important) return 1;
 
-    if (this.ids > aThat.ids) return -1;
-    if (aThat.ids > this.ids) return 1;
+    if (this.specificity.ids > aThat.specificity.ids) return -1;
+    if (aThat.specificity.ids > this.specificity.ids) return 1;
 
-    if (this.classes > aThat.classes) return -1;
-    if (aThat.classes > this.classes) return 1;
+    if (this.specificity.classes > aThat.specificity.classes) return -1;
+    if (aThat.specificity.classes > this.specificity.classes) return 1;
 
-    if (this.tags > aThat.tags) return -1;
-    if (aThat.tags > this.tags) return 1;
+    if (this.specificity.tags > aThat.specificity.tags) return -1;
+    if (aThat.specificity.tags > this.specificity.tags) return 1;
 
-    if (this.index > aThat.index) return -1;
-    if (aThat.index > this.index) return 1;
+    if (this.sheetIndex > aThat.sheetIndex) return -1;
+    if (aThat.sheetIndex > this.sheetIndex) return 1;
+
+    if (this.ruleLine > aThat.ruleLine) return -1;
+    if (aThat.ruleLine > this.ruleLine) return 1;
 
     return 0;
   },
 
-  /**
-   * Displayable version of the specificity.
-   * @return {string}
-   */
-  toString: function CssSpecificity_toString()
+  toString: function CssSelectorInfo_toString()
   {
-    let result = "";
-    if (this.score) {
-      result = this.score;
-    } else {
-      if (this.inline) {
-        let prefix = this.important ? "!," : " ,";
-        result = prefix + this.ids + "," + this.classes + "," + this.tags;
-      } else {
-        result = this.important ? "!" : " ";
-      }
-    }
-    return result;
+    return this.selector + " -> " + this.value;
   },
 };
+
diff --git a/browser/base/content/inspector.js b/browser/base/content/inspector.js
--- a/browser/base/content/inspector.js
+++ b/browser/base/content/inspector.js
@@ -681,17 +681,17 @@ var InspectorUI = {
     this.domBox = this.propertyPanel.tree;
     this.domTreeView = this.propertyPanel.treeView;
 
     // open inspector UI
     this.openTreePanel();
 
     // style panel setup and activation
     let styleWin = document.getElementById("inspector-style-browser");
-    this.cssLogic = new CssLogic(this.style);
+    this.cssLogic = new CssLogic();
     this.cssHtmlTree = new CssHtmlTree(styleWin, this.cssLogic);
     this.openStylePanel();
 
     // DOM panel setup and activation
     this.clearDOMPanel();
     this.openDOMPanel();
 
     // setup highlighter and start inspecting
@@ -1315,15 +1315,8 @@ XPCOMUtils.defineLazyGetter(InspectorUI,
 });
 
 XPCOMUtils.defineLazyGetter(InspectorUI, "PropertyPanel", function () {
   var obj = {};
   Cu.import("resource://gre/modules/PropertyPanel.jsm", obj);
   return obj.PropertyPanel;
 });
 
-XPCOMUtils.defineLazyGetter(InspectorUI, "style", function () {
-  var obj = {};
-  Cu.import("resource:///modules/stylePanel.jsm", obj);
-  obj.style.initialize();
-  return obj.style;
-});
-
diff --git a/browser/base/content/stylePanel.jsm b/browser/base/content/stylePanel.jsm
deleted file mode 100644
--- a/browser/base/content/stylePanel.jsm
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
- * Software License Agreement (BSD License)
- *
- * Copyright (c) 2007, Parakey Inc.
- * All rights reserved.
- * 
- * Redistribution and use of this software in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- * 
- * * Redistributions of source code must retain the above
- *   copyright notice, this list of conditions and the
- *   following disclaimer.
- * 
- * * Redistributions in binary form must reproduce the above
- *   copyright notice, this list of conditions and the
- *   following disclaimer in the documentation and/or other
- *   materials provided with the distribution.
- * 
- * * Neither the name of Parakey Inc. nor the names of its
- *   contributors may be used to endorse or promote products
- *   derived from this software without specific prior
- *   written permission of Parakey Inc.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
- * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Creator:
- *  Joe Hewitt
- * Contributors
- *  John J. Barton (IBM Almaden)
- *  Jan Odvarko (Mozilla Corp.)
- *  Max Stepanov (Aptana Inc.)
- *  Rob Campbell (Mozilla Corp.)
- *  Hans Hillen (Paciello Group, Mozilla)
- *  Curtis Bartley (Mozilla Corp.)
- *  Mike Collins (IBM Almaden)
- *  Kevin Decker
- *  Mike Ratcliffe (Comartis AG)
- *  Hernan Rodríguez Colmeiro
- *  Austin Andrews
- *  Christoph Dorn
- *  Steven Roussey (AppCenter Inc, Network54)
- */
-
-var EXPORTED_SYMBOLS = ["style"];
-
-const Cc = Components.classes;
-const Ci = Components.interfaces;
-const Cu = Components.utils;
-
-Cu.import("resource://gre/modules/Services.jsm");
-
-var style = {
-
-  /**
-   * initialize domUtils
-   */
-  initialize: function CSS_initialize()
-  {
-    this.domUtils = Cc["@mozilla.org/inspector/dom-utils;1"].
-      getService(Ci["inIDOMUtils"]);
-  },
-
-  /**
-   * Is the given property sheet a system (user agent) stylesheet?
-   *
-   * @param aSheet
-   *        a stylesheet
-   */
-  isSystemStyleSheet: function CSS_isSystemStyleSheet(aSheet)
-  {
-    if (!aSheet)
-      return true;
-
-    let url = aSheet.href;
-
-    if (!url)
-      return false;
-    if (url.length == 0)
-      return true;
-    if (url[0] == 'h') 
-      return false;
-    if (url.substr(0, 9) == "resource:")
-      return true;
-    if (url.substr(0, 7) == "chrome:")
-      return true;
-    if (url  == "XPCSafeJSObjectWrapper.cpp")
-      return true;
-    if (url.substr(0, 6) == "about:")
-      return true;
-
-    return false;
-  },
-
-  /**
-   * Parse properties from a given style object.
-   * Borrowed from Firebug's css.js.
-   *
-   * @param aStyle
-   *        a style object
-   */
-  parseCSSProperties: function CSS_parseCSSProps(aStyle)
-  {
-    let properties = [];
-    let lines = aStyle.cssText.match(/(?:[^;\(]*(?:\([^\)]*?\))?[^;\(]*)*;?/g);
-    let propRE = /\s*([^:\s]*)\s*:\s*(.*?)\s*(! important)?;?$/;
-    let line, i = 0;
-    while(line = lines[i++]) {
-      let match = propRE.exec(line);
-      if (!match)
-        continue;
-      let name = match[1];
-      let value = match[2];
-      let important = !!match[3]; // true if match[3] is non-empty
-      properties.unshift({name: name, value: value, important: important});
-    }
-
-    return properties;
-  },
-
-  /**
-   * Mark properties overridden further up the hierarchy.
-   *
-   * @param aProps
-   *        Array of properties.
-   * @param aUsedProps
-   *        Object of arrays keyed by property name.
-   * @param aInherit
-   *        Boolean of whether or not we are in inherited mode.
-   */
-  markOverriddenProperties: function CSS_markOverriddenProperties(aProps, aUsedProps, aInherit)
-  {
-    for (let i = 0; i < aProps.length; ++i) {
-      let prop = aProps[i];
-      if (aUsedProps.hasOwnProperty(prop.name)) {
-        // all previous occurrences of this property
-        let deadProps = aUsedProps[prop.name];
-        for (let j = 0; j < deadProps.length; ++j) {
-          let deadProp = deadProps[j];
-          if (!deadProp.disabled && !deadProp.wasInherited &&
-              deadProp.important && !prop.important) {
-            prop.overridden = true;  // new occurrence overridden
-          } else if (!prop.disabled) {
-            deadProp.overridden = true;  // previous occurrences overridden
-          } else {
-            aUsedProps[prop.name] = [];
-          }
-
-          prop.wasInherited = aInherit ? true : false;
-          // all occurrences of a property seen so far, by name
-          aUsedProps[prop.name].push(prop);
-        }
-      }
-    }
-  },
-
-  /**
-   * Sort given properties in lexical order by name.
-   *
-   * @param properties
-   *        An array of properties.
-   * @returns sorted array.
-   */
-  sortProperties: function CSS_sortProperties(properties)
-  {
-    properties.sort(function(a, b)
-    {
-      if (a.name < b.name) {
-        return -1;
-      }
-      if (a.name > b.name) {
-        return 1;
-      }
-      return 0;
-    });
-  },
-
-  /**
-   * Get properties for a given element and push them to the rules array.
-   *
-   * @param aNode
-   *        a DOM node
-   * @param rules
-   *        An array of rules to add properties to.
-   * @param usedProps
-   *        Object of arrays keyed by property name.
-   * @param inherit
-   *        boolean determining whether or not we're in inherit mode
-   */
-  getStyleProperties: function CSS_getStyleProperties(aNode, aRules, aUsedProps, aInherit)
-  {
-    let properties = this.parseCSSProperties(aNode.style, aInherit);
-
-    this.sortProperties(properties);
-    this.markOverriddenProperties(properties, aUsedProps, aInherit);
-
-    if (properties.length) {
-      aRules.push({rule: aNode, selector: "element.style",
-        properties: properties, inherited: aInherit});
-    }
-  },
-
-  /**
-   * Get properties for a given rule.
-   *
-   * @param aRule
-   *        A Rule from a stylesheet.
-   */
-  getRuleProperties: function CSS_getRuleProperties(aRule)
-  {
-    let style = aRule.style;
-    return this.parseCSSProperties(style);
-  },
-
-  /**
-   * Recursively get rules for an element's parents and add them to the
-   * sections array.
-   *
-   * @param aNode
-   *        an element in a DOM tree.
-   * @param sections
-   *        an array of sections
-   * @param usedProps
-   *        Object of arrays keyed by property name.
-   */
-  getInheritedRules: function CSS_getInheritedRules(aNode, aSections, aUsedProps)
-  {
-    let parent = aNode.parentNode;
-    if (parent && parent.nodeType == 1) {
-      this.getInheritedRules(parent, aSections, aUsedProps);
-
-      let rules = [];
-      this.getElementRules(parent, rules, aUsedProps, true);
-
-      if (rules.length) {
-        aSections.unshift({element: parent, rules: rules});
-      }
-    }
-  },
-
-  /**
-   * Get the CSS style rules for a given node in the DOM and append them to the
-   * rules array.
-   *
-   * @param aNode
-   *        an element in the DOM tree.
-   * @param aRules
-   *        an array of rules.
-   * @param aUsedProps
-   *        Object of arrays keyed by property name.
-   * @param aInherit
-   *        boolean indicating whether we are in an inherited mode or not
-   */
-  getElementRules: function CSS_getElementRules(aNode, aRules, aUsedProps, aInherit)
-  {
-    let inspectedRules;
-
-    try {
-      inspectedRules = this.domUtils.getCSSStyleRules(aNode);
-    } catch (ex) {
-      Services.console.logStringMessage(ex);
-    }
-
-    if (!inspectedRules)
-      return;
-
-    for (let i = 0; i < inspectedRules.Count(); ++i) {
-      let rule = inspectedRules.GetElementAt(i);
-      let href = rule.parentStyleSheet.href;
-
-      if (!href) {
-        // Null href means inline style.
-        href = aNode.ownerDocument.location.href;
-      }
-
-      let isSystemSheet = this.isSystemStyleSheet(rule.parentStyleSheet);
-
-      if (isSystemSheet)
-        continue;
-
-      let properties = this.getRuleProperties(rule, aInherit);
-      if (aInherit && !properties.length)
-        continue;
-
-      let line = this.domUtils.getRuleLine(rule);
-      let ruleId = rule.selectorText + " " + href + " (" + line + ")";
-
-      let sourceLink = "view-source:" + href + "#" + line;
-
-      this.markOverriddenProperties(properties, aUsedProps, aInherit);
-
-      aRules.unshift(
-        {rule: rule,
-         id: ruleId,
-         selector: rule.selectorText,
-         properties: properties,
-         inherited: aInherit,
-         sourceLink: sourceLink,
-         isSystemSheet: isSystemSheet});
-    }
-
-    if (aNode.style) {
-      this.getStyleProperties(aNode, aRules, aUsedProps, aInherit);
-    }
-  },
-};
-
